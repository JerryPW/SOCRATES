[
    {
        "function_name": "editCounterPart",
        "vulnerability": "Unauthorized modification of counterpart",
        "criticism": "The reasoning is correct. The function allows the swap creator to change the counterparty address unilaterally, which can be exploited to defraud the original counterparty by replacing them with an address controlled by the creator. This is a significant vulnerability as it undermines the integrity of the swap process. The severity is high because it directly affects the trust and security of the swap mechanism. The profitability is moderate to high, as the creator can potentially redirect valuable assets to themselves or an accomplice.",
        "correctness": 8,
        "severity": 7,
        "profitability": 6,
        "reason": "The function allows the swap creator to unilaterally change the counterparty address of a swap intent after its creation. This could be exploited to replace the intended counterparty with an address controlled by the creator, potentially defrauding the original counterparty.",
        "code": "function editCounterPart(uint256 _swapId, address payable _counterPart) public { require(checksCreator[_swapId] == msg.sender, \"You're not the interested counterpart\"); require(msg.sender == swapList[msg.sender][swapMatch[_swapId]].addressOne, \"Message sender must be the swap creator\"); checksCounterparty[_swapId] = _counterPart; swapList[msg.sender][swapMatch[_swapId]].addressTwo = _counterPart; }",
        "file_name": "0x13d8faf4a690f5ae52e2d2c52938d1167057b9af.sol"
    },
    {
        "function_name": "cancelSwapIntent",
        "vulnerability": "Reentrancy attack potential",
        "criticism": "The reasoning is partially correct. The function does transfer ETH back to the swap creator without following the checks-effects-interactions pattern, which is a known best practice to prevent reentrancy attacks. However, the function is marked as nonReentrant, which should prevent reentrancy attacks. The severity is low because the nonReentrant modifier mitigates the risk. The profitability is also low because an attacker cannot exploit this vulnerability due to the nonReentrant protection.",
        "correctness": 5,
        "severity": 2,
        "profitability": 1,
        "reason": "The function allows for the transfer of ETH back to the swap creator without using the checks-effects-interactions pattern. This can potentially open the function to a reentrancy attack where an attacker could repeatedly call the cancel function before the state is updated, draining funds.",
        "code": "function cancelSwapIntent(uint256 _swapId) public nonReentrant { require(checksCreator[_swapId] == msg.sender, \"You're not the interested counterpart\"); require(swapList[msg.sender][swapMatch[_swapId]].addressOne == msg.sender, \"You're not the interested counterpart\"); require(swapList[msg.sender][swapMatch[_swapId]].status == swapStatus.Opened, \"Swap Status is not opened\"); if(swapList[msg.sender][swapMatch[_swapId]].swapFee>0) payable(msg.sender).transfer(swapList[msg.sender][swapMatch[_swapId]].swapFee); uint256 i; for(i=0; i<nftsOne[_swapId].length; i++) { if(nftsOne[_swapId][i].typeStd == ERC20) { ERC20Interface(nftsOne[_swapId][i].dapp).transfer(swapList[msg.sender][swapMatch[_swapId]].addressOne, nftsOne[_swapId][i].blc[0]); } else if(nftsOne[_swapId][i].typeStd == ERC721) { ERC721Interface(nftsOne[_swapId][i].dapp).safeTransferFrom(address(this), swapList[msg.sender][swapMatch[_swapId]].addressOne, nftsOne[_swapId][i].tokenId[0], nftsOne[_swapId][i].data); } else if(nftsOne[_swapId][i].typeStd == ERC1155) { ERC1155Interface(nftsOne[_swapId][i].dapp).safeBatchTransferFrom(address(this), swapList[msg.sender][swapMatch[_swapId]].addressOne, nftsOne[_swapId][i].tokenId, nftsOne[_swapId][i].blc, nftsOne[_swapId][i].data); } else { customInterface(dappRelations[nftsOne[_swapId][i].dapp]).bridgeSafeTransferFrom(nftsOne[_swapId][i].dapp, dappRelations[nftsOne[_swapId][i].dapp], swapList[msg.sender][swapMatch[_swapId]].addressOne, nftsOne[_swapId][i].tokenId, nftsOne[_swapId][i].blc, nftsOne[_swapId][i].data); } } if(swapList[msg.sender][swapMatch[_swapId]].valueOne > 0) swapList[msg.sender][swapMatch[_swapId]].addressOne.transfer(swapList[msg.sender][swapMatch[_swapId]].valueOne); swapList[msg.sender][swapMatch[_swapId]].swapEnd = block.timestamp; swapList[msg.sender][swapMatch[_swapId]].status = swapStatus.Cancelled; emit swapEvent(msg.sender, (block.timestamp-(block.timestamp%secs)), swapStatus.Cancelled, _swapId, address(0)); }",
        "file_name": "0x13d8faf4a690f5ae52e2d2c52938d1167057b9af.sol"
    },
    {
        "function_name": "createSwapIntent",
        "vulnerability": "Inadequate validation and handling of ERC20 transfer",
        "criticism": "The reasoning is correct. The function does not check the return value of the ERC20 transferFrom function, which can fail silently if the token contract does not revert on failure. This can lead to a situation where the contract does not actually receive the ERC20 tokens, resulting in a loss of funds for the user. The severity is moderate because it can lead to financial loss for users. The profitability is low because an external attacker cannot directly profit from this vulnerability, but it can cause indirect losses.",
        "correctness": 8,
        "severity": 5,
        "profitability": 2,
        "reason": "The function does not check the return value of the ERC20 `transferFrom` function, which can fail silently if the token contract does not revert on failure. This can result in a situation where the contract does not actually receive the ERC20 tokens, leading to a loss of funds for the user. Additionally, the function assumes that all ERC20 tokens follow the same standards without verifying the transfer success.",
        "code": "function createSwapIntent(swapIntent memory _swapIntent, swapStruct[] memory _nftsOne, swapStruct[] memory _nftsTwo) payable public whenNotPaused nonReentrant { if(payment.status) { if(ERC721Interface(TRADESQUAD).balanceOf(msg.sender)==0) { require(msg.value>=payment.value.add(_swapIntent.valueOne), \"Not enought WEI for handle the transaction\"); _swapIntent.swapFee = getWeiPayValueAmount() ; } else { require(msg.value>=_swapIntent.valueOne, \"Not enought WEI for handle the transaction\"); _swapIntent.swapFee = 0 ; } } else require(msg.value>=_swapIntent.valueOne, \"Not enought WEI for handle the transaction\"); _swapIntent.addressOne = payable(msg.sender); _swapIntent.id = _swapIds.current(); checksCreator[_swapIntent.id] = _swapIntent.addressOne ; checksCounterparty[_swapIntent.id] = _swapIntent.addressTwo ; _swapIntent.swapStart = block.timestamp; _swapIntent.swapEnd = 0; _swapIntent.status = swapStatus.Opened ; swapMatch[_swapIds.current()] = swapList[msg.sender].length; swapList[msg.sender].push(_swapIntent); uint256 i; for(i=0; i<_nftsOne.length; i++) nftsOne[_swapIntent.id].push(_nftsOne[i]); for(i=0; i<_nftsTwo.length; i++) nftsTwo[_swapIntent.id].push(_nftsTwo[i]); for(i=0; i<nftsOne[_swapIntent.id].length; i++) { require(whiteList[nftsOne[_swapIntent.id][i].dapp], \"A DAPP is not handled by the system\"); if(nftsOne[_swapIntent.id][i].typeStd == ERC20) { ERC20Interface(nftsOne[_swapIntent.id][i].dapp).transferFrom(_swapIntent.addressOne, address(this), nftsOne[_swapIntent.id][i].blc[0]); } else if(nftsOne[_swapIntent.id][i].typeStd == ERC721) { ERC721Interface(nftsOne[_swapIntent.id][i].dapp).safeTransferFrom(_swapIntent.addressOne, address(this), nftsOne[_swapIntent.id][i].tokenId[0], nftsOne[_swapIntent.id][i].data); } else if(nftsOne[_swapIntent.id][i].typeStd == ERC1155) { ERC1155Interface(nftsOne[_swapIntent.id][i].dapp).safeBatchTransferFrom(_swapIntent.addressOne, address(this), nftsOne[_swapIntent.id][i].tokenId, nftsOne[_swapIntent.id][i].blc, nftsOne[_swapIntent.id][i].data); } else { customInterface(dappRelations[nftsOne[_swapIntent.id][i].dapp]).bridgeSafeTransferFrom(nftsOne[_swapIntent.id][i].dapp, _swapIntent.addressOne, dappRelations[nftsOne[_swapIntent.id][i].dapp], nftsOne[_swapIntent.id][i].tokenId, nftsOne[_swapIntent.id][i].blc, nftsOne[_swapIntent.id][i].data); } } emit swapEvent(msg.sender, (block.timestamp-(block.timestamp%secs)), _swapIntent.status, _swapIntent.id, _swapIntent.addressTwo); _swapIds.increment(); }",
        "file_name": "0x13d8faf4a690f5ae52e2d2c52938d1167057b9af.sol"
    }
]