[
    {
        "function_name": "swapAndSend",
        "code": "function swapAndSend() private lockTheSwap { uint256 contractTokenBalance = balanceOf(address(this)); uint256 maxroutersell = _totalSupply.div(1000).mul(maxrouterpercent); if(contractTokenBalance > maxroutersell && maxrouterlimitenabled) { contractTokenBalance = contractTokenBalance.div(10); } uint256 _totalFee = _liquidityFee.add(_ethReflectionFee).add(_stakingFee).add(_marketingFee); uint256 amountForLiquidity = contractTokenBalance.mul(_liquidityFee).div(_totalFee); uint256 amountForEthReflection = contractTokenBalance.mul(_ethReflectionFee).div(_totalFee); uint256 amountForStaking = contractTokenBalance.mul(_stakingFee).div(_totalFee); uint256 amountForMarketingAndDev = contractTokenBalance.sub(amountForLiquidity).sub(amountForEthReflection).sub(amountForStaking); uint256 half = amountForLiquidity.div(2); uint256 otherHalf = amountForLiquidity.sub(half); uint256 swapAmount = half.add(amountForEthReflection).add(amountForStaking).add(amountForMarketingAndDev); swapTokensForEth(swapAmount); uint256 ethBalance = address(this).balance; uint256 ethLiquid = ethBalance.mul(half).div(swapAmount); uint256 ethReflection = ethBalance.mul(amountForEthReflection).div(swapAmount); uint256 ethStaking = ethBalance.mul(amountForStaking).div(swapAmount); uint256 ethMarketingAndDev = ethBalance.sub(ethLiquid).sub(ethReflection).sub(ethStaking); if(ethMarketingAndDev > 0){ payable(marketingWallet).transfer(ethMarketingAndDev.mul(70).div(100)); payable(developmentWallet).transfer(ethMarketingAndDev.mul(30).div(100)); } if(ethReflection > 0) try distributor.deposit{value: ethReflection}() {} catch {} if(ethStaking > 0){ try staking.distributeUsdtToStaking{value: ethStaking}() {} catch {} } if(ethLiquid > 0) addLiquidity(otherHalf, ethLiquid); }",
        "vulnerability": "Incorrect Fee Splitting",
        "reason": "The 'swapAndSend' function splits ETH obtained from token swaps into several parts: liquidity, reflection, staking, and marketing. However, the calculations for each part might not accurately reflect the intended distribution due to potential rounding errors, leading to incorrect fee splitting. This could result in less ETH being allocated for marketing or staking than intended, potentially impacting the functionality of the contract.",
        "file_name": "0x3775876e537df71b60061151b39bcfb638f832f5.sol"
    },
    {
        "function_name": "swapTokensForEth",
        "code": "function swapTokensForEth(uint256 tokenAmount) private { address[] memory path = new address[](2); path[0] = address(this); path[1] = uniswapV2Router.WETH(); _approve(address(this), address(uniswapV2Router), tokenAmount); uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens( tokenAmount, 0, path, address(this), block.timestamp ); }",
        "vulnerability": "Lack of Slippage Control",
        "reason": "The 'swapTokensForEth' function does not handle slippage, which means it sets the minimum amount of ETH to receive to zero. This can lead to significant losses if the price drops between the transaction's submission and its execution, as the swap will execute regardless of the price, potentially resulting in a worse rate than expected.",
        "file_name": "0x3775876e537df71b60061151b39bcfb638f832f5.sol"
    },
    {
        "function_name": "deposit",
        "code": "function deposit(uint256 _amount) external nonReentrant { UserInfo storage user = userInfo[msg.sender]; require(_amount > 0, \"Can't deposit zero amount\"); _updatePool(); if (user.amount > 0) { user.pendingUsdtReward = user.pendingUsdtReward.add(user.amount.mul(accUsdtPerShare).div(PRECISION_FACTOR).sub(user.rewardUsdtDebt)); user.pendingEthReward = user.pendingEthReward.add(user.amount.mul(accEthPerShare).div(PRECISION_FACTOR).sub(user.rewardEthDebt)); } user.depositTime = user.depositTime > 0 ? user.depositTime : block.timestamp; user.amount = user.amount.add(_amount); token.transferFrom(address(msg.sender), address(this), _amount); totalStakedAmount = totalStakedAmount.add(_amount); user.rewardUsdtDebt = user.amount.mul(accUsdtPerShare).div(PRECISION_FACTOR); user.rewardEthDebt = user.amount.mul(accEthPerShare).div(PRECISION_FACTOR); emit Deposit(msg.sender, _amount); }",
        "vulnerability": "Reentrancy Risk",
        "reason": "Although the 'deposit' function is protected by a non-reentrant modifier, there is a risk of reentrancy if the nonReentrant protection is bypassed, for instance, if the modifier is removed or altered. This function updates user balances and transfers tokens, making it crucial to ensure atomicity and protection against reentrant calls to prevent potential double-spending or incorrect balance updates.",
        "file_name": "0x3775876e537df71b60061151b39bcfb638f832f5.sol"
    }
]