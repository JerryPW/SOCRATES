[
    {
        "function_name": "addToPool",
        "code": "function addToPool(uint256[] memory minimumAmountsOut) public payable { require(msg.value > 0); if(totalSupply() == 0){ require(msg.value >= 10000000000000000 , \"You must initiate the pool with at least 0.01 ETH!\"); } uint256 factoryFeeAmount = msg.value * _factoryFee / 10**18; uint256 poolOwnerFeeAmount = msg.value * _poolFee / 10**18; uint256 amountIn = msg.value - factoryFeeAmount - poolOwnerFeeAmount; IWETH WETHContract = IWETH(WETHAddress); WETHContract.deposit{value: msg.value}(); IERC20(WETHAddress).transfer(owner(), poolOwnerFeeAmount); processFee(WETHAddress, factoryFeeAmount, 0); uint256 poolTokensToMint = InvestmentLibrary.getPoolTokensToMint( amountIn, _tokensHeld, totalSupply() ); if(_tokensToSwapIntoOnDeposit.length != 0){ for (uint i = 0; i < _tokensToSwapIntoOnDeposit.length; i++){ InvestmentLibrary.autoSwapToken memory autoSwapParams = _tokensToSwapIntoOnDeposit[i]; _swapTokens( autoSwapParams.v2Path, autoSwapParams.v3Path, amountIn * autoSwapParams.ratio / 10**18, minimumAmountsOut[i], autoSwapParams.quoteToken ); } } if(balanceOf(msg.sender) == 0){ _totalHolders++; } _mint(msg.sender, poolTokensToMint); if(InvestmentLibrary.isTokenHeld(_tokensHeld, WETHAddress) == false && IERC20(WETHAddress).balanceOf(address(this)) > 0){ _tokensHeld.push(InvestmentLibrary.heldToken(WETHAddress, address(0), false)); } emit InvestmentLibrary.feePaidToOwner(msg.sender, owner(), poolOwnerFeeAmount); emit InvestmentLibrary.poolAddedTo(msg.sender, msg.value, poolTokensToMint); }",
        "vulnerability": "Reentrancy Vulnerability",
        "reason": "The function 'addToPool' transfers ETH to the owner via 'IERC20(WETHAddress).transfer' and calls 'processFee' before minting tokens and updating the state. This sequence can be exploited by reentrancy attacks, allowing attackers to re-enter the function and manipulate the state in their favor before it is finalized.",
        "file_name": "0x38721079a72030ab1817fb9e1aaa86ae0d08356f.sol"
    },
    {
        "function_name": "removeFromPool",
        "code": "function removeFromPool(uint256 amountToRemove, InvestmentLibrary.exitSwapParams[] memory exitSwapParams) public { require(balanceOf(msg.sender) > 0, \"You need to have pool tokens if you want to burn them!\"); require(amountToRemove > 0, \"You can't remove 0 of your tokens!\"); require(amountToRemove <= balanceOf(msg.sender), \"You can only remove 100% of your share!\"); require(exitSwapParams.length == _tokensHeld.length, \"Not enough params!\"); _burn(msg.sender, amountToRemove); if(balanceOf(msg.sender) == 0){ _totalHolders--; } uint256 userShare = amountToRemove * 10**18 / (totalSupply() + amountToRemove); uint256 wethPayout = IERC20(WETHAddress).balanceOf(address(this)) * userShare / 10**18; InvestmentLibrary.heldToken[] memory tokensHeldSnapshot = _tokensHeld; for (uint i = 0; i < tokensHeldSnapshot.length; i++){ IERC20 tokenContract = IERC20(tokensHeldSnapshot[i].tokenAddress); if(tokensHeldSnapshot[i].tokenAddress != WETHAddress){ if(exitSwapParams[i].fee == 0){ bytes memory emptyBytes; address[] memory path = new address[](2); path[0] = tokensHeldSnapshot[i].tokenAddress; path[1] = WETHAddress; uint256 wethRecieved = _swapTokens( path, emptyBytes, tokenContract.balanceOf(address(this)) * userShare / 10**18, exitSwapParams[i].minimumOut, address(0) ); wethPayout += wethRecieved; } else { address[] memory path; uint256 wethRecieved = _swapTokens( path, abi.encode(tokensHeldSnapshot[i].tokenAddress, exitSwapParams[i].fee, WETHAddress), tokenContract.balanceOf(address(this)) * userShare / 10**18, exitSwapParams[i].minimumOut, address(0) ); wethPayout += wethRecieved; } } } uint256 poolOwnerFeeAmount = wethPayout * _poolFee / 10**18; uint256 factoryFeeAmount = wethPayout * _factoryFee / 10**18; uint256 amountToPayToUser = wethPayout - factoryFeeAmount - poolOwnerFeeAmount; IWETH WETHContract = IWETH(WETHAddress); IERC20(WETHAddress).transfer(owner(), poolOwnerFeeAmount); processFee(WETHAddress, factoryFeeAmount, 0); WETHContract.withdraw(amountToPayToUser); msg.sender.call{value: amountToPayToUser}(\"\"); if(InvestmentLibrary.isTokenHeld(_tokensHeld, WETHAddress) == true && IERC20(WETHAddress).balanceOf(address(this)) == 0){ _removeAddressFromTokensHeld(WETHAddress); } emit InvestmentLibrary.feePaidToOwner(msg.sender, owner(), poolOwnerFeeAmount); emit InvestmentLibrary.poolRemovedFrom(msg.sender, amountToRemove, amountToPayToUser); }",
        "vulnerability": "Reentrancy Vulnerability",
        "reason": "The function 'removeFromPool' calls 'msg.sender.call' to transfer ETH back to the user before updating the state variables and emitting events. This can be exploited in a reentrancy attack where an attacker re-enters the function before the state is correctly updated, potentially allowing them to withdraw more funds than they are entitled to.",
        "file_name": "0x38721079a72030ab1817fb9e1aaa86ae0d08356f.sol"
    },
    {
        "function_name": "processFee",
        "code": "function processFee(address tokenIn, uint256 amount, uint24 uniPoolfee) internal { uint256 feeAmount = amount; if(tokenIn != WETHAddress){ if(uniPoolfee == 0){ bytes memory emptyBytes; address[] memory path = new address[](2); path[0] = tokenIn; path[1] = WETHAddress; feeAmount = _swapTokens(path, emptyBytes, amount, 0, address(0)); } else { address[] memory path; feeAmount = _swapTokens(path, abi.encode(tokenIn, uniPoolfee, WETHAddress), amount, 0, address(0)); } } address feeHandlerAddress = IFactory(_factoryAddress)._feeHandlerAddress(); IERC20(WETHAddress).approve(feeHandlerAddress, feeAmount); IFeeHandler(feeHandlerAddress).collectFees(feeAmount); }",
        "vulnerability": "Approval Race Condition",
        "reason": "The function 'processFee' approves a certain amount of WETH to be spent by the fee handler contract. If the approval is not carefully managed, an attacker could potentially exploit the race condition in token approvals to spend more tokens than intended by quickly performing multiple transactions before the approvals are correctly set.",
        "file_name": "0x38721079a72030ab1817fb9e1aaa86ae0d08356f.sol"
    }
]