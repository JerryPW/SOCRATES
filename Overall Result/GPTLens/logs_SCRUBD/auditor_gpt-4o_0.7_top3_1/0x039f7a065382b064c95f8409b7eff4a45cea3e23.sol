[
    {
        "function_name": "swapAndLiquify",
        "code": "function swapAndLiquify() private lockTheSwap { uint256 contractTokenBalance = balanceOf(address(this)); if(liquidityTokens >= swapTokensAtAmount && contractTokenBalance >= swapTokensAtAmount) { uint256 half = swapTokensAtAmount.div(2); uint256 otherHalf = swapTokensAtAmount.sub(half); uint256 initialBalance = address(this).balance; swapTokensForEth(half, address(this)); uint256 newBalance = address(this).balance.sub(initialBalance); addLiquidity(otherHalf, newBalance); emit SwapAndLiquify(half, newBalance, otherHalf); liquidityTokens -= swapTokensAtAmount; } if(devTokens >= swapTokensAtAmount && contractTokenBalance >= swapTokensAtAmount) { swapTokensForEth(swapTokensAtAmount, devWallet); devTokens -= swapTokensAtAmount; } }",
        "vulnerability": "Reentrancy vulnerability",
        "reason": "The function `swapAndLiquify` involves transferring tokens and calling external contracts. Although the `lockTheSwap` modifier is used to prevent reentrancy within the function itself, it does not protect against reentrancy initiated by external calls made during token swaps or adding liquidity. An attacker could potentially exploit this by triggering reentrant calls when the contract interacts with Uniswap, leading to unexpected behavior or draining of funds.",
        "file_name": "0x039f7a065382b064c95f8409b7eff4a45cea3e23.sol"
    },
    {
        "function_name": "_transfer",
        "code": "function _transfer( address from, address to, uint256 amount ) internal override { require(from != address(0), \"ERC20: transfer from the zero address\"); require(to != address(0), \"ERC20: transfer to the zero address\"); if(amount == 0) { super._transfer(from, to, 0); return; } if (from==uniswapV2Pair && !_isExcludedFromFees[from] && !_isExcludedFromFees[to]) { uint256 contractBalanceRecepient = balanceOf(to); require(contractBalanceRecepient + amount <= maxWalletToken, \"Exceeds maximum wallet token amount.\"); } if(!_isExcludedFromFees[from] && !_isExcludedFromFees[to] && from==uniswapV2Pair){ require(amount <= maxBuyTransactionAmount, \"amount exceeds the maxBuyTransactionAmount.\"); } if(!_isExcludedFromFees[from] && !_isExcludedFromFees[to] && to==uniswapV2Pair){ require(amount <= maxSellTransactionAmount, \"amount exceeds the maxSellTransactionAmount.\"); } if(!inSwapAndLiquify && to==uniswapV2Pair && swapAndLiquifyEnabled && (devTokens >= swapTokensAtAmount || liquidityTokens >= swapTokensAtAmount)) { swapAndLiquify(); } if(!_isExcludedFromFees[from] && !_isExcludedFromFees[to]) { uint256 devShare; uint256 liquidityShare; uint256 burnShare; if(from==uniswapV2Pair) { if(devBuyFee > 0) { devShare = amount.mul(devBuyFee).div(100); devTokens += devShare; super._transfer(from, address(this), devShare); } if(liquidityBuyFee > 0) { liquidityShare = amount.mul(liquidityBuyFee).div(100); liquidityTokens += liquidityShare; super._transfer(from, address(this), liquidityShare); } } if(to==uniswapV2Pair) { if(devSellFee > 0) { devShare = amount.mul(devSellFee).div(100); devTokens += devShare; super._transfer(from, address(this), devShare); } if(burnSellFee > 0) { burnShare = amount.mul(burnSellFee).div(100); super._transfer(from, deadWallet, burnShare); } } amount = amount.sub(devShare.add(liquidityShare).add(burnShare)); } super._transfer(from, to, amount); }",
        "vulnerability": "Lack of checks for token transfer limits",
        "reason": "In the `_transfer` function, there are checks for maximum buy and sell transaction amounts, and maximum wallet token amounts. However, these checks can be easily bypassed by splitting a large transaction into smaller ones, allowing potential attackers to circumvent the intended limits and manipulate token transfers in ways that could lead to market manipulation or other harmful actions.",
        "file_name": "0x039f7a065382b064c95f8409b7eff4a45cea3e23.sol"
    },
    {
        "function_name": "swapTokensForEth",
        "code": "function swapTokensForEth(uint256 tokenAmount, address _to) private { address[] memory path = new address[](2); path[0] = address(this); path[1] = uniswapV2Router.WETH(); if(allowance(address(this), address(uniswapV2Router)) < tokenAmount) { _approve(address(this), address(uniswapV2Router), ~uint256(0)); } uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens( tokenAmount, 0, path, _to, block.timestamp ); }",
        "vulnerability": "Unlimited token allowance",
        "reason": "In the `swapTokensForEth` function, the contract sets an unlimited allowance for the Uniswap router by approving `~uint256(0)`. This can lead to potential security risks if the router contract is compromised or if there are errors in its implementation, allowing unauthorized transfers of tokens from this contract.",
        "file_name": "0x039f7a065382b064c95f8409b7eff4a45cea3e23.sol"
    }
]