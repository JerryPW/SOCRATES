[
    {
        "function_name": "transferFrom",
        "code": "function transferFrom( address from, address to, uint256 value ) public returns (bool) { _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value); _transfer(from, to, value); return true; }",
        "vulnerability": "Missing Check for Approvals",
        "reason": "The function `transferFrom` directly subtracts the `value` from the `_allowed` mapping without checking if the value is less than or equal to the current allowance, which can cause issues depending on the implementation of `SafeMath.sub`. Without a proper check, it can lead to unexpected behavior if the `sub` function reverts, potentially leading to a denial of service or other logic flaws.",
        "file_name": "0x1f42f986f9ef31d6ef787565b211bce0eb877bcc.sol"
    },
    {
        "function_name": "setGameWaveAddress",
        "code": "function setGameWaveAddress(address payable _GameWaveAddress) public { require(address(GameWaveContract) == address(0x0)); GameWaveContract = GameWave(_GameWaveAddress); }",
        "vulnerability": "Potential Front-running Attack",
        "reason": "The function `setGameWaveAddress` allows setting the `GameWaveContract` address, but only if it is currently set to the zero address. This could allow a front-running attack where an attacker observes a transaction setting this address and quickly sends their own transaction to set the address to something else, potentially hijacking the contract's functionality.",
        "file_name": "0x1f42f986f9ef31d6ef787565b211bce0eb877bcc.sol"
    },
    {
        "function_name": "getWinners",
        "code": "function getWinners() public { require(winner == 0 && !getState()); uint256 seed1 = address(this).balance; uint256 seed2 = totalSupplyOfBulls; uint256 seed3 = totalSupplyOfBears; uint256 seed4 = totalGWSupplyOfBulls; uint256 seed5 = totalGWSupplyOfBulls; uint256 seed6 = block.difficulty; uint256 seed7 = block.timestamp; bytes32 randomHash = keccak256(abi.encodePacked(seed1, seed2, seed3, seed4, seed5, seed6, seed7)); uint randomNumber = uint(randomHash); if (randomNumber == 0){ randomNumber = 1; } uint winningNumber = randomNumber % 10000; if (1 <= winningNumber && winningNumber <= probabilityOfBears){ winner = 1; } if (probabilityOfBears < winningNumber && winningNumber <= 10000){ winner = 2; } if (GameWaveContract.balanceOf(address(BullsContract)) > 0) GameWaveContract.transferFrom( address(BullsContract), address(this), GameWaveContract.balanceOf(address(BullsContract)) ); if (GameWaveContract.balanceOf(address(BearsContract)) > 0) GameWaveContract.transferFrom( address(BearsContract), address(this), GameWaveContract.balanceOf(address(BearsContract)) ); lastTotalSupplyOfBulls = totalSupplyOfBulls; lastTotalSupplyOfBears = totalSupplyOfBears; lastTotalGWSupplyOfBears = totalGWSupplyOfBears; lastTotalGWSupplyOfBulls = totalGWSupplyOfBulls; lastRoundHero = lastHero; lastJackPot = jackPot; lastWinner = winner; lastCountOfBears = countOfBears; lastCountOfBulls = countOfBulls; lastWithdrawn = withdrawn; lastWithdrawnGW = withdrawnGW; if (lastBalance > lastWithdrawn){ remainder = lastBalance.sub(lastWithdrawn); address(GameWaveContract).transfer(remainder); } lastBalance = lastTotalSupplyOfBears.add(lastTotalSupplyOfBulls).add(lastJackPot); if (lastBalanceGW > lastWithdrawnGW){ remainderGW = lastBalanceGW.sub(lastWithdrawnGW); tokenReturn = (totalGWSupplyOfBears.add(totalGWSupplyOfBulls)).mul(20).div(100).add(remainderGW); GameWaveContract.transfer(crowdSale, tokenReturn); } lastBalanceGW = GameWaveContract.balanceOf(address(this)); totalSupplyOfBulls = 0; totalSupplyOfBears = 0; totalGWSupplyOfBulls = 0; totalGWSupplyOfBears = 0; remainder = 0; remainderGW = 0; jackPot = 0; withdrawn = 0; winner = 0; withdrawnGW = 0; countOfBears = 0; countOfBulls = 0; probabilityOfBulls = 0; probabilityOfBears = 0; _setRoundTime(defaultCurrentDeadlineInHours, defaultLastDeadlineInHours); currentRound++; }",
        "vulnerability": "Predictable Randomness",
        "reason": "The function `getWinners` uses a predictable source of randomness by relying on block attributes and contract state variables to generate a random number. This approach is vulnerable to manipulation by miners or other clever attackers, who can influence block attributes such as `block.difficulty` and `block.timestamp` to produce a favorable outcome.",
        "file_name": "0x1f42f986f9ef31d6ef787565b211bce0eb877bcc.sol"
    }
]