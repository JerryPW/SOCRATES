[
    {
        "function_name": "withdraw",
        "code": "function withdraw(uint8 coin) external { (uint256 to_payout, uint256 max_payout) = this.payoutOf(msg.sender); if(to_payout > 0) { if(users[msg.sender].payouts + to_payout > max_payout) { to_payout = max_payout - users[msg.sender].payouts; } users[msg.sender].deposit_payouts += to_payout; users[msg.sender].payouts += to_payout; _refPayout(msg.sender, to_payout); } if(users[msg.sender].payouts < max_payout && users[msg.sender].direct_bonus > 0) { uint256 direct_bonus = users[msg.sender].direct_bonus; if(users[msg.sender].payouts + direct_bonus > max_payout) { direct_bonus = max_payout - users[msg.sender].payouts; } users[msg.sender].direct_bonus -= direct_bonus; users[msg.sender].payouts += direct_bonus; to_payout += direct_bonus; } if(users[msg.sender].payouts < max_payout && users[msg.sender].pool_bonus > 0) { uint256 pool_bonus = users[msg.sender].pool_bonus; if(users[msg.sender].payouts + pool_bonus > max_payout) { pool_bonus = max_payout - users[msg.sender].payouts; } users[msg.sender].pool_bonus -= pool_bonus; users[msg.sender].payouts += pool_bonus; to_payout += pool_bonus; } if(users[msg.sender].payouts < max_payout && users[msg.sender].match_bonus > 0) { uint256 match_bonus = users[msg.sender].match_bonus; if(users[msg.sender].payouts + match_bonus > max_payout) { match_bonus = max_payout - users[msg.sender].payouts; } users[msg.sender].match_bonus -= match_bonus; users[msg.sender].payouts += match_bonus; to_payout += match_bonus; } if(users[msg.sender].payouts < max_payout && matrixUser[msg.sender].matrix_bonus > 0) { if(users[msg.sender].isWithdrawActive){ uint256 matrix_bonus = matrixUser[msg.sender].matrix_bonus; if(users[msg.sender].payouts + matrix_bonus > max_payout) { matrix_bonus = max_payout - users[msg.sender].payouts; } matrixUser[msg.sender].matrix_bonus -= matrix_bonus; users[msg.sender].payouts += matrix_bonus; to_payout += matrix_bonus; } else{ matrixUser[msg.sender].matrix_bonus = 0; } } if(users[msg.sender].payouts < max_payout && matrixUser[msg.sender].leader_bonus > 0) { uint256 leader_bonus = matrixUser[msg.sender].leader_bonus; if(users[msg.sender].payouts + leader_bonus > max_payout) { leader_bonus = max_payout - users[msg.sender].payouts; } matrixUser[msg.sender].leader_bonus -= leader_bonus; users[msg.sender].payouts += leader_bonus; to_payout += leader_bonus; } require(to_payout > 0, \"Zero payout\"); users[msg.sender].total_payouts += to_payout; total_withdraw += to_payout; uint256 matrixbonus = to_payout.mul(20).div(100); calcMatrixBonus(msg.sender,matrixbonus); to_payout -= to_payout.mul(20).div(100); if(coin == 0){ payable(msg.sender).transfer(to_payout); } else if(coin == 1){ _token.send(msg.sender,to_payout,\"Token Withdrawed\"); } emit Withdraw(msg.sender, to_payout); if(users[msg.sender].payouts >= max_payout) { users[msg.sender].isWithdrawActive = false; emit LimitReached(msg.sender, users[msg.sender].payouts); } }",
        "vulnerability": "Reentrancy vulnerability",
        "reason": "The function performs state updates before transferring funds. An attacker could exploit this by recursively calling the withdraw function, leading to reentrancy attacks where the contract state is inconsistent with the actual token balances.",
        "file_name": "0x00b6358d1ac8d3731defd6b4d593b6ba04f9b8ea.sol"
    },
    {
        "function_name": "_setUpline",
        "code": "function _setUpline(address _addr, address _upline) private { if(users[_addr].upline == address(0) && _upline != _addr && (users[_upline].deposit_time > 0 || _upline == owner())) { users[_addr].upline = _upline; users[_upline].referrals++; matrixUser[_upline].totalRefs.push(_addr); emit Upline(_addr, _upline); addToMatrix(_addr,_upline); for(uint8 i = 0; i < 15; i++) { if(_upline == address(0)) break; users[_upline].total_structure++; _upline = users[_upline].upline; } } }",
        "vulnerability": "Upline manipulation",
        "reason": "The function does not properly validate the upline address, allowing a malicious user to set arbitrary uplines, potentially manipulating the referral system for unfair bonus and reward accumulation.",
        "file_name": "0x00b6358d1ac8d3731defd6b4d593b6ba04f9b8ea.sol"
    },
    {
        "function_name": "deposit",
        "code": "function deposit(address upline) payable public { setUpline(upline); _deposit(msg.sender, msg.value, 0); }",
        "vulnerability": "Unrestricted Ether deposit",
        "reason": "The deposit function allows direct Ether transfers without sufficient validation or controls. An attacker can exploit this to manipulate balances and other state variables, particularly if combined with functions that handle Ether improperly.",
        "file_name": "0x00b6358d1ac8d3731defd6b4d593b6ba04f9b8ea.sol"
    }
]