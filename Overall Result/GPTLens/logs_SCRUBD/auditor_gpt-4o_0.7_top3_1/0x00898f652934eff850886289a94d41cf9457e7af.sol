[
    {
        "function_name": "withdrawReward",
        "code": "function withdrawReward(uint256 positionId) public byPositionOwner(positionId) { FarmingPosition storage farmingPosition = _positions[positionId]; uint256 reward = farmingPosition.reward; uint256 currentBlock = block.number; if (!_setupsInfo[_setups[farmingPosition.setupIndex].infoIndex].free) { require(farmingPosition.reward > 0, \"No reward\"); (reward,) = calculateLockedFarmingReward(0, 0, true, positionId); require(reward <= farmingPosition.reward, \"Reward is bigger than expected\"); farmingPosition.reward = currentBlock >= _setups[farmingPosition.setupIndex].endBlock ? 0 : farmingPosition.reward - reward; farmingPosition.creationBlock = block.number; } else { currentBlock = currentBlock > _setups[farmingPosition.setupIndex].endBlock ? _setups[farmingPosition.setupIndex].endBlock : currentBlock; _rewardPerTokenPerSetup[farmingPosition.setupIndex] += (((currentBlock - _setups[farmingPosition.setupIndex].lastUpdateBlock) * _setups[farmingPosition.setupIndex].rewardPerBlock) * 1e18) / _setups[farmingPosition.setupIndex].totalSupply; reward = calculateFreeFarmingReward(positionId, false); _rewardPerTokenPaid[positionId] = _rewardPerTokenPerSetup[farmingPosition.setupIndex]; farmingPosition.reward = 0; _setups[farmingPosition.setupIndex].lastUpdateBlock = currentBlock; } if (reward > 0) { if (_rewardTokenAddress != address(0)) { _safeTransfer(_rewardTokenAddress, farmingPosition.uniqueOwner, reward); } else { (bool result,) = farmingPosition.uniqueOwner.call{value:reward}(\"\"); require(result, \"Invalid ETH transfer.\"); } _rewardPaid[farmingPosition.setupIndex] += reward; } if (_setups[farmingPosition.setupIndex].endBlock <= block.number) { if (_setups[farmingPosition.setupIndex].active) { _toggleSetup(farmingPosition.setupIndex); } if (!_setupsInfo[_setups[farmingPosition.setupIndex].infoIndex].free) { _setupPositionsCount[farmingPosition.setupIndex] -= 1; if (_setupPositionsCount[farmingPosition.setupIndex] == 0 && !_setups[farmingPosition.setupIndex].active) { _giveBack(_rewardReceived[farmingPosition.setupIndex] - _rewardPaid[farmingPosition.setupIndex]); delete _setups[farmingPosition.setupIndex]; } delete _positions[positionId]; } } else if (!_setupsInfo[_setups[farmingPosition.setupIndex].infoIndex].free) { _partiallyRedeemed[positionId] += reward; } }",
        "vulnerability": "Reentrancy vulnerability",
        "reason": "The function `withdrawReward` transfers rewards to the user's address using a direct call. This can potentially open up a reentrancy vulnerability if the receiving address is a contract that can re-enter the `withdrawReward` function before the state is updated properly. Such a reentrancy attack can lead to draining all available rewards.",
        "file_name": "0x00898f652934eff850886289a94d41cf9457e7af.sol"
    },
    {
        "function_name": "_safeTransfer",
        "code": "function _safeTransfer(address erc20TokenAddress, address to, uint256 value) internal virtual { bytes memory returnData = _call(erc20TokenAddress, abi.encodeWithSelector(IERC20(erc20TokenAddress).transfer.selector, to, value)); require(returnData.length == 0 || abi.decode(returnData, (bool)), 'TRANSFER_FAILED'); }",
        "vulnerability": "Unchecked external call",
        "reason": "The `_safeTransfer` function makes an external call to transfer ERC20 tokens without properly handling potential errors or reentrancy issues. This unchecked call can lead to failures in token transfers, which are not caught, potentially causing other vulnerabilities or incorrect state updates.",
        "file_name": "0x00898f652934eff850886289a94d41cf9457e7af.sol"
    },
    {
        "function_name": "unlock",
        "code": "function unlock(uint256 positionId, bool unwrapPair) public payable byPositionOwner(positionId) { FarmingPosition storage farmingPosition = _positions[positionId]; require(!_setupsInfo[_setups[farmingPosition.setupIndex].infoIndex].free && _setups[farmingPosition.setupIndex].endBlock > block.number, \"Invalid unlock\"); uint256 rewardToGiveBack = _partiallyRedeemed[positionId]; rewardToGiveBack += _setupsInfo[_setups[farmingPosition.setupIndex].infoIndex].penaltyFee == 0 ? 0 : (farmingPosition.reward * ((_setupsInfo[_setups[farmingPosition.setupIndex].infoIndex].penaltyFee * 1e18) / ONE_HUNDRED) / 1e18); if (rewardToGiveBack > 0) { _safeTransferFrom(_rewardTokenAddress, msg.sender, address(this), rewardToGiveBack); _giveBack(rewardToGiveBack); } _setups[farmingPosition.setupIndex].totalSupply -= farmingPosition.mainTokenAmount; _burnFarmTokenAmount(_setups[farmingPosition.setupIndex].objectId, farmingPosition.liquidityPoolTokenAmount); _removeLiquidity(positionId, farmingPosition.setupIndex, unwrapPair, farmingPosition.liquidityPoolTokenAmount, true); _setupPositionsCount[farmingPosition.setupIndex] -= 1 + farmingPosition.liquidityPoolTokenAmount; delete _positions[positionId]; }",
        "vulnerability": "Incorrect penalty calculation",
        "reason": "The function `unlock` calculates the penalty fee based on a fixed percentage but does not handle edge cases where the penalty might be incorrectly computed due to precision errors or incorrect penalty fee settings. This can lead to incorrect amounts being transferred or refunded, leading to potential financial loss or exploits.",
        "file_name": "0x00898f652934eff850886289a94d41cf9457e7af.sol"
    }
]