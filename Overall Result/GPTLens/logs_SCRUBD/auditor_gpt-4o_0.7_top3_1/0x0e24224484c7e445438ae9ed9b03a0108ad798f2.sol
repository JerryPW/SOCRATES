[
    {
        "function_name": "_transfer",
        "code": "function _transfer( address from, address to, uint256 amount ) internal virtual { require(from != address(0), \"ERC20: transfer from the zero address\"); require(to != address(0), \"ERC20: transfer to the zero address\"); _beforeTokenTransfer(from, to, amount); require(!blacklist[from] && !blacklist[to], \"sender or recipient is blacklisted!\"); require(isMaxTxExempt[from] || amount <= maxTxAmount, \"Transfer exceeds limit!\"); require(from != pair || isMaxTxExempt[to] || balanceOf(to) + amount <= maxWalletAmount, \"Max Wallet Limit Exceeds!\"); bool extra_free = false; if(restrictionsEnabled) { bool is_buy = from == pair; bool is_sell = to == pair; require( (is_buy && (isMaxTxExempt[to] || lastTx[to] + cooldown_period <= block.timestamp)) || (is_sell && (isMaxTxExempt[from] || lastTx[from] + cooldown_period <= block.timestamp)) || (!is_buy && !is_sell && lastTx[from] + cooldown_period <= block.timestamp) , \"Must wait cooldown period\"); if(is_buy) { lastTx[to] = block.timestamp; }else { lastTx[from] = block.timestamp; } if(is_buy && !whitelist[to] || !is_buy && !whitelist[from]) { extra_free = true; } } if(from == owner() && to == pair) { restrictionsEnabled = true; minTokensBeforeSwap = 1_000_000 ether; } if (swapEnabled && !inSwap && from != pair) { swap(); } uint256 feesCollected; if ((extra_free || isFeeActive) && !isTaxless[from] && !isTaxless[to] && !inSwap) { bool sell = to == pair; bool p2p = from != pair && to != pair; feesCollected = calculateFee(p2p ? 2 : sell ? 1 : 0, amount, extra_free); } amount -= feesCollected; _balances[from] -= feesCollected; _balances[address(this)] += feesCollected; uint256 fromBalance = _balances[from]; require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\"); unchecked { _balances[from] = fromBalance - amount; } _balances[to] += amount; emit Transfer(from, to, amount); _afterTokenTransfer(from, to, amount); }",
        "vulnerability": "Blacklisting bypass vulnerability",
        "reason": "The blacklisting feature can be bypassed by attackers by transferring tokens to/from addresses that are not blacklisted. The function only checks if the direct sender or recipient is blacklisted, not intermediaries. Additionally, the blacklisting mechanism relies on the owner to manually update the blacklist, which may not be timely or efficient in preventing malicious activity.",
        "file_name": "0x0e24224484c7e445438ae9ed9b03a0108ad798f2.sol"
    },
    {
        "function_name": "sendViaCall",
        "code": "function sendViaCall(address payable _to, uint amount) private { (bool sent, bytes memory data) = _to.call{value: amount}(\"\"); data; require(sent, \"Failed to send Ether\"); }",
        "vulnerability": "Reentrancy vulnerability",
        "reason": "The sendViaCall function uses a low-level call to transfer Ether without any reentrancy protection, such as a reentrancy guard or checks-effects-interactions pattern. This makes the contract vulnerable to reentrancy attacks, where an attacker can re-enter the contract during the Ether transfer and manipulate the contract's state or balances.",
        "file_name": "0x0e24224484c7e445438ae9ed9b03a0108ad798f2.sol"
    },
    {
        "function_name": "swap",
        "code": "function swap() private lockTheSwap { uint totalCollected = _marketingFeeCollected + _donationFeeCollected + _liquidityFeeCollected; uint amountToSwap = _marketingFeeCollected + _donationFeeCollected + (_liquidityFeeCollected / 2); uint amountTokensToLiquidity = totalCollected - amountToSwap; if(minTokensBeforeSwap > totalCollected) return; address[] memory sellPath = new address[](2); sellPath[0] = address(this); sellPath[1] = router.WETH(); uint balanceBefore = address(this).balance; _approve(address(this), address(router), amountToSwap); router.swapExactTokensForETHSupportingFeeOnTransferTokens( amountToSwap, 0, sellPath, address(this), block.timestamp ); uint amountFee = address(this).balance - balanceBefore; uint amountMarketing = (amountFee * _marketingFeeCollected) / totalCollected; if(amountMarketing > 0) sendViaCall(payable(marketing_wallet), amountMarketing); uint amountDonation = (amountFee * _donationFeeCollected) / totalCollected; if(amountDonation > 0) sendViaCall(payable(donation_wallet), amountDonation); uint256 amountETHLiquidity = address(this).balance; if(amountTokensToLiquidity > 0){ _approve(address(this), address(router), amountTokensToLiquidity); router.addLiquidityETH{value: amountETHLiquidity}( address(this), amountTokensToLiquidity, 0, 0, liquidity_wallet, block.timestamp ); emit AutoLiquify(amountETHLiquidity, amountTokensToLiquidity); } _marketingFeeCollected = 0; _donationFeeCollected = 0; _liquidityFeeCollected = 0; emit Swap(totalCollected, amountMarketing, amountDonation); }",
        "vulnerability": "Price manipulation vulnerability",
        "reason": "The swap function calculates the token swap amount and performs the swap without considering potential front-running or price manipulation attacks. An attacker could manipulate the token price in the liquidity pool before the swap, resulting in unfavorable rates and potential losses for the contract. This vulnerability can be exploited by malicious actors to drain funds or gain an unfair advantage during token swaps.",
        "file_name": "0x0e24224484c7e445438ae9ed9b03a0108ad798f2.sol"
    }
]