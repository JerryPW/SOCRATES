[
    {
        "function_name": "function() payable",
        "code": "function() payable { if(now > priceIncrease_20_February){ price = \"0.007 Ether for 1 microBDSM\"; realPrice = 0.007 * 1 ether; } else if(now > priceIncrease_20_January){ price = \"0.00525 Ether for 1 microBDSM\"; realPrice = 0.00525 * 1 ether; } tokenFree = sharesTokenAddress.balanceOf(this); if (now < startICO_20_December) { msg.sender.transfer(msg.value); } else if (now > stopICO_20_March) { msg.sender.transfer(msg.value); if(!tokensWithdrawn){ sharesTokenAddress.transfer(safeContract, sharesTokenAddress.balanceOf(this)); tokenFree = sharesTokenAddress.balanceOf(this); tokensWithdrawn = true; crowdsaleClosed = true; } } else if (crowdsaleClosed) { msg.sender.transfer(msg.value); } else { uint256 tokenToBuy = msg.value / realPrice * coeff; if(tokenToBuy <= 0) msg.sender.transfer(msg.value); require(tokenToBuy > 0); uint256 actualETHTransfer = tokenToBuy * realPrice / coeff; if (tokenFree >= tokenToBuy) { owner.transfer(actualETHTransfer); if (msg.value > actualETHTransfer){ msg.sender.transfer(msg.value - actualETHTransfer); } sharesTokenAddress.transfer(msg.sender, tokenToBuy); tokenSold += tokenToBuy; tokenFree -= tokenToBuy; if(tokenFree==0) crowdsaleClosed = true; } else { uint256 sendETH = tokenFree * realPrice / coeff; owner.transfer(sendETH); sharesTokenAddress.transfer(msg.sender, tokenFree); msg.sender.transfer(msg.value - sendETH); tokenSold += tokenFree; tokenFree = sharesTokenAddress.balanceOf(this); crowdsaleClosed = true; } } TokenFree(tokenFree); CrowdsaleClosed(crowdsaleClosed); }",
        "vulnerability": "Reentrancy Attack",
        "reason": "The fallback function is vulnerable to reentrancy attacks because it performs external calls (transfers) before updating the state variables. Specifically, the `msg.sender.transfer` is called before updating `tokenSold` and `tokenFree`, allowing an attacker to exploit this by repeatedly calling the function before the state is updated, potentially draining the contract.",
        "file_name": "0x61683dfbe07e98a4edbddc2f1f1a44a75fa74912.sol"
    },
    {
        "function_name": "function() payable",
        "code": "function() payable { if(now > priceIncrease_20_February){ price = \"0.007 Ether for 1 microBDSM\"; realPrice = 0.007 * 1 ether; } else if(now > priceIncrease_20_January){ price = \"0.00525 Ether for 1 microBDSM\"; realPrice = 0.00525 * 1 ether; } tokenFree = sharesTokenAddress.balanceOf(this); if (now < startICO_20_December) { msg.sender.transfer(msg.value); } else if (now > stopICO_20_March) { msg.sender.transfer(msg.value); if(!tokensWithdrawn){ sharesTokenAddress.transfer(safeContract, sharesTokenAddress.balanceOf(this)); tokenFree = sharesTokenAddress.balanceOf(this); tokensWithdrawn = true; crowdsaleClosed = true; } } else if (crowdsaleClosed) { msg.sender.transfer(msg.value); } else { uint256 tokenToBuy = msg.value / realPrice * coeff; if(tokenToBuy <= 0) msg.sender.transfer(msg.value); require(tokenToBuy > 0); uint256 actualETHTransfer = tokenToBuy * realPrice / coeff; if (tokenFree >= tokenToBuy) { owner.transfer(actualETHTransfer); if (msg.value > actualETHTransfer){ msg.sender.transfer(msg.value - actualETHTransfer); } sharesTokenAddress.transfer(msg.sender, tokenToBuy); tokenSold += tokenToBuy; tokenFree -= tokenToBuy; if(tokenFree==0) crowdsaleClosed = true; } else { uint256 sendETH = tokenFree * realPrice / coeff; owner.transfer(sendETH); sharesTokenAddress.transfer(msg.sender, tokenFree); msg.sender.transfer(msg.value - sendETH); tokenSold += tokenFree; tokenFree = sharesTokenAddress.balanceOf(this); crowdsaleClosed = true; } } TokenFree(tokenFree); CrowdsaleClosed(crowdsaleClosed); }",
        "vulnerability": "Incorrect Price Calculation",
        "reason": "The contract calculates the number of tokens to buy using `uint256 tokenToBuy = msg.value / realPrice * coeff;`, which could result in an incorrect calculation due to integer division truncation. This can lead to buyers receiving fewer tokens than they paid for or unexpected behavior when interacting with the contract.",
        "file_name": "0x61683dfbe07e98a4edbddc2f1f1a44a75fa74912.sol"
    },
    {
        "function_name": "function() payable",
        "code": "function() payable { if(now > priceIncrease_20_February){ price = \"0.007 Ether for 1 microBDSM\"; realPrice = 0.007 * 1 ether; } else if(now > priceIncrease_20_January){ price = \"0.00525 Ether for 1 microBDSM\"; realPrice = 0.00525 * 1 ether; } tokenFree = sharesTokenAddress.balanceOf(this); if (now < startICO_20_December) { msg.sender.transfer(msg.value); } else if (now > stopICO_20_March) { msg.sender.transfer(msg.value); if(!tokensWithdrawn){ sharesTokenAddress.transfer(safeContract, sharesTokenAddress.balanceOf(this)); tokenFree = sharesTokenAddress.balanceOf(this); tokensWithdrawn = true; crowdsaleClosed = true; } } else if (crowdsaleClosed) { msg.sender.transfer(msg.value); } else { uint256 tokenToBuy = msg.value / realPrice * coeff; if(tokenToBuy <= 0) msg.sender.transfer(msg.value); require(tokenToBuy > 0); uint256 actualETHTransfer = tokenToBuy * realPrice / coeff; if (tokenFree >= tokenToBuy) { owner.transfer(actualETHTransfer); if (msg.value > actualETHTransfer){ msg.sender.transfer(msg.value - actualETHTransfer); } sharesTokenAddress.transfer(msg.sender, tokenToBuy); tokenSold += tokenToBuy; tokenFree -= tokenToBuy; if(tokenFree==0) crowdsaleClosed = true; } else { uint256 sendETH = tokenFree * realPrice / coeff; owner.transfer(sendETH); sharesTokenAddress.transfer(msg.sender, tokenFree); msg.sender.transfer(msg.value - sendETH); tokenSold += tokenFree; tokenFree = sharesTokenAddress.balanceOf(this); crowdsaleClosed = true; } } TokenFree(tokenFree); CrowdsaleClosed(crowdsaleClosed); }",
        "vulnerability": "Denial of Service via Block Gas Limit",
        "reason": "The function does not properly handle situations where the number of tokens to transfer or the number of iterations in the loop could exceed the block gas limit, leading to a denial of service. An attacker could exploit this by sending a large number of transactions or a large amount of Ether to prevent other users from participating in the crowdsale.",
        "file_name": "0x61683dfbe07e98a4edbddc2f1f1a44a75fa74912.sol"
    }
]