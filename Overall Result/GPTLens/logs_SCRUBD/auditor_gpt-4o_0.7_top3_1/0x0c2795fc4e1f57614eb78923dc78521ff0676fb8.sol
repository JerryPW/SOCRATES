[
    {
        "function_name": "acceptOwnership",
        "code": "function acceptOwnership() public {\n    if (msg.sender == newOwner) {\n        owner = newOwner;\n    }\n}",
        "vulnerability": "Ownership takeover without confirmation",
        "reason": "The function does not reset newOwner to address(0) after ownership transfer, which means that if the new owner inadvertently sets a newOwner, any address that matches the newOwner can call this function and take over the contract. It also lacks an event to signal the transfer, making tracking ownership changes difficult.",
        "file_name": "0x0c2795fc4e1f57614eb78923dc78521ff0676fb8.sol"
    },
    {
        "function_name": "oraclize_query",
        "code": "function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n    uint price = oraclize.getPrice(datasource);\n    if (price > 1 ether + tx.gasprice*200000) return 0;\n    return oraclize.query.value(price)(0, datasource, arg);\n}",
        "vulnerability": "No check for oraclize query result validity",
        "reason": "The function does not verify the success of the oraclize query or handle any errors that may occur, which could lead to unexpected behavior or potential loss of funds if the query fails. Additionally, there's no mechanism to ensure that the callback is processed correctly or to handle cases where the callback function is not called.",
        "file_name": "0x0c2795fc4e1f57614eb78923dc78521ff0676fb8.sol"
    },
    {
        "function_name": "buy",
        "code": "function buy (address _address, uint _value, uint _time) internal returns(bool) {\n    uint8 currentPhase = getPhase(_time);\n    if (currentPhase == 1){\n        uint tokensToSend = _value.mul((uint)(10).pow(decimals))/(stage_1_price);\n        if(stage_1_TokensSold.add(tokensToSend) <= STAGE_1_MAXCAP){\n            ethCollected = ethCollected.add(_value);\n            token.transfer(_address,tokensToSend);\n            distributionAddress.transfer(address(this).balance.sub(oraclizeBalance));\n            emit OnSuccessfullyBought(_address,_value,false,tokensToSend);\n            stage_1_TokensSold = stage_1_TokensSold.add(tokensToSend);\n            return true;\n        }else{\n            if(stage_1_TokensSold == STAGE_1_MAXCAP){\n                return false;\n            }\n            uint availableTokens = STAGE_1_MAXCAP.sub(stage_1_TokensSold);\n            uint ethRequire = availableTokens.mul(stage_1_price)/(uint(10).pow(decimals));\n            token.transfer(_address,availableTokens);\n            msg.sender.transfer(_value.sub(ethRequire));\n            distributionAddress.transfer(address(this).balance.sub(oraclizeBalance));\n            emit OnSuccessfullyBought(_address,ethRequire,false,availableTokens);\n            ethCollected = ethCollected.add(ethRequire);\n            stage_1_TokensSold = STAGE_1_MAXCAP;\n            return true;\n        }\n    }\n    if(currentPhase == 2){\n        if(!phase2Flag){\n            stage_2_maxcap = stage_2_maxcap.add(STAGE_1_MAXCAP.sub(stage_1_TokensSold));\n            phase2Flag = true;\n        }\n        tokensToSend = _value.mul((uint)(10).pow(decimals))/stage_2_price;\n        if(stage_2_TokensSold.add(tokensToSend) <= stage_2_maxcap){\n            ethCollected = ethCollected.add(_value);\n            token.transfer(_address,tokensToSend);\n            distributionAddress.transfer(address(this).balance.sub(oraclizeBalance));\n            emit OnSuccessfullyBought(_address,_value,false,tokensToSend);\n            stage_2_TokensSold = stage_2_TokensSold.add(tokensToSend);\n            return true;\n        }else{\n            if(stage_2_TokensSold == stage_2_maxcap){\n                return false;\n            }\n            availableTokens = stage_2_maxcap.sub(stage_2_TokensSold);\n            ethRequire = availableTokens.mul(stage_2_price)/(uint(10).pow(decimals));\n            token.transfer(_address,availableTokens);\n            msg.sender.transfer(_value.sub(ethRequire));\n            distributionAddress.transfer(address(this).balance.sub(oraclizeBalance));\n            emit OnSuccessfullyBought(_address,ethRequire,false,availableTokens);\n            ethCollected = ethCollected.add(ethRequire);\n            stage_2_TokensSold = stage_2_maxcap;\n            return true;\n        }\n    }\n    if(currentPhase == 3){\n        tokensToSend = _value.mul((uint)(10).pow(decimals))/stage_3_price;\n        if(stage_3_TokensSold.add(tokensToSend) <= STAGE_3_MAXCAP){\n            ethCollected = ethCollected.add(_value);\n            token.transfer(_address,tokensToSend);\n            distributionAddress.transfer(address(this).balance.sub(oraclizeBalance));\n            emit OnSuccessfullyBought(_address,_value,false,availableTokens);\n            stage_3_TokensSold = stage_3_TokensSold.add(tokensToSend);\n            return true;\n        }else{\n            if(stage_3_TokensSold == STAGE_3_MAXCAP){\n                return false;\n            }\n            availableTokens = STAGE_3_MAXCAP.sub(stage_3_TokensSold);\n            ethRequire = availableTokens.mul(stage_3_price)/(uint(10).pow(decimals));\n            token.transfer(_address,availableTokens);\n            msg.sender.transfer(_value.sub(ethRequire));\n            distributionAddress.transfer(address(this).balance.sub(oraclizeBalance));\n            emit OnSuccessfullyBought(_address,ethRequire,false,availableTokens);\n            ethCollected = ethCollected.add(ethRequire);\n            stage_3_TokensSold = STAGE_3_MAXCAP;\n            return true;\n        }\n    }\n    return false;\n}",
        "vulnerability": "Reentrancy vulnerability",
        "reason": "The function makes an external call to the token contract after updating the state variables, which could lead to reentrancy attacks if the token contract is malicious. The function should use the Checks-Effects-Interactions pattern to prevent reentrancy vulnerabilities.",
        "file_name": "0x0c2795fc4e1f57614eb78923dc78521ff0676fb8.sol"
    }
]