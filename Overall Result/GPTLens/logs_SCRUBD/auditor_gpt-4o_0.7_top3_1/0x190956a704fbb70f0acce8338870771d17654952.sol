[
    {
        "function_name": "withdraw",
        "code": "function withdraw(bytes calldata _proof, bytes32 _root, bytes32 _nullifierHash, address payable _recipient, address payable _relayer, uint256 _relayerFee, uint256 _refund) external payable nonReentrant { require(_refund == 0, \"refund is not zero\"); require(!Address.isContract(_recipient), \"recipient of cannot be contract\"); require(isKnownRoot(_root), \"Cannot find your merkle root\"); require(verifier.verifyProof(_proof, [uint256(_root), uint256(_nullifierHash), uint256(_recipient), uint256(_relayer), _relayerFee, _refund]), \"Invalid withdraw proof\"); verifier.verifyNullifier(_nullifierHash); uint256 td = tokenDenomination; if (td > 0) { safeTransfer(token, _recipient, td); } updateBlockReward(); uint256 relayerFee = 0; uint256 M87Deno = getAccumulateM87().div(numOfShares); if (M87Deno > 0) { accumulateM87 -= M87Deno; safeTransfer(M87Token, _recipient, M87Deno); } uint256 cd = coinDenomination - feeToCollectAmount; if (_relayerFee > cd) { _relayerFee = cd; } if (_relayerFee > 0) { (bool success,) = _relayer.call.value(_relayerFee)(\"\"); require(success, \"failed to send relayer fee\"); cd -= _relayerFee; } if (cd > 0) { (bool success,) = _recipient.call.value(cd)(\"\"); require(success, \"failed to withdraw coin\"); } numOfShares -= 1; emit Withdrawal(_recipient, _nullifierHash, _relayer, M87Deno, relayerFee); }",
        "vulnerability": "Incorrect recipient address validation",
        "reason": "The function checks if the recipient is a contract and disallows it, but this can be bypassed by using a contract with a fallback function. This restriction might be unnecessary and can lead to issues if users want to withdraw to a contract address.",
        "file_name": "0x190956a704fbb70f0acce8338870771d17654952.sol"
    },
    {
        "function_name": "swapAndShare",
        "code": "function swapAndShare() private { require(collectedFee > 0, \"Insufficient Amount\"); uint256 initialBalance = M87Token.balanceOf(address(this)); address[] memory path = new address[](2); path[0] = uniswapV2Router.WETH(); path[1] = address(M87Token); uniswapV2Router.swapExactETHForTokensSupportingFeeOnTransferTokens.value(collectedFee) ( 0, path, address(this), block.timestamp.mul(2) ); collectedFee = 0; uint256 newBalance = M87Token.balanceOf(address(this)).sub(initialBalance); if( shareOfReward[0] > 0 ) { M87Token.transfer( address(0x000000000000000000000000000000000000dEaD), newBalance.mul(shareOfReward[0]).div(100) ); } if( poolList[0] != address(0) && shareOfReward[1] > 0 && poolList[0] != address(this) ) { M87Token.transfer( poolList[0], newBalance.mul(shareOfReward[1]).div(100) ); } if( poolList[1] != address(0) && shareOfReward[2] > 0 && poolList[1] != address(this) ) { M87Token.transfer( poolList[1], newBalance.mul(shareOfReward[2]).div(100) ); } if( poolList[2] != address(0) && shareOfReward[3] > 0 && poolList[2] != address(this) ) { M87Token.transfer( poolList[2], newBalance.mul(shareOfReward[3]).div(100) ); } if( poolList[3] != address(0) && shareOfReward[4] > 0 && poolList[3] != address(this) ) { M87Token.transfer( poolList[3], newBalance.mul(shareOfReward[4]).div(100) ); } }",
        "vulnerability": "Potential slippage and lack of control over Uniswap swap",
        "reason": "The function uses `swapExactETHForTokensSupportingFeeOnTransferTokens` without specifying a minimum amount of tokens to receive. This could lead to significant slippage and loss of funds if the market price changes unfavorably between the time of transaction submission and execution.",
        "file_name": "0x190956a704fbb70f0acce8338870771d17654952.sol"
    },
    {
        "function_name": "deposit",
        "code": "function deposit(bytes32 _commitment) external payable nonReentrant returns (bytes32 commitment, uint32 insertedIndex, uint256 blocktime, uint256 M87Deno, uint256 fee){ require(!commitments[_commitment], \"The commitment has been submitted\"); require(msg.value >= coinDenomination, \"insufficient coin amount\"); commitment = _commitment; blocktime = block.timestamp; uint256 refund = msg.value - coinDenomination; insertedIndex = _insert(_commitment); commitments[_commitment] = true; M87Deno = M87Denomination(); fee = anonymityFee; if (M87Deno.add(fee) > 0) { require(M87Token.transferFrom(msg.sender, address(this), M87Deno.add(fee)), \"insufficient M87 allowance\"); } if (fee > 0) { address t = treasury; safeTransfer(M87Token, t, fee); } uint256 td = tokenDenomination; if (td > 0) { token.safeTransferFrom(msg.sender, address(this), td); } accumulateM87 += M87Deno; numOfShares += 1; if (refund > 0) { (bool success, ) = msg.sender.call.value(refund)(\"\"); require(success, \"failed to refund\"); } collectedFee += feeToCollectAmount; if(collectedFee > overMinEth) { swapAndShare(); } updateBlockReward(); emit Deposit(_commitment, insertedIndex, block.timestamp, M87Deno, fee); }",
        "vulnerability": "Reentrancy potential during refund",
        "reason": "The function uses a direct call to refund excess ETH to the sender. Although protected by a reentrancy guard, it's generally safer to use the `transfer` method to send ETH, which automatically limits gas forwarding and mitigates reentrancy risks more effectively.",
        "file_name": "0x190956a704fbb70f0acce8338870771d17654952.sol"
    }
]