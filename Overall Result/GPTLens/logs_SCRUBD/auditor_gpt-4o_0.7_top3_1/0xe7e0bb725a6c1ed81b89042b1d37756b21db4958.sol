[
    {
        "function_name": "BDSM_Crowdsale",
        "code": "function BDSM_Crowdsale(address _tokenAddress, address _owner, address _stopScamHolder) { owner = _owner; sharesTokenAddress = token(_tokenAddress); safeContract = _stopScamHolder; }",
        "vulnerability": "Uninitialized SafeMath library for arithmetic operations",
        "reason": "The contract uses arithmetic operations such as addition and multiplication without implementing a library like SafeMath, which is critical in preventing integer overflow and underflow vulnerabilities. In the context of a crowdsale, an overflow could allow an attacker to manipulate token amounts or ether transfers, leading to significant financial loss.",
        "file_name": "0xe7e0bb725a6c1ed81b89042b1d37756b21db4958.sol"
    },
    {
        "function_name": "fallback",
        "code": "function() payable { if(now > 1519084800) price = 0.0105 * 1 ether; else if(now > 1516406400) price = 0.0070 * 1 ether; tokenFree = sharesTokenAddress.balanceOf(this); if (now < startICO) { msg.sender.transfer(msg.value); } else if (now > stopICO) { msg.sender.transfer(msg.value); if(!tokenWithdraw){ sharesTokenAddress.transfer(safeContract, sharesTokenAddress.balanceOf(this)); tokenFree = sharesTokenAddress.balanceOf(this); tokenWithdraw = true; crowdsaleClosed = true; } } else if (crowdsaleClosed) { msg.sender.transfer(msg.value); } else { uint256 tokenToBuy = msg.value / price * coeff; if(tokenToBuy <= 0) msg.sender.transfer(msg.value); require(tokenToBuy > 0); uint256 actualETHTransfer = tokenToBuy * price / coeff; if (tokenFree >= tokenToBuy) { owner.transfer(actualETHTransfer); if (msg.value > actualETHTransfer){ msg.sender.transfer(msg.value - actualETHTransfer); } sharesTokenAddress.transfer(msg.sender, tokenToBuy); tokenSold += tokenToBuy; tokenFree -= tokenToBuy; if(tokenFree==0) crowdsaleClosed = true; } else { uint256 sendETH = tokenFree * price / coeff; owner.transfer(sendETH); sharesTokenAddress.transfer(msg.sender, tokenFree); msg.sender.transfer(msg.value - sendETH); tokenSold += tokenFree; tokenFree = sharesTokenAddress.balanceOf(this); crowdsaleClosed = true; } } TokenFree(tokenFree); CrowdsaleClosed(crowdsaleClosed); }",
        "vulnerability": "Reentrancy vulnerability",
        "reason": "The fallback function allows for ether transfers back to the sender and token transfers without proper handling of reentrancy attacks. An attacker can exploit this by recursively calling the fallback function before the state is updated, allowing them to drain the contract of its tokens or ether by repeatedly triggering reentrant calls.",
        "file_name": "0xe7e0bb725a6c1ed81b89042b1d37756b21db4958.sol"
    },
    {
        "function_name": "fallback",
        "code": "function() payable { if(now > 1519084800) price = 0.0105 * 1 ether; else if(now > 1516406400) price = 0.0070 * 1 ether; tokenFree = sharesTokenAddress.balanceOf(this); if (now < startICO) { msg.sender.transfer(msg.value); } else if (now > stopICO) { msg.sender.transfer(msg.value); if(!tokenWithdraw){ sharesTokenAddress.transfer(safeContract, sharesTokenAddress.balanceOf(this)); tokenFree = sharesTokenAddress.balanceOf(this); tokenWithdraw = true; crowdsaleClosed = true; } } else if (crowdsaleClosed) { msg.sender.transfer(msg.value); } else { uint256 tokenToBuy = msg.value / price * coeff; if(tokenToBuy <= 0) msg.sender.transfer(msg.value); require(tokenToBuy > 0); uint256 actualETHTransfer = tokenToBuy * price / coeff; if (tokenFree >= tokenToBuy) { owner.transfer(actualETHTransfer); if (msg.value > actualETHTransfer){ msg.sender.transfer(msg.value - actualETHTransfer); } sharesTokenAddress.transfer(msg.sender, tokenToBuy); tokenSold += tokenToBuy; tokenFree -= tokenToBuy; if(tokenFree==0) crowdsaleClosed = true; } else { uint256 sendETH = tokenFree * price / coeff; owner.transfer(sendETH); sharesTokenAddress.transfer(msg.sender, tokenFree); msg.sender.transfer(msg.value - sendETH); tokenSold += tokenFree; tokenFree = sharesTokenAddress.balanceOf(this); crowdsaleClosed = true; } } TokenFree(tokenFree); CrowdsaleClosed(crowdsaleClosed); }",
        "vulnerability": "Incorrect ether transfer logic",
        "reason": "There is a potential logic error in the transfer of ether where the calculated 'actualETHTransfer' or 'sendETH' could be incorrect if the arithmetic precision is not handled properly. This could result in incorrect ether amounts being transferred to the owner and incorrect refunds to the sender, leading to financial discrepancies and potential loss for participants in the crowdsale.",
        "file_name": "0xe7e0bb725a6c1ed81b89042b1d37756b21db4958.sol"
    }
]