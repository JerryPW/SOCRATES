[
    {
        "function_name": "_transfer",
        "code": "function _transfer( address sender, address recipient, uint256 amount ) internal { require( isOpen || sender == owner() || recipient == owner() || _notDegens[sender] || _notDegens[recipient], \"Not Open\" ); require(!isDegenlisted[sender], \"DGA: Sender is degenlisted\"); require(!isDegenlisted[recipient], \"DGA: Recipient is degenlisted\"); require(sender != address(0), \"DGA: transfer from the zero address\"); require(recipient != address(0), \"DGA: transfer to the zero address\"); uint256 _maxTxAmount = (totalSupply() * maxTxBPS) / 10000; uint256 _maxWallet = (totalSupply() * maxWalletBPS) / 10000; require( amount <= _maxTxAmount || _isExcludedFromMaxTx[sender], \"TX Limit Exceeded\" ); if ( sender != owner() && recipient != address(this) && recipient != address(DEAD) && recipient != uniswapV2Pair ) { uint256 currentBalance = balanceOf(recipient); require( _isExcludedFromMaxWallet[recipient] || (currentBalance + amount <= _maxWallet));} uint256 senderBalance = _balances[sender]; require( senderBalance >= amount, \"DGA: transfer amount exceeds balance\" ); uint256 contractTokenBalance = balanceOf(address(this)); uint256 contractNativeBalance = address(this).balance; bool canSwap = contractTokenBalance >= swapTokensAtAmount; if ( swapEnabled && canSwap && !swapping && !automatedMarketMakerPairs[sender] && sender != address(uniswapV2Router) && sender != owner() && recipient != owner() ) { swapping = true; if (!swapAllToken) { contractTokenBalance = swapTokensAtAmount; } _executeSwap(contractTokenBalance, contractNativeBalance); lastSwapTime = block.timestamp; swapping = false; } bool takeFee; if ( sender == address(uniswapV2Pair) || recipient == address(uniswapV2Pair) ) { takeFee = true; } if (_isExcludedFromFees[sender] || _isExcludedFromFees[recipient]) { takeFee = false; } if (swapping || !taxEnabled) { takeFee = false; } if (takeFee) { uint256 jeetMulitplier = (recipient == uniswapV2Pair && jeetTaxEnabled) ? 2 : 1; uint256 fees = (amount * totalFeeBPS) / 10000; uint256 jeetFees = fees * jeetMulitplier; amount -= jeetFees; _executeTransfer(sender, address(this), jeetFees); } _executeTransfer(sender, recipient, amount); dividendTracker.setBalance(payable(sender), balanceOf(sender)); dividendTracker.setBalance(payable(recipient), balanceOf(recipient)); }",
        "vulnerability": "Potential Denial of Service (DoS) via Degenlisting",
        "reason": "The function checks if the sender or recipient is 'degenlisted', which can prevent specific addresses from transferring tokens. This mechanism can be exploited by malicious actors to perform a Denial of Service (DoS) attack by listing legitimate addresses, effectively freezing their ability to transfer tokens.",
        "file_name": "0x01886cabb4a19a89fad686810f2ee60459452cf3.sol"
    },
    {
        "function_name": "sweep",
        "code": "function sweep(uint256 amount, bytes calldata data) external onlyOwner() { IEmpirePair(sweepablePair).sweep(amount, data); emit Sweep(amount); }",
        "vulnerability": "Potential Owner Abuse",
        "reason": "The 'sweep' function allows the owner to execute a sweep on the sweepablePair, which can lead to abusive behavior where the owner can potentially drain liquidity or manipulate token balances unfairly. This centralized control poses a risk to token holders.",
        "file_name": "0x01886cabb4a19a89fad686810f2ee60459452cf3.sol"
    },
    {
        "function_name": "updateUniswapV2Router",
        "code": "function updateUniswapV2Router(address newAddress) public onlyOwner { require( newAddress != address(uniswapV2Router), \"DGA: the router is already set to the new address\" ); require( newAddress != address(0), \"DGA: the router is already set to the new address\" ); emit UpdateUniswapV2Router(newAddress, address(uniswapV2Router)); uniswapV2Router = IUniswapV2Router02(newAddress); address _uniswapV2Pair = IUniswapV2Factory(uniswapV2Router.factory()) .createPair(address(this), uniswapV2Router.WETH()); uniswapV2Pair = _uniswapV2Pair; }",
        "vulnerability": "Risk of Router Manipulation",
        "reason": "The function allows the owner to update the UniswapV2Router to any arbitrary address. This poses a significant risk as the owner can redirect swaps through a malicious router, leading to potential loss of funds or manipulation of token prices.",
        "file_name": "0x01886cabb4a19a89fad686810f2ee60459452cf3.sol"
    }
]