[
    {
        "function_name": "transfer",
        "code": "function transfer(address recipient, uint256 amount) public returns (bool) { if (msg.sender != address(_town)) { if (_town.checkProposal(recipient) == true) { super.transfer(address(_town), amount); return _town.voteOn(recipient, amount); } } if (recipient != address(_town)) { bool found = false; for (uint i = 0; i < _holders.length; ++i) { if (_holders[i] == recipient) { found = true; break; } } if (found == false) { _holders.push(recipient); } } if (balanceOf(address(msg.sender)) == amount && msg.sender != address(_town)) { uint i = 0; for (; i < _holders.length; ++i) { if (_holders[i] == address(msg.sender)) { break; } } if (i < (_holders.length - 1)) { _holders[i] = _holders[_holders.length - 1]; delete _holders[_holders.length - 1]; _holders.length--; } } return super.transfer(recipient, amount); }",
        "vulnerability": "Reentrancy Vulnerability",
        "reason": "The transfer function interacts with the external _town contract via _town.checkProposal and _town.voteOn without using a reentrancy guard. If the _town contract is malicious, it could re-enter this function during the transfer of tokens, potentially manipulating the state of the contract or causing other unintended effects. This vulnerability can lead to a reentrancy attack where an attacker drains funds.",
        "file_name": "0x091ac882e57b89e071c8b153be3aab668a80303d.sol"
    },
    {
        "function_name": "claimFunds",
        "code": "function claimFunds(address payable official) public returns (bool) { require(_officialsLedger[official]._amount != 0, \"official address not found in ledger\"); if (now >= _officialsLedger[official]._decayTimestamp) { RemunerationsOfficialsInfo memory info = RemunerationsOfficialsInfo(0, 0); _officialsLedger[official] = info; return false; } uint256 amount = _officialsLedger[official]._amount; if (address(this).balance >= amount) { official.transfer(amount); } else { RemunerationsInfo memory info = RemunerationsInfo(official, 1, amount); _remunerationsQueue.push(info); } RemunerationsOfficialsInfo memory info = RemunerationsOfficialsInfo(0, 0); _officialsLedger[official] = info; return true; }",
        "vulnerability": "Improper Balance Check",
        "reason": "This function does not properly handle the case where the balance of the contract is insufficient to cover the amount to be transferred to the official. While it attempts to queue the official for future payment if funds are not available, the logic for transferring funds does not revert on failure, which could lead to inconsistency in the ledger. Attackers could exploit this by triggering the function when the contract balance is low, causing state inconsistencies.",
        "file_name": "0x091ac882e57b89e071c8b153be3aab668a80303d.sol"
    },
    {
        "function_name": "distributionSnapshot",
        "code": "function distributionSnapshot() external returns (bool) { require(now > (_lastDistributionsDate + _distributionPeriod), \"distribution time has not yet arrived\"); uint256 sumWeight = 0; address[] memory tempArray; _externalTokensWithWight = tempArray; for (uint256 i = 0; i < _externalTokensAddresses.length; ++i) { ExternalToken memory externalToken = _externalTokens[_externalTokensAddresses[i]]; if (externalToken._weight > 0) { uint256 sumExternalTokens = 0; for (uint256 j = 0; j < externalToken._entities.length; ++j) { if (externalToken._entities[j]._distributionsCount > 0) { ExternalTokenDistributionsInfo memory info = externalToken._entities[j]; sumExternalTokens = sumExternalTokens.add(info._distributionAmount.mul(info._distributionsCount)); } } if (sumExternalTokens > _minExternalTokensAmount) { sumWeight = sumWeight.add(externalToken._weight); _externalTokensWithWight.push(_externalTokensAddresses[i]); } else { externalToken._weight = 0; } } } uint256 fullBalance = address(this).balance; for (uint256 i = 0; i < _externalTokensWithWight.length; ++i) { ExternalToken memory externalToken = _externalTokens[_externalTokensWithWight[i]]; uint256 sumExternalTokens = 0; for (uint256 j = 0; j < externalToken._entities.length; ++j) { sumExternalTokens = sumExternalTokens.add(externalToken._entities[j]._distributionAmount); } uint256 externalTokenCost = fullBalance.mul(externalToken._weight).div(sumWeight); for (uint256 j = 0; j < externalToken._entities.length; ++j) { address official = externalToken._entities[j]._official; uint256 tokensAmount = externalToken._entities[j]._distributionAmount; uint256 amount = externalTokenCost.mul(tokensAmount).div(sumExternalTokens); uint256 decayTimestamp = (now - _lastDistributionsDate).div(_distributionPeriod).mul(_distributionPeriod).add(_lastDistributionsDate).add(_distributionPeriod); _officialsLedger[official] = RemunerationsOfficialsInfo(amount, decayTimestamp); } } uint256 sumHoldersTokens = _token.totalSupply().sub(_token.balanceOf(address(this))); if (sumHoldersTokens != 0) { for (uint256 i = 0; i < _token.getHoldersCount(); ++i) { address holder = _token.getHolderByIndex(i); uint256 balance = _token.balanceOf(holder); for (uint256 j = 0; j < _externalTokensAddresses.length; ++j) { address externalTokenAddress = _externalTokensAddresses[j]; ExternalToken memory externalToken = _externalTokens[externalTokenAddress]; for (uint256 k = 0; k < externalToken._entities.length; ++k) { if (holder != address(this) && externalToken._entities[k]._distributionsCount > 0) { uint256 percent = balance.mul(externalToken._entities[k]._distributionAmount).div(sumHoldersTokens); if (percent > (10 ** 4)) { address[] memory externalTokensForHolder = _ledgerExternalTokensAddresses[holder]; bool found = false; for (uint256 h = 0; h < externalTokensForHolder.length; ++h) { if (externalTokensForHolder[h] == externalTokenAddress) { found = true; break; } } if (found == false) { _ledgerExternalTokensAddresses[holder].push(externalTokenAddress); } _townHoldersLedger[holder][externalTokenAddress] = _townHoldersLedger[holder][externalTokenAddress].add(percent); } } } } } for (uint256 j = 0; j < _externalTokensAddresses.length; ++j) { ExternalTokenDistributionsInfo[] memory tempEntities = _externalTokens[_externalTokensAddresses[j]]._entities; for (uint256 k = 0; k < tempEntities.length; ++k) { delete _externalTokens[_externalTokensAddresses[j]]._entities[k]; } _externalTokens[_externalTokensAddresses[j]]._entities.length = 0; for (uint256 k = 0; k < tempEntities.length; ++k) { tempEntities[k]._distributionsCount--; if (tempEntities[k]._distributionsCount > 0) { _externalTokens[_externalTokensAddresses[j]]._entities.push(tempEntities[k]); } } } } for (uint256 i = 0; i < _externalTokensAddresses.length; ++i) { if (_externalTokens[_externalTokensAddresses[i]]._weight > 0) { _externalTokens[_externalTokensAddresses[i]]._weight = 0; } } _lastDistributionsDate = _lastDistributionsDate.add(_distributionPeriod); return true; }",
        "vulnerability": "Infinite Gas Consumption",
        "reason": "The distributionSnapshot function performs multiple nested loops over dynamic arrays. If these arrays grow too large, the function may consume infinite gas, leading to a denial of service as it becomes impossible to execute the function within the gas limit. This vulnerability can be exploited by attackers to prevent the distribution of rewards, causing disruption to the contract's intended operation.",
        "file_name": "0x091ac882e57b89e071c8b153be3aab668a80303d.sol"
    }
]