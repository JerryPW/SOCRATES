[
    {
        "function_name": "BDSM_Crowdsale",
        "code": "function BDSM_Crowdsale(address _tokenAddress, address _owner, address _stopScamHolder) { owner = _owner; sharesTokenAddress = token(_tokenAddress); safeContract = _stopScamHolder; }",
        "vulnerability": "Lack of input validation",
        "reason": "The constructor does not validate the input addresses. If any of these addresses, especially _tokenAddress or _owner, are set to a zero address or an incorrect contract address, it could lead to unexpected behavior or contract misconfiguration. This could potentially lock funds or allow unauthorized access.",
        "file_name": "0x61683dfbe07e98a4edbddc2f1f1a44a75fa74912.sol"
    },
    {
        "function_name": "fallback",
        "code": "function() payable { if(now > priceIncrease_20_February){ price = \"0.007 Ether for 1 microBDSM\"; realPrice = 0.007 * 1 ether; } else if(now > priceIncrease_20_January){ price = \"0.00525 Ether for 1 microBDSM\"; realPrice = 0.00525 * 1 ether; } tokenFree = sharesTokenAddress.balanceOf(this); if (now < startICO_20_December) { msg.sender.transfer(msg.value); } else if (now > stopICO_20_March) { msg.sender.transfer(msg.value); if(!tokensWithdrawn){ sharesTokenAddress.transfer(safeContract, sharesTokenAddress.balanceOf(this)); tokenFree = sharesTokenAddress.balanceOf(this); tokensWithdrawn = true; crowdsaleClosed = true; } } else if (crowdsaleClosed) { msg.sender.transfer(msg.value); } else { uint256 tokenToBuy = msg.value / realPrice * coeff; if(tokenToBuy <= 0) msg.sender.transfer(msg.value); require(tokenToBuy > 0); uint256 actualETHTransfer = tokenToBuy * realPrice / coeff; if (tokenFree >= tokenToBuy) { owner.transfer(actualETHTransfer); if (msg.value > actualETHTransfer){ msg.sender.transfer(msg.value - actualETHTransfer); } sharesTokenAddress.transfer(msg.sender, tokenToBuy); tokenSold += tokenToBuy; tokenFree -= tokenToBuy; if(tokenFree==0) crowdsaleClosed = true; } else { uint256 sendETH = tokenFree * realPrice / coeff; owner.transfer(sendETH); sharesTokenAddress.transfer(msg.sender, tokenFree); msg.sender.transfer(msg.value - sendETH); tokenSold += tokenFree; tokenFree = sharesTokenAddress.balanceOf(this); crowdsaleClosed = true; } } TokenFree(tokenFree); CrowdsaleClosed(crowdsaleClosed); }",
        "vulnerability": "Reentrancy attacks",
        "reason": "The fallback function transfers Ether to the sender before changing the state variables. Specifically, when refunding the excess Ether, it calls msg.sender.transfer(msg.value - actualETHTransfer); before updating internal state variables like tokenSold and tokenFree. This pattern can be exploited using a reentrancy attack where the attacker uses a fallback function to call back into the function before the state changes are finalized.",
        "file_name": "0x61683dfbe07e98a4edbddc2f1f1a44a75fa74912.sol"
    },
    {
        "function_name": "fallback",
        "code": "function() payable { if(now > priceIncrease_20_February){ price = \"0.007 Ether for 1 microBDSM\"; realPrice = 0.007 * 1 ether; } else if(now > priceIncrease_20_January){ price = \"0.00525 Ether for 1 microBDSM\"; realPrice = 0.00525 * 1 ether; } tokenFree = sharesTokenAddress.balanceOf(this); if (now < startICO_20_December) { msg.sender.transfer(msg.value); } else if (now > stopICO_20_March) { msg.sender.transfer(msg.value); if(!tokensWithdrawn){ sharesTokenAddress.transfer(safeContract, sharesTokenAddress.balanceOf(this)); tokenFree = sharesTokenAddress.balanceOf(this); tokensWithdrawn = true; crowdsaleClosed = true; } } else if (crowdsaleClosed) { msg.sender.transfer(msg.value); } else { uint256 tokenToBuy = msg.value / realPrice * coeff; if(tokenToBuy <= 0) msg.sender.transfer(msg.value); require(tokenToBuy > 0); uint256 actualETHTransfer = tokenToBuy * realPrice / coeff; if (tokenFree >= tokenToBuy) { owner.transfer(actualETHTransfer); if (msg.value > actualETHTransfer){ msg.sender.transfer(msg.value - actualETHTransfer); } sharesTokenAddress.transfer(msg.sender, tokenToBuy); tokenSold += tokenToBuy; tokenFree -= tokenToBuy; if(tokenFree==0) crowdsaleClosed = true; } else { uint256 sendETH = tokenFree * realPrice / coeff; owner.transfer(sendETH); sharesTokenAddress.transfer(msg.sender, tokenFree); msg.sender.transfer(msg.value - sendETH); tokenSold += tokenFree; tokenFree = sharesTokenAddress.balanceOf(this); crowdsaleClosed = true; } } TokenFree(tokenFree); CrowdsaleClosed(crowdsaleClosed); }",
        "vulnerability": "Potential for locked funds",
        "reason": "If the sharesTokenAddress.transfer function fails, the contract may not correctly update the state variables tokenSold or tokenFree, potentially causing a deadlock where funds are locked in the contract and neither the tokens nor the Ether can be correctly allocated or refunded.",
        "file_name": "0x61683dfbe07e98a4edbddc2f1f1a44a75fa74912.sol"
    }
]