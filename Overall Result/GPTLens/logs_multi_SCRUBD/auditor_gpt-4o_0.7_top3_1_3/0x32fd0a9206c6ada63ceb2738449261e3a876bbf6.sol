[
    {
        "function_name": "getTownTokens",
        "code": "function getTownTokens(address holder) public payable returns (bool) { require(holder != address(0), \"holder address cannot be null\"); uint256 amount = msg.value; uint256 tokenAmount = IWantTakeTokensToAmount(amount); uint256 rate = currentRate(); if (_transactionsCount < _durationOfMinTokenGetAmount && tokenAmount < _minTokenGetAmount) { return false; } if (tokenAmount >= _maxTokenGetAmount) { tokenAmount = _maxTokenGetAmount; uint256 change = amount.sub(_maxTokenGetAmount.mul(rate).div(10 ** 18)); msg.sender.transfer(change); amount = amount.sub(change); } if (_token.balanceOf(address(this)) >= tokenAmount) { TransactionsInfo memory transactionsHistory = TransactionsInfo(rate, tokenAmount); _token.transfer(holder, tokenAmount); _historyTransactions[holder].push(transactionsHistory); _transactionsCount = _transactionsCount.add(1); } else { if (_token.balanceOf(address(this)) > 0) { uint256 tokenBalance = _token.balanceOf(address(this)); _token.transfer(holder, tokenBalance); TransactionsInfo memory transactionsHistory = TransactionsInfo(rate, tokenBalance); _historyTransactions[holder].push(transactionsHistory); tokenAmount = tokenAmount.sub(tokenBalance); } TransactionsInfo memory transactionsInfo = TransactionsInfo(rate, tokenAmount); TownTokenRequest memory tokenRequest = TownTokenRequest(holder, transactionsInfo); _queueTownTokenRequests.push(tokenRequest); } for (uint256 i = 0; i < _remunerationsQueue.length; ++i) { if (_remunerationsQueue[i]._priority == 1) { if (_remunerationsQueue[i]._amount > amount) { _remunerationsQueue[i]._address.transfer(_remunerationsQueue[i]._amount); amount = amount.sub(_remunerationsQueue[i]._amount); for (uint j = i + 1; j < _remunerationsQueue.length; ++j) { _remunerationsQueue[j - 1] = _remunerationsQueue[j]; } _remunerationsQueue.pop(); } else { _remunerationsQueue[i]._address.transfer(amount); _remunerationsQueue[i]._amount = _remunerationsQueue[i]._amount.sub(amount); break; } } } for (uint256 i = 0; i < _remunerationsQueue.length; ++i) { if (_remunerationsQueue[i]._amount > amount) { _remunerationsQueue[i]._address.transfer(_remunerationsQueue[i]._amount); amount = amount.sub(_remunerationsQueue[i]._amount); for (uint j = i + 1; j < _remunerationsQueue.length; ++j) { _remunerationsQueue[j - 1] = _remunerationsQueue[j]; } _remunerationsQueue.pop(); } else { _remunerationsQueue[i]._address.transfer(amount); _remunerationsQueue[i]._amount = _remunerationsQueue[i]._amount.sub(amount); break; } } return true; }",
        "vulnerability": "Reentrancy vulnerability",
        "reason": "The function sends Ether to msg.sender via transfer before updating the internal state. This can allow a reentrancy attack where an attacker can call getTownTokens recursively, depleting the contract\u2019s funds or manipulating its state maliciously.",
        "file_name": "0x32fd0a9206c6ada63ceb2738449261e3a876bbf6.sol"
    },
    {
        "function_name": "claimFunds",
        "code": "function claimFunds(address payable official) public returns (bool) { require(_officialsLedger[official]._amount != 0, \"official address not found in ledger\"); if (block.timestamp >= _officialsLedger[official]._decayTimestamp) { RemunerationsOfficialsInfo memory info = RemunerationsOfficialsInfo(0, 0); _officialsLedger[official] = info; return false; } uint256 amount = _officialsLedger[official]._amount; if (address(this).balance >= amount) { official.transfer(amount); } else { RemunerationsInfo memory info = RemunerationsInfo(official, 1, amount); _remunerationsQueue.push(info); } RemunerationsOfficialsInfo memory info = RemunerationsOfficialsInfo(0, 0); _officialsLedger[official] = info; return true; }",
        "vulnerability": "Reentrancy vulnerability",
        "reason": "The function sends Ether to the official address using transfer before updating the internal state. This allows a reentrancy attack where an attacker could re-enter the function, causing inconsistencies in the contract\u2019s state or depleting funds.",
        "file_name": "0x32fd0a9206c6ada63ceb2738449261e3a876bbf6.sol"
    },
    {
        "function_name": "sendExternalTokens",
        "code": "function sendExternalTokens(address official, address externalToken) external returns (bool) { Token tokenERC20 = Token(externalToken); uint256 balance = tokenERC20.allowance(official, address(this)); require(tokenERC20.balanceOf(official) >= balance, \"Official should have external tokens for approved\"); require(balance > 0, \"External tokens must be approved for town smart contract\"); tokenERC20.transferFrom(official, address(this), balance); ExternalTokenDistributionsInfo memory tokenInfo; tokenInfo._official = official; tokenInfo._distributionsCount = _distributionPeriodsNumber; tokenInfo._distributionAmount = balance.div(_distributionPeriodsNumber); ExternalToken storage tokenObj = _externalTokens[externalToken]; if (tokenObj._entities.length == 0) { _externalTokensAddresses.push(externalToken); } tokenObj._entities.push(tokenInfo); emit Proposal(balance, tokenInfo._official, tokenInfo._distributionsCount, tokenInfo._distributionAmount, externalToken); return true; }",
        "vulnerability": "Approval race condition",
        "reason": "The function assumes that the approved amount of tokens will not change between the allowance call and the transferFrom call. An attacker can change the approved amount in between these calls, causing transfers of unintended amounts, potentially leading to theft of tokens.",
        "file_name": "0x32fd0a9206c6ada63ceb2738449261e3a876bbf6.sol"
    }
]