[
    {
        "function_name": "revoke",
        "code": "function revoke() public onlyAdministrator activeGame { for (uint i = 0; i < ticketIndex.length; i++) { tickets[ticketIndex[i]].is_active = false; ticketIndex[i].transfer(bet); } state = State.REVOKED; }",
        "vulnerability": "reentrancy",
        "reason": "The revoke function transfers Ether to players via ticketIndex[i].transfer(bet). This can potentially lead to a reentrancy attack if a malicious contract is a player, allowing the attacker to re-enter the function and drain the contract's funds before the function completes.",
        "file_name": "0xb588530e3956d9787b0429244ca360f566ff3301.sol"
    },
    {
        "function_name": "finish",
        "code": "function finish() public onlyAdministrator activeGame { uint max_votes; for (uint i = 0; i < ticketIndex.length; i++) { TicketLib.Ticket memory ticket = tickets[ticketIndex[i]]; uint vote = ( ( ticket.block_number * ticket.block_time ) + uint(ticketIndex[i]) ) % ticketIndex.length; tickets[ticketIndex[vote]].num_votes += 1; uint ticketNumVotes = tickets[ticketIndex[vote]].num_votes; if ( ticketNumVotes > max_votes ) { max_votes = ticketNumVotes; winnerIndex = vote; } } uint[] memory prizes = calcaultePrizes(); uint lastId = winnerIndex; for ( i = 0; i < prizes.length; i++ ) { if (tickets[ticketIndex[lastId]].is_active) { tickets[ticketIndex[lastId]].prize = prizes[i]; tickets[ticketIndex[lastId]].is_winner = true; ticketIndex[lastId].transfer(prizes[i]); } else { i--; } if ( lastId <= 0 ) { lastId = ticketIndex.length; } lastId -= 1; } administrator.transfer(this.balance); state = State.ENDED; GameFinished(ticketIndex[winnerIndex]); }",
        "vulnerability": "reentrancy",
        "reason": "The finish function transfers Ether to players using ticketIndex[lastId].transfer(prizes[i]). If a malicious contract is a player, it can re-enter the function due to the transfer call, potentially allowing the attacker to manipulate the game outcome or drain funds.",
        "file_name": "0xb588530e3956d9787b0429244ca360f566ff3301.sol"
    },
    {
        "function_name": "finish",
        "code": "function finish() public onlyAdministrator activeGame { uint max_votes; for (uint i = 0; i < ticketIndex.length; i++) { TicketLib.Ticket memory ticket = tickets[ticketIndex[i]]; uint vote = ( ( ticket.block_number * ticket.block_time ) + uint(ticketIndex[i]) ) % ticketIndex.length; tickets[ticketIndex[vote]].num_votes += 1; uint ticketNumVotes = tickets[ticketIndex[vote]].num_votes; if ( ticketNumVotes > max_votes ) { max_votes = ticketNumVotes; winnerIndex = vote; } } uint[] memory prizes = calcaultePrizes(); uint lastId = winnerIndex; for ( i = 0; i < prizes.length; i++ ) { if (tickets[ticketIndex[lastId]].is_active) { tickets[ticketIndex[lastId]].prize = prizes[i]; tickets[ticketIndex[lastId]].is_winner = true; ticketIndex[lastId].transfer(prizes[i]); } else { i--; } if ( lastId <= 0 ) { lastId = ticketIndex.length; } lastId -= 1; } administrator.transfer(this.balance); state = State.ENDED; GameFinished(ticketIndex[winnerIndex]); }",
        "vulnerability": "predictable randomness",
        "reason": "The randomness for selecting the winner is based on block attributes and player addresses, which are predictable. This allows an attacker to potentially influence the outcome by strategically timing their participation or manipulating block attributes.",
        "file_name": "0xb588530e3956d9787b0429244ca360f566ff3301.sol"
    }
]