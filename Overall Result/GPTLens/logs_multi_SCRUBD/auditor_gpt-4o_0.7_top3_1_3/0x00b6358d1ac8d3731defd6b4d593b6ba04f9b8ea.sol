[
    {
        "function_name": "withdraw",
        "code": "function withdraw(uint8 coin) external { (uint256 to_payout, uint256 max_payout) = this.payoutOf(msg.sender); if(to_payout > 0) { if(users[msg.sender].payouts + to_payout > max_payout) { to_payout = max_payout - users[msg.sender].payouts; } users[msg.sender].deposit_payouts += to_payout; users[msg.sender].payouts += to_payout; _refPayout(msg.sender, to_payout); } if(users[msg.sender].payouts < max_payout && users[msg.sender].direct_bonus > 0) { uint256 direct_bonus = users[msg.sender].direct_bonus; if(users[msg.sender].payouts + direct_bonus > max_payout) { direct_bonus = max_payout - users[msg.sender].payouts; } users[msg.sender].direct_bonus -= direct_bonus; users[msg.sender].payouts += direct_bonus; to_payout += direct_bonus; } if(users[msg.sender].payouts < max_payout && users[msg.sender].pool_bonus > 0) { uint256 pool_bonus = users[msg.sender].pool_bonus; if(users[msg.sender].payouts + pool_bonus > max_payout) { pool_bonus = max_payout - users[msg.sender].payouts; } users[msg.sender].pool_bonus -= pool_bonus; users[msg.sender].payouts += pool_bonus; to_payout += pool_bonus; } if(users[msg.sender].payouts < max_payout && users[msg.sender].match_bonus > 0) { uint256 match_bonus = users[msg.sender].match_bonus; if(users[msg.sender].payouts + match_bonus > max_payout) { match_bonus = max_payout - users[msg.sender].payouts; } users[msg.sender].match_bonus -= match_bonus; users[msg.sender].payouts += match_bonus; to_payout += match_bonus; } if(users[msg.sender].payouts < max_payout && matrixUser[msg.sender].matrix_bonus > 0) { if(users[msg.sender].isWithdrawActive){ uint256 matrix_bonus = matrixUser[msg.sender].matrix_bonus; if(users[msg.sender].payouts + matrix_bonus > max_payout) { matrix_bonus = max_payout - users[msg.sender].payouts; } matrixUser[msg.sender].matrix_bonus -= matrix_bonus; users[msg.sender].payouts += matrix_bonus; to_payout += matrix_bonus; } else{ matrixUser[msg.sender].matrix_bonus = 0; } } if(users[msg.sender].payouts < max_payout && matrixUser[msg.sender].leader_bonus > 0) { uint256 leader_bonus = matrixUser[msg.sender].leader_bonus; if(users[msg.sender].payouts + leader_bonus > max_payout) { leader_bonus = max_payout - users[msg.sender].payouts; } matrixUser[msg.sender].leader_bonus -= leader_bonus; users[msg.sender].payouts += leader_bonus; to_payout += leader_bonus; } require(to_payout > 0, \"Zero payout\"); users[msg.sender].total_payouts += to_payout; total_withdraw += to_payout; uint256 matrixbonus = to_payout.mul(20).div(100); calcMatrixBonus(msg.sender,matrixbonus); to_payout -= to_payout.mul(20).div(100); if(coin == 0){ payable(msg.sender).transfer(to_payout); } else if(coin == 1){ _token.send(msg.sender,to_payout,\"Token Withdrawed\"); } emit Withdraw(msg.sender, to_payout); if(users[msg.sender].payouts >= max_payout) { users[msg.sender].isWithdrawActive = false; emit LimitReached(msg.sender, users[msg.sender].payouts); } }",
        "vulnerability": "Reentrancy vulnerability",
        "reason": "The function allows for Ether transfer before updating all state variables, making it potentially susceptible to reentrancy attacks. An attacker could reenter the contract to drain funds by exploiting this vulnerability, especially since external calls are made before the state is fully updated.",
        "file_name": "0x00b6358d1ac8d3731defd6b4d593b6ba04f9b8ea.sol"
    },
    {
        "function_name": "emergencyWithdraw",
        "code": "function emergencyWithdraw() external { (uint256 to_payout, uint256 max_payout) = this.payoutOf(msg.sender); if(to_payout > 0) { if(users[msg.sender].payouts + to_payout > max_payout) { to_payout = max_payout - users[msg.sender].payouts; } users[msg.sender].deposit_payouts += to_payout; users[msg.sender].payouts += to_payout; _refPayout(msg.sender, to_payout); } require(to_payout > 0, \"Zero payout\"); users[msg.sender].total_payouts += to_payout; total_withdraw += to_payout; to_payout -= to_payout.mul(20).div(100); payable(msg.sender).transfer(to_payout); emit EmergencyWithdraw(msg.sender, to_payout); if(users[msg.sender].payouts >= max_payout) { users[msg.sender].isWithdrawActive = false; emit LimitReached(msg.sender, users[msg.sender].payouts); } }",
        "vulnerability": "Reentrancy vulnerability",
        "reason": "Similar to the 'withdraw' function, this function is vulnerable to reentrancy because it transfers Ether to the caller before all state changes are done. An attacker could exploit this to repeatedly call `emergencyWithdraw` and drain funds.",
        "file_name": "0x00b6358d1ac8d3731defd6b4d593b6ba04f9b8ea.sol"
    },
    {
        "function_name": "tokensReceived",
        "code": "function tokensReceived(address operator, address from, address to, uint256 amount, bytes calldata userData, bytes calldata operatorData) external { require(msg.sender == address(_token), \"Invalid token\"); require(tempUpline[from] != address(0),\"No referral found\"); _deposit(from,amount,1); }",
        "vulnerability": "Lack of access control",
        "reason": "The function `tokensReceived` lacks proper access control and can be called by any address. This allows unauthorized parties to potentially trigger deposits and manipulate contract state unexpectedly.",
        "file_name": "0x00b6358d1ac8d3731defd6b4d593b6ba04f9b8ea.sol"
    }
]