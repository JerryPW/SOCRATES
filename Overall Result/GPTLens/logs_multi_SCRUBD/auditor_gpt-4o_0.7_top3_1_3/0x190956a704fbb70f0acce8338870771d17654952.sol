[
    {
        "function_name": "withdraw",
        "code": "function withdraw(bytes calldata _proof, bytes32 _root, bytes32 _nullifierHash, address payable _recipient, address payable _relayer, uint256 _relayerFee, uint256 _refund) external payable nonReentrant { require(_refund == 0, \"refund is not zero\"); require(!Address.isContract(_recipient), \"recipient of cannot be contract\"); require(isKnownRoot(_root), \"Cannot find your merkle root\"); require(verifier.verifyProof(_proof, [uint256(_root), uint256(_nullifierHash), uint256(_recipient), uint256(_relayer), _relayerFee, _refund]), \"Invalid withdraw proof\"); verifier.verifyNullifier(_nullifierHash); uint256 td = tokenDenomination; if (td > 0) { safeTransfer(token, _recipient, td); } updateBlockReward(); uint256 relayerFee = 0; uint256 M87Deno = getAccumulateM87().div(numOfShares); if (M87Deno > 0) { accumulateM87 -= M87Deno; safeTransfer(M87Token, _recipient, M87Deno); } uint256 cd = coinDenomination - feeToCollectAmount; if (_relayerFee > cd) { _relayerFee = cd; } if (_relayerFee > 0) { (bool success,) = _relayer.call.value(_relayerFee)(\"\"); require(success, \"failed to send relayer fee\"); cd -= _relayerFee; } if (cd > 0) { (bool success,) = _recipient.call.value(cd)(\"\"); require(success, \"failed to withdraw coin\"); } numOfShares -= 1; emit Withdrawal(_recipient, _nullifierHash, _relayer, M87Deno, relayerFee); }",
        "vulnerability": "Recipient Address Check Bypass",
        "reason": "The function checks if the recipient is a contract and blocks it, but this check can be bypassed by contracts that utilize a constructor or proxy pattern, allowing funds to be sent to a contract potentially, contrary to the intention.",
        "file_name": "0x190956a704fbb70f0acce8338870771d17654952.sol"
    },
    {
        "function_name": "deposit",
        "code": "function deposit(bytes32 _commitment) external payable nonReentrant returns (bytes32 commitment, uint32 insertedIndex, uint256 blocktime, uint256 M87Deno, uint256 fee){ require(!commitments[_commitment], \"The commitment has been submitted\"); require(msg.value >= coinDenomination, \"insufficient coin amount\"); commitment = _commitment; blocktime = block.timestamp; uint256 refund = msg.value - coinDenomination; insertedIndex = _insert(_commitment); commitments[_commitment] = true; M87Deno = M87Denomination(); fee = anonymityFee; if (M87Deno.add(fee) > 0) { require(M87Token.transferFrom(msg.sender, address(this), M87Deno.add(fee)), \"insufficient M87 allowance\"); } if (fee > 0) { address t = treasury; safeTransfer(M87Token, t, fee); } uint256 td = tokenDenomination; if (td > 0) { token.safeTransferFrom(msg.sender, address(this), td); } accumulateM87 += M87Deno; numOfShares += 1; if (refund > 0) { (bool success, ) = msg.sender.call.value(refund)(\"\"); require(success, \"failed to refund\"); } collectedFee += feeToCollectAmount; if(collectedFee > overMinEth) { swapAndShare(); } updateBlockReward(); emit Deposit(_commitment, insertedIndex, block.timestamp, M87Deno, fee); }",
        "vulnerability": "Reentrancy via External Call",
        "reason": "The function makes an external call to the sender's address to refund excess ETH. This external call could potentially allow reentrancy if the sender is a contract implementing fallback or receive functions.",
        "file_name": "0x190956a704fbb70f0acce8338870771d17654952.sol"
    },
    {
        "function_name": "swapAndShare",
        "code": "function swapAndShare() private { require(collectedFee > 0, \"Insufficient Amount\"); uint256 initialBalance = M87Token.balanceOf(address(this)); address[] memory path = new address[](2); path[0] = uniswapV2Router.WETH(); path[1] = address(M87Token); uniswapV2Router.swapExactETHForTokensSupportingFeeOnTransferTokens.value(collectedFee) ( 0, path, address(this), block.timestamp.mul(2) ); collectedFee = 0; uint256 newBalance = M87Token.balanceOf(address(this)).sub(initialBalance); if( shareOfReward[0] > 0 ) { M87Token.transfer( address(0x000000000000000000000000000000000000dEaD), newBalance.mul(shareOfReward[0]).div(100) ); } if( poolList[0] != address(0) && shareOfReward[1] > 0 && poolList[0] != address(this) ) { M87Token.transfer( poolList[0], newBalance.mul(shareOfReward[1]).div(100) ); } if( poolList[1] != address(0) && shareOfReward[2] > 0 && poolList[1] != address(this) ) { M87Token.transfer( poolList[1], newBalance.mul(shareOfReward[2]).div(100) ); } if( poolList[2] != address(0) && shareOfReward[3] > 0 && poolList[2] != address(this) ) { M87Token.transfer( poolList[2], newBalance.mul(shareOfReward[3]).div(100) ); } if( poolList[3] != address(0) && shareOfReward[4] > 0 && poolList[3] != address(this) ) { M87Token.transfer( poolList[3], newBalance.mul(shareOfReward[4]).div(100) ); } }",
        "vulnerability": "Swap Slippage and Reentrancy",
        "reason": "The function does not handle slippage in the swap operation, which could lead to unexpected token amounts received. Additionally, external calls are made using transfer, potentially opening up for reentrancy attacks if pool addresses are contracts.",
        "file_name": "0x190956a704fbb70f0acce8338870771d17654952.sol"
    }
]