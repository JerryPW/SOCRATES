[
    {
        "function_name": "createSwapIntent",
        "vulnerability": "Missing validation for swap counterparty",
        "criticism": "The reasoning is correct in identifying that the function does not validate the `_swapIntent.addressTwo` input. This could allow a malicious actor to set any address as the counterparty without their consent, potentially leading to unauthorized swaps. The severity is moderate because it could lead to loss of assets if a swap is executed with an unintended counterparty. The profitability is moderate as well, as an attacker could potentially exploit this to redirect swaps to their own address.",
        "correctness": 8,
        "severity": 5,
        "profitability": 5,
        "reason": "The function does not validate the `_swapIntent.addressTwo` input, allowing a malicious actor to set any address as the counterparty without their consent, potentially causing loss of assets.",
        "code": "function createSwapIntent(swapIntent memory _swapIntent, swapStruct[] memory _nftsOne, swapStruct[] memory _nftsTwo) payable public whenNotPaused nonReentrant { if(payment.status) { if(ERC721Interface(TRADESQUAD).balanceOf(msg.sender)==0) { require(msg.value>=payment.value.add(_swapIntent.valueOne), \"Not enought WEI for handle the transaction\"); _swapIntent.swapFee = getWeiPayValueAmount() ; } else { require(msg.value>=_swapIntent.valueOne, \"Not enought WEI for handle the transaction\"); _swapIntent.swapFee = 0 ; } } else require(msg.value>=_swapIntent.valueOne, \"Not enought WEI for handle the transaction\"); _swapIntent.addressOne = payable(msg.sender); _swapIntent.id = _swapIds.current(); checksCreator[_swapIntent.id] = _swapIntent.addressOne ; checksCounterparty[_swapIntent.id] = _swapIntent.addressTwo ; _swapIntent.swapStart = block.timestamp; _swapIntent.swapEnd = 0; _swapIntent.status = swapStatus.Opened ; swapMatch[_swapIds.current()] = swapList[msg.sender].length; swapList[msg.sender].push(_swapIntent); uint256 i; for(i=0; i<_nftsOne.length; i++) nftsOne[_swapIntent.id].push(_nftsOne[i]); for(i=0; i<_nftsTwo.length; i++) nftsTwo[_swapIntent.id].push(_nftsTwo[i]); for(i=0; i<nftsOne[_swapIntent.id].length; i++) { require(whiteList[nftsOne[_swapIntent.id][i].dapp], \"A DAPP is not handled by the system\"); if(nftsOne[_swapIntent.id][i].typeStd == ERC20) { ERC20Interface(nftsOne[_swapIntent.id][i].dapp).transferFrom(_swapIntent.addressOne, address(this), nftsOne[_swapIntent.id][i].blc[0]); } else if(nftsOne[_swapIntent.id][i].typeStd == ERC721) { ERC721Interface(nftsOne[_swapIntent.id][i].dapp).safeTransferFrom(_swapIntent.addressOne, address(this), nftsOne[_swapIntent.id][i].tokenId[0], nftsOne[_swapIntent.id][i].data); } else if(nftsOne[_swapIntent.id][i].typeStd == ERC1155) { ERC1155Interface(nftsOne[_swapIntent.id][i].dapp).safeBatchTransferFrom(_swapIntent.addressOne, address(this), nftsOne[_swapIntent.id][i].tokenId, nftsOne[_swapIntent.id][i].blc, nftsOne[_swapIntent.id][i].data); } else { customInterface(dappRelations[nftsOne[_swapIntent.id][i].dapp]).bridgeSafeTransferFrom(nftsOne[_swapIntent.id][i].dapp, _swapIntent.addressOne, dappRelations[nftsOne[_swapIntent.id][i].dapp], nftsOne[_swapIntent.id][i].tokenId, nftsOne[_swapIntent.id][i].blc, nftsOne[_swapIntent.id][i].data); } } emit swapEvent(msg.sender, (block.timestamp-(block.timestamp%secs)), _swapIntent.status, _swapIntent.id, _swapIntent.addressTwo); _swapIds.increment(); }",
        "file_name": "0x13d8faf4a690f5ae52e2d2c52938d1167057b9af.sol"
    },
    {
        "function_name": "closeSwapIntent",
        "vulnerability": "Lack of fee validation",
        "criticism": "The reasoning correctly identifies that the function does not validate the transaction fees paid by the user. This could allow an attacker to underpay fees, affecting the contract's expected revenue or operational costs. However, the severity is relatively low because the primary impact is on the contract's revenue rather than on the security of the assets being swapped. The profitability is also low, as the attacker would only benefit from reduced fees rather than direct asset gain.",
        "correctness": 8,
        "severity": 3,
        "profitability": 2,
        "reason": "The function assumes that transaction fees paid by the user are correct without validation, allowing manipulation of the `msg.value` sent in. An attacker could potentially underpay fees, affecting the contract's expected revenue or operational costs.",
        "code": "function closeSwapIntent(address _swapCreator, uint256 _swapId) payable public whenNotPaused nonReentrant { require(checksCounterparty[_swapId] == msg.sender, \"You're not the interested counterpart\"); require(swapList[_swapCreator][swapMatch[_swapId]].status == swapStatus.Opened, \"Swap Status is not opened\"); require(swapList[_swapCreator][swapMatch[_swapId]].addressTwo == msg.sender, \"You're not the interested counterpart\"); if(payment.status) { if(ERC721Interface(TRADESQUAD).balanceOf(msg.sender)==0) { require(msg.value>=payment.value.add(swapList[_swapCreator][swapMatch[_swapId]].valueTwo), \"Not enought WEI for handle the transaction\"); if(payment.value.add(swapList[_swapCreator][swapMatch[_swapId]].swapFee) > 0) VAULT.transfer(payment.value.add(swapList[_swapCreator][swapMatch[_swapId]].swapFee)); } else { require(msg.value>=swapList[_swapCreator][swapMatch[_swapId]].valueTwo, \"Not enought WEI for handle the transaction\"); if(swapList[_swapCreator][swapMatch[_swapId]].swapFee>0) VAULT.transfer(swapList[_swapCreator][swapMatch[_swapId]].swapFee); } } else require(msg.value>=swapList[_swapCreator][swapMatch[_swapId]].valueTwo, \"Not enought WEI for handle the transaction\"); swapList[_swapCreator][swapMatch[_swapId]].addressTwo = payable(msg.sender); swapList[_swapCreator][swapMatch[_swapId]].swapEnd = block.timestamp; swapList[_swapCreator][swapMatch[_swapId]].status = swapStatus.Closed; uint256 i; for(i=0; i<nftsOne[_swapId].length; i++) { require(whiteList[nftsOne[_swapId][i].dapp], \"A DAPP is not handled by the system\"); if(nftsOne[_swapId][i].typeStd == ERC20) { ERC20Interface(nftsOne[_swapId][i].dapp).transfer(swapList[_swapCreator][swapMatch[_swapId]].addressTwo, nftsOne[_swapId][i].blc[0]); } else if(nftsOne[_swapId][i].typeStd == ERC721) { ERC721Interface(nftsOne[_swapId][i].dapp).safeTransferFrom(address(this), swapList[_swapCreator][swapMatch[_swapId]].addressTwo, nftsOne[_swapId][i].tokenId[0], nftsOne[_swapId][i].data); } else if(nftsOne[_swapId][i].typeStd == ERC1155) { ERC1155Interface(nftsOne[_swapId][i].dapp).safeBatchTransferFrom(address(this), swapList[_swapCreator][swapMatch[_swapId]].addressTwo, nftsOne[_swapId][i].tokenId, nftsOne[_swapId][i].blc, nftsOne[_swapId][i].data); } else { customInterface(dappRelations[nftsOne[_swapId][i].dapp]).bridgeSafeTransferFrom(nftsOne[_swapId][i].dapp, dappRelations[nftsOne[_swapId][i].dapp], swapList[_swapCreator][swapMatch[_swapId]].addressTwo, nftsOne[_swapId][i].tokenId, nftsOne[_swapId][i].blc, nftsOne[_swapId][i].data); } } if(swapList[_swapCreator][swapMatch[_swapId]].valueOne > 0) swapList[_swapCreator][swapMatch[_swapId]].addressTwo.transfer(swapList[_swapCreator][swapMatch[_swapId]].valueOne); for(i=0; i<nftsTwo[_swapId].length; i++) { require(whiteList[nftsTwo[_swapId][i].dapp], \"A DAPP is not handled by the system\"); if(nftsTwo[_swapId][i].typeStd == ERC20) { ERC20Interface(nftsTwo[_swapId][i].dapp).transferFrom(swapList[_swapCreator][swapMatch[_swapId]].addressTwo, swapList[_swapCreator][swapMatch[_swapId]].addressOne, nftsTwo[_swapId][i].blc[0]); } else if(nftsTwo[_swapId][i].typeStd == ERC721) { ERC721Interface(nftsTwo[_swapId][i].dapp).safeTransferFrom(swapList[_swapCreator][swapMatch[_swapId]].addressTwo, swapList[_swapCreator][swapMatch[_swapId]].addressOne, nftsTwo[_swapId][i].tokenId[0], nftsTwo[_swapId][i].data); } else if(nftsTwo[_swapId][i].typeStd == ERC1155) { ERC1155Interface(nftsTwo[_swapId][i].dapp).safeBatchTransferFrom(swapList[_swapCreator][swapMatch[_swapId]].addressTwo, swapList[_swapCreator][swapMatch[_swapId]].addressOne, nftsTwo[_swapId][i].tokenId, nftsTwo[_swapId][i].blc, nftsTwo[_swapId][i].data); } else { customInterface(dappRelations[nftsTwo[_swapId][i].dapp]).bridgeSafeTransferFrom(nftsTwo[_swapId][i].dapp, swapList[_swapCreator][swapMatch[_swapId]].addressTwo, swapList[_swapCreator][swapMatch[_swapId]].addressOne, nftsTwo[_swapId][i].tokenId, nftsTwo[_swapId][i].blc, nftsTwo[_swapId][i].data); } } if(swapList[_swapCreator][swapMatch[_swapId]].valueTwo>0) swapList[_swapCreator][swapMatch[_swapId]].addressOne.transfer(swapList[_swapCreator][swapMatch[_swapId]].valueTwo); emit swapEvent(msg.sender, (block.timestamp-(block.timestamp%secs)), swapStatus.Closed, _swapId, _swapCreator); }",
        "file_name": "0x13d8faf4a690f5ae52e2d2c52938d1167057b9af.sol"
    },
    {
        "function_name": "editCounterPart",
        "vulnerability": "Arbitrary counterpart change",
        "criticism": "The reasoning is correct in identifying that the function allows the swap creator to change the swap counterpart without restrictions or confirmations. This could lead to loss of funds or assets for the original counterpart if the swap is executed with a new, unauthorized counterparty. The severity is high because it directly affects the integrity of the swap process and could lead to significant asset loss. The profitability is also high, as an attacker could exploit this to redirect swaps to their own address.",
        "correctness": 9,
        "severity": 8,
        "profitability": 7,
        "reason": "The function allows the swap creator to arbitrarily change the swap counterpart without any restrictions or confirmations, potentially leading to loss of funds or assets for the original counterpart.",
        "code": "function editCounterPart(uint256 _swapId, address payable _counterPart) public { require(checksCreator[_swapId] == msg.sender, \"You're not the interested counterpart\"); require(msg.sender == swapList[msg.sender][swapMatch[_swapId]].addressOne, \"Message sender must be the swap creator\"); checksCounterparty[_swapId] = _counterPart; swapList[msg.sender][swapMatch[_swapId]].addressTwo = _counterPart; }",
        "file_name": "0x13d8faf4a690f5ae52e2d2c52938d1167057b9af.sol"
    }
]