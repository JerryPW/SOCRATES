[
    {
        "function_name": "transferFrom",
        "code": "function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) { uint256 burnAddressAmount = amount * burnAddressPer / 1000; uint256 burnBlockAmount = amount * burnBlockPer / 1000; uint256 burnAirDropAmount = amount * burnAirDropPer / 1000; uint256 transferAmount = amount - burnAddressAmount -burnBlockAmount-burnAirDropAmount; super._transfer(sender, recipient, transferAmount); if(burnAddressAmount>0){ super._transfer(sender, burnAddress, burnAddressAmount); } if(burnBlockAmount>0){ super._transfer(sender, blackHole, burnBlockAmount); } if(burnAirDropAmount>0){ super._transfer(sender, airDropAddress, burnAirDropAmount); } uint256 currentAllowance = allowance(sender, msg.sender); require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\"); super._approve(sender, msg.sender, currentAllowance - amount); return true; }",
        "vulnerability": "Incorrect allowance deduction",
        "reason": "The allowance is reduced by the total amount instead of the transferAmount (after deductions for burns and airdrops). This allows the caller to incorrectly reduce the allowance more than necessary, potentially leading to Denial of Service (DoS) by exhausting the sender's allowance.",
        "file_name": "0x0321be5f545ea569424aace4dc08d60f467229ac.sol"
    },
    {
        "function_name": "mintProof",
        "code": "function mintProof(uint256 mintCount,address receiveAds,bytes32[] memory proof) public payable { require(!isContract(msg.sender),\"not supper contract mint\"); require(mintCount > 0, \"Invalid mint count\"); require(mintCount <= _maxMintPerAddress, \"Exceeded maximum mint count per address\"); require(msg.value >= mintCount*_mintPrice, \"illegal price\"); require(_mintCounts[msg.sender]+mintCount <= _maxMintPerAddress, \"over limit\"); receiveAds = msg.sender; if(isZero(wlRoot)){ require(block.timestamp >= mintStartTime, \"Minting has not started yet\"); require(block.timestamp <= mintEndTime, \"Minting has ended\"); }else { if (block.timestamp<wlMintedEndTime){ require(wlMintedCounts+mintCount<=wlMintCounts,\"over limit\"); bytes32 leaf = keccak256(abi.encodePacked(msg.sender)); require(MerkleProof.verify(proof, wlRoot, leaf),\"Not In Wl\"); wlMintedCounts += mintCount; } } if (block.timestamp<wlMintedEndTime){ require(_mintedCounts-wlMintedCounts+mintCount <= (_maxMintCount - wlMintedCounts), \"illegal mintAmount\"); } IWETH(wethAddress).deposit{value: msg.value*(1000-deployReserveEthPro-donateEthPro)/1000}(); IWETH(wethAddress).approve(lpContract, msg.value*(1000-deployReserveEthPro-donateEthPro)/1000); IWETH(wethAddress).transferFrom(address(this), lpContract, msg.value*(1000-deployReserveEthPro-donateEthPro)/1000); uint256 mintAmount = (totalSupply() * _maxPro * mintCount) / (_maxMintCount * 2000000); for (uint256 i = 0; i < contractAuths.length; i++) { if (contractAuths[i].contractType == ContractType.ERC721) { if(validateNftNumber==1){ IERC721Enumerable eRC721Enumerable = IERC721Enumerable(contractAuths[i].contractAddress); uint256 tokenId = eRC721Enumerable.tokenOfOwnerByIndex(msg.sender, 0); require(!tokenExists[tokenId],\"had used!\"); tokenExists[tokenId] = true; } uint256 tokenCount = getERC721TokenCount(contractAuths[i].contractAddress); require(tokenCount >= contractAuths[i].tokenCount, \"Insufficient ERC721 tokens\"); } else if (contractAuths[i].contractType == ContractType.ERC20) { uint256 tokenCount = getERC20TokenCount(contractAuths[i].contractAddress); require(tokenCount >= contractAuths[i].tokenCount, \"Insufficient ERC20 tokens\"); } else if (contractAuths[i].contractType == ContractType.ERC1155) { uint256 tokenCount = getERC1155TokenCount(contractAuths[i].contractAddress, 0); require(tokenCount >= contractAuths[i].tokenCount, \"Insufficient ERC1155 tokens\"); } } _transfer(address(this), receiveAds, mintAmount); _transfer(address(this), lpContract, mintAmount); IUniswapV2Pair(lpContract).sync(); _mintCounts[msg.sender] += mintCount; _mintedCounts += mintCount; }",
        "vulnerability": "Minting to default address",
        "reason": "The function forces the receiveAds address to be msg.sender, which can cause unexpected behavior if the caller intended to mint tokens to a different address. This limits the flexibility of the function and may lead to misuse or user errors.",
        "file_name": "0x0321be5f545ea569424aace4dc08d60f467229ac.sol"
    },
    {
        "function_name": "deployAwardToken",
        "code": "function deployAwardToken() external { require(_mintedCounts==_maxMintCount,\"waiting mint finish\"); require(msg.sender==_deplyAddress,\"not deplyer\"); require(totalTokensClaimed <= totalTokensLocked, \"All tokens have been claimed.\"); uint256 currentTimestamp = block.timestamp; uint256 lockEndTime = deployTime + (tokenLockDays * 86400); uint256 unlockTimes = (lockEndTime - currentTimestamp) / ((tokenLockDays / tokenUnlockCounts) * 86400) - hadTokenUnlockCounts; uint256 claimableTokens; IERC20 token2 = IERC20(address(this)); if (unlockTimes >= tokenUnlockCounts) { claimableTokens = token2.balanceOf(address(this)); hadTokenUnlockCounts = tokenUnlockCounts; } else { require(unlockTimes>0,\"not have unlock times!\"); claimableTokens = unlockTimes * (totalTokensLocked/tokenUnlockCounts); hadTokenUnlockCounts += unlockTimes; } token2.transfer(msg.sender, claimableTokens); }",
        "vulnerability": "Token lock period calculation error",
        "reason": "The calculation of unlockTimes can result in a negative number due to integer division and subtraction, leading to an incorrect computation of claimableTokens. This can potentially allow premature withdrawal of tokens if exploiters manipulate the timing of function calls.",
        "file_name": "0x0321be5f545ea569424aace4dc08d60f467229ac.sol"
    }
]