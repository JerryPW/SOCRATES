[
    {
        "function_name": "processActionProposal",
        "code": "function processActionProposal(uint256 proposalIndex) external nonReentrant returns (bool, bytes memory) { _validateProposalForProcessing(proposalIndex); uint256 proposalId = proposalQueue[proposalIndex]; bytes storage action = actions[proposalId]; Proposal storage proposal = proposals[proposalId]; require(proposal.flags[6] == 1, \"!action\"); proposal.flags[1] = 1; bool didPass = _didPass(proposalIndex); if (tokenWhitelist[proposal.applicant] && proposal.paymentRequested > userTokenBalances[GUILD][proposal.applicant]) { didPass = false; } if (proposal.tributeOffered > address(this).balance) { didPass = false; } if (didPass) { proposal.flags[2] = 1; (bool success, bytes memory returnData) = proposal.applicant.call{value: proposal.tributeOffered}(action); if (tokenWhitelist[proposal.applicant]) { unsafeSubtractFromBalance(GUILD, proposal.applicant, proposal.paymentRequested); if (userTokenBalances[GUILD][proposal.applicant] == 0 && proposal.paymentRequested > 0) {totalGuildBankTokens -= 1;} } return (success, returnData); } _returnDeposit(proposal.sponsor); emit ProcessActionProposal(proposalIndex, proposalId, didPass); }",
        "vulnerability": "Reentrancy vulnerability",
        "reason": "The processActionProposal function allows an external call using .call with potential reentrancy. If an untrusted contract is called, it could re-enter this contract and execute functions before state changes are finalized.",
        "file_name": "0x01b92e2c0d06325089c6fd53c98a214f5c75b2ac.sol"
    },
    {
        "function_name": "submitProposal",
        "code": "function submitProposal( address applicant, uint256 sharesRequested, uint256 lootRequested, uint256 tributeOffered, address tributeToken, uint256 paymentRequested, address paymentToken, bytes32 details ) external nonReentrant payable returns (uint256 proposalId) { require(sharesRequested.add(lootRequested) <= MAX_GUILD_BOUND, \"guild maxed\"); require(tokenWhitelist[tributeToken], \"tributeToken != whitelist\"); require(tokenWhitelist[paymentToken], \"paymentToken != whitelist\"); require(applicant != GUILD && applicant != ESCROW && applicant != TOTAL, \"applicant unreservable\"); require(members[applicant].jailed == 0, \"applicant jailed\"); if (tributeOffered > 0 && userTokenBalances[GUILD][tributeToken] == 0) { require(totalGuildBankTokens < MAX_TOKEN_GUILDBANK_COUNT, \"guildbank maxed\"); } if (msg.value > 0) { require(tributeToken == wETH && msg.value == tributeOffered, \"!ethBalance\"); (bool success, ) = wETH.call{value: msg.value}(\"\"); require(success, \"!ethCall\"); IERC20(wETH).safeTransfer(address(this), msg.value); } else { IERC20(tributeToken).safeTransferFrom(msg.sender, address(this), tributeOffered); } unsafeAddToBalance(ESCROW, tributeToken, tributeOffered); uint8[8] memory flags; flags[7] = 1; _submitProposal(applicant, sharesRequested, lootRequested, tributeOffered, tributeToken, paymentRequested, paymentToken, details, flags, \"\"); return proposalCount - 1; }",
        "vulnerability": "Improper ETH handling",
        "reason": "The submitProposal function sends ETH to the wETH contract using a low-level call without checking if the call was successful beyond the return value, which could result in a loss of funds if the call fails or reverts for some reason.",
        "file_name": "0x01b92e2c0d06325089c6fd53c98a214f5c75b2ac.sol"
    },
    {
        "function_name": "updateDelegateKey",
        "code": "function updateDelegateKey(address newDelegateKey) external nonReentrant { require(members[msg.sender].shares > 0, \"!shareholder\"); require(newDelegateKey != address(0), \"newDelegateKey = 0\"); if (newDelegateKey != msg.sender) { require(members[newDelegateKey].exists == 0, \"!overwrite members\"); require(members[memberAddressByDelegateKey[newDelegateKey]].exists == 0, \"!overwrite keys\"); } Member storage member = members[msg.sender]; memberAddressByDelegateKey[member.delegateKey] = address(0); memberAddressByDelegateKey[newDelegateKey] = msg.sender; member.delegateKey = newDelegateKey; emit UpdateDelegateKey(msg.sender, newDelegateKey); }",
        "vulnerability": "Delegate key overwrite",
        "reason": "The updateDelegateKey function does not adequately prevent assigning a delegate key that could collide with an existing member's delegate key due to the lack of checks on the memberAddressByDelegateKey mapping, which could allow unauthorized access.",
        "file_name": "0x01b92e2c0d06325089c6fd53c98a214f5c75b2ac.sol"
    }
]