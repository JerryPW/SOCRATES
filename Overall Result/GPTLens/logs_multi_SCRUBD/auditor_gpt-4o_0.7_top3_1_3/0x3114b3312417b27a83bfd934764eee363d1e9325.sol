[
    {
        "function_name": "rollDice",
        "code": "function rollDice(uint[] memory betNumbers) public payable returns (bool success) {\n    bytes32 oraclizeQueryId;\n    address payable player = msg.sender;\n    uint betAmount = msg.value;\n    require(betAmount >= minimumBet);\n    require(betNumbers.length >= 1);\n    emit PlayerBetAccepted(address(this), player, betNumbers, betAmount);\n    emit RollDice(address(this), player, \"Query to random.org was sent, standing by for the answer.\");\n    if(betNumbers.length < 6) {\n        oraclizeQueryId = oraclize_query(\"URL\", \"https: //random.org\");\n        oraclizeStructs[oraclizeQueryId].status = false;\n        oraclizeStructs[oraclizeQueryId].queryId = oraclizeQueryId;\n        oraclizeStructs[oraclizeQueryId].player = player;\n        oraclizeStructs[oraclizeQueryId].betNumbers = betNumbers;\n        oraclizeStructs[oraclizeQueryId].betAmount = betAmount;\n        oraclizedIndices.push(oraclizeQueryId) -1;\n        emit NumberGeneratorQuery(address(this), player, oraclizeQueryId);\n    } else {\n        msg.sender.transfer(msg.value);\n    }\n    emit AwaitingRandomOrgCallback(address(this), oraclizeQueryId);\n    return true;\n}",
        "vulnerability": "Missing URL parameter in oraclize_query",
        "reason": "The function attempts to call `oraclize_query` with a URL that is commented out (`https: //random.org`), making it non-functional. This means the query will not be formed correctly, potentially leading to unexpected behavior or failed transactions.",
        "file_name": "0x3114b3312417b27a83bfd934764eee363d1e9325.sol"
    },
    {
        "function_name": "payRoyalty",
        "code": "function payRoyalty() public payable returns (bool success) {\n    uint royalty = address(this).balance/2;\n    address payable trustedParty1 = 0xcdAD2D448583C1d9084F54c0d207b3eBE0398490;\n    address payable trustedParty2 = 0x7d75fa60af97284b0c4db3f5EE2AC2D3569576b1;\n    trustedParty1.transfer(royalty/2);\n    trustedParty2.transfer(royalty/2);\n    return (true);\n}",
        "vulnerability": "Hardcoded addresses",
        "reason": "The function uses hardcoded addresses for `trustedParty1` and `trustedParty2`. If these addresses are incorrect or change, funds could be sent to unintended recipients. This could potentially lead to loss of funds.",
        "file_name": "0x3114b3312417b27a83bfd934764eee363d1e9325.sol"
    },
    {
        "function_name": "oraclize_newRandomDSQuery",
        "code": "function oraclize_newRandomDSQuery(uint _delay, uint _nbytes, uint _customGasLimit) internal returns (bytes32 _queryId) {\n    require((_nbytes > 0) && (_nbytes <= 32));\n    _delay *= 10;\n    bytes memory nbytes = new bytes(1);\n    nbytes[0] = byte(uint8(_nbytes));\n    bytes memory unonce = new bytes(32);\n    bytes memory sessionKeyHash = new bytes(32);\n    bytes32 sessionKeyHash_bytes32 = oraclize_randomDS_getSessionPubKeyHash();\n    assembly {\n        mstore(unonce, 0x20)\n        mstore(add(unonce, 0x20), xor(blockhash(sub(number, 1)), xor(coinbase, timestamp)))\n        mstore(sessionKeyHash, 0x20)\n        mstore(add(sessionKeyHash, 0x20), sessionKeyHash_bytes32)\n    }\n    bytes memory delay = new bytes(32);\n    assembly {\n        mstore(add(delay, 0x20), _delay)\n    }\n    bytes memory delay_bytes8 = new bytes(8);\n    copyBytes(delay, 24, 8, delay_bytes8, 0);\n    bytes[4] memory args = [unonce, nbytes, sessionKeyHash, delay];\n    bytes32 queryId = oraclize_query(\"random\", args, _customGasLimit);\n    bytes memory delay_bytes8_left = new bytes(8);\n    assembly {\n        let x := mload(add(delay_bytes8, 0x20))\n        mstore8(add(delay_bytes8_left, 0x27), div(x, 0x100000000000000000000000000000000000000000000000000000000000000))\n        mstore8(add(delay_bytes8_left, 0x26), div(x, 0x1000000000000000000000000000000000000000000000000000000000000))\n        mstore8(add(delay_bytes8_left, 0x25), div(x, 0x10000000000000000000000000000000000000000000000000000000000))\n        mstore8(add(delay_bytes8_left, 0x24), div(x, 0x100000000000000000000000000000000000000000000000000000000))\n        mstore8(add(delay_bytes8_left, 0x23), div(x, 0x1000000000000000000000000000000000000000000000000000000))\n        mstore8(add(delay_bytes8_left, 0x22), div(x, 0x10000000000000000000000000000000000000000000000000000))\n        mstore8(add(delay_bytes8_left, 0x21), div(x, 0x100000000000000000000000000000000000000000000000000))\n        mstore8(add(delay_bytes8_left, 0x20), div(x, 0x1000000000000000000000000000000000000000000000000))\n    }\n    oraclize_randomDS_setCommitment(queryId, keccak256(abi.encodePacked(delay_bytes8_left, args[1], sha256(args[0]), args[2])));\n    return queryId;\n}",
        "vulnerability": "Use of blockhash and coinbase for randomness",
        "reason": "The function `oraclize_newRandomDSQuery` uses `blockhash` and `coinbase` to generate randomness. These are predictable and manipulatable by miners, which makes the randomness potentially insecure and exploitable. This could allow attackers to predict or influence the outcome of random generation.",
        "file_name": "0x3114b3312417b27a83bfd934764eee363d1e9325.sol"
    }
]