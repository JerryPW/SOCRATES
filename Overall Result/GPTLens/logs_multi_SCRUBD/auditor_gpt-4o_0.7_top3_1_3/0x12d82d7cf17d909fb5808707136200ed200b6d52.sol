[
    {
        "function_name": "removeOrder",
        "code": "function removeOrder(uint256 indexOfOrder) public { if (indexOfOrder >= _userActions.length) return; require(_userActions[indexOfOrder].user == msg.sender || msg.sender == owner() || msg.sender == address(this)); if(msg.sender != address(this)){ _userActions[indexOfOrder].user.call{value: _transactionFee}(\"\"); } for (uint i = indexOfOrder; i<_userActions.length-1; i++){ _userActions[i] = _userActions[i+1]; } _userActions.pop(); }",
        "vulnerability": "Reentrancy vulnerability",
        "reason": "The function allows external calls to an arbitrary address before state changes, which could be exploited for reentrancy attacks. Specifically, the call to `_userActions[indexOfOrder].user.call` could trigger a reentrant call to `removeOrder`, leading to unexpected behavior.",
        "file_name": "0x12d82d7cf17d909fb5808707136200ed200b6d52.sol"
    },
    {
        "function_name": "processUserTransactions",
        "code": "function processUserTransactions(uint256 amountToProcess, swapInfoEntry[] memory swapInfo) public onlyOwner{ require(swapInfo.length == _tokensHeld.length); uint256 totalPoolValue = getContractTotalBalance(swapInfo); userInteractionInfo[] memory userActionsSnapshot = _userActions; processInfoStruct memory processingInfo = processInfoStruct(0,0,0,0,0); for (uint i = 0; i < amountToProcess; i++){ if(userActionsSnapshot[i].deposit == true){ if(userActionsSnapshot[i].deadline >= block.timestamp && IERC20(WETHAddress).allowance(userActionsSnapshot[i].user, address(this)) >= userActionsSnapshot[i].amount && IERC20(WETHAddress).balanceOf(userActionsSnapshot[i].user) >= userActionsSnapshot[i].amount ){ IERC20(WETHAddress).transferFrom(userActionsSnapshot[i].user, address(this), userActionsSnapshot[i].amount); processingInfo.platformFeeAmount += (userActionsSnapshot[i].amount * _factoryFee / 10**18); processingInfo.ownerFeeAmount += userActionsSnapshot[i].amount * _poolFee / 10**18; userActionsSnapshot[i].amount = userActionsSnapshot[i].amount - (userActionsSnapshot[i].amount * _poolFee / 10**18) - (userActionsSnapshot[i].amount * _factoryFee / 10**18); processingInfo.valueDeposited += userActionsSnapshot[i].amount; if(balanceOf(userActionsSnapshot[i].user) == 0){ _totalHolders++; } } else { userActionsSnapshot[i].amount = 0; } } else { if(userActionsSnapshot[i].deadline >= block.timestamp && allowance(userActionsSnapshot[i].user, address(this)) >= userActionsSnapshot[i].amount && balanceOf(userActionsSnapshot[i].user) >= userActionsSnapshot[i].amount){ ERC20Burnable(address(this)).burnFrom(userActionsSnapshot[i].user, userActionsSnapshot[i].amount); processingInfo.tokensWithdrawn += userActionsSnapshot[i].amount; processingInfo.withdrawals++; if(balanceOf(userActionsSnapshot[i].user) == 0){ _totalHolders--; } } else { userActionsSnapshot[i].amount = 0; } } removeOrder(0); } if(processingInfo.valueDeposited > 0){ uint256 valueIncreasePercentage = 0; uint256 amountToMint; uint256 tokensProcessed = 0; if(_tokensHeld.length > 0 && totalSupply() > 0){ for (uint i = 0; i < _tokensHeld.length; i++){ require(swapInfo[i].token == _tokensHeld[i]); uint256 value; if(swapInfo[i].pathToWETHV2.length != 0){ value = InvestmentLibrary.getQuoteV2(swapInfo[i].pathToWETHV2, IERC20(_tokensHeld[i]).balanceOf(address(this)) * 10**(18 - IERC20Metadata(_tokensHeld[i]).decimals())); } else { value = InvestmentLibrary.getQuoteV3(swapInfo[i].pathToWETHV3, IERC20(_tokensHeld[i]).balanceOf(address(this)) * 10**(18 - IERC20Metadata(_tokensHeld[i]).decimals())); } uint256 amountRecieved = _swapTokens(swapInfo[i].pathFromWETHV2, swapInfo[i].pathFromWETHV3, processingInfo.valueDeposited * (value * 10**18 / totalPoolValue) / 10**18, swapInfo[i].fromWETHMinimumAmountOut); valueIncreasePercentage += amountRecieved * 10**18 / (IERC20(_tokensHeld[i]).balanceOf(address(this)) - amountRecieved); tokensProcessed++; } amountToMint = (totalSupply() + processingInfo.tokensWithdrawn) * (valueIncreasePercentage / tokensProcessed) / 10**18; } else if(totalPoolValue > 0 && totalSupply() > 0) { amountToMint = (totalSupply() + processingInfo.tokensWithdrawn) * ((IERC20(WETHAddress).balanceOf(address(this)) - totalPoolValue - processingInfo.ownerFeeAmount - processingInfo.platformFeeAmount) * 10**18 / totalPoolValue) / 10**18; } else { amountToMint = processingInfo.valueDeposited * 100; } for (uint i = 0; i < amountToProcess; i++){ if(userActionsSnapshot[i].deposit == true && userActionsSnapshot[i].amount != 0){ _mint(userActionsSnapshot[i].user, amountToMint * (userActionsSnapshot[i].amount * 10**18 / processingInfo.valueDeposited) / 10**18); } } } if(processingInfo.tokensWithdrawn > 0){ uint256 WETHRecieved = (processingInfo.tokensWithdrawn * 10**18 / (totalSupply() + processingInfo.tokensWithdrawn)) * IERC20(WETHAddress).balanceOf(address(this)) / 10**18; address[] memory tokensHeldSnapshot = _tokensHeld; if(tokensHeldSnapshot.length > 0){ for (uint i = 0; i < tokensHeldSnapshot.length; i++){ require(swapInfo[i].token == tokensHeldSnapshot[i]); WETHRecieved += _swapTokens(swapInfo[i].pathToWETHV2, swapInfo[i].pathToWETHV3, IERC20(tokensHeldSnapshot[i]).balanceOf(address(this)) * (processingInfo.tokensWithdrawn * 10**18 / (totalSupply() + processingInfo.tokensWithdrawn)) / 10**18, swapInfo[i].toWETHMinimumAmountOut); } } processingInfo.platformFeeAmount += (WETHRecieved * _factoryFee / 10**18); processingInfo.ownerFeeAmount += WETHRecieved * _poolFee / 10**18; WETHRecieved = WETHRecieved - (WETHRecieved * _poolFee / 10**18) - (WETHRecieved * _factoryFee / 10**18); IWETH(WETHAddress).withdraw(WETHRecieved); for (uint i = 0; i < amountToProcess; i++){ if(userActionsSnapshot[i].deposit == false && userActionsSnapshot[i].amount != 0){ userActionsSnapshot[i].user.call{value: WETHRecieved * (userActionsSnapshot[i].amount * 10**18 / processingInfo.tokensWithdrawn) / 10**18}(\"\"); } } } IWETH WETHContract = IWETH(WETHAddress); WETHContract.withdraw(processingInfo.ownerFeeAmount); owner().call{value: address(this).balance}(\"\"); processFee(processingInfo.platformFeeAmount); emit transactionsProcessed(processingInfo); }",
        "vulnerability": "Improper validation of user input",
        "reason": "The function does not properly validate user inputs such as deadline and allowance. This can lead to processing transactions that should not be allowed, such as expired transactions or transactions with insufficient allowance, which could disrupt the pool's balance and result in incorrect minting or withdrawal amounts.",
        "file_name": "0x12d82d7cf17d909fb5808707136200ed200b6d52.sol"
    },
    {
        "function_name": "submitOrder",
        "code": "function submitOrder(uint256 amount, uint256 deadline, bool deposit) public payable{ if(deposit){ require(msg.value > _transactionFee); require(acceptingNewDeposits == true); IWETH WETHContract = IWETH(WETHAddress); WETHContract.deposit{value: msg.value - _transactionFee}(); IERC20(WETHAddress).transfer(msg.sender, msg.value - _transactionFee); } else { require(amount <= balanceOf(msg.sender)); require(msg.value == _transactionFee); } _userActions.push(userInteractionInfo(msg.sender, deposit ? msg.value - _transactionFee : amount, deposit, deadline)); }",
        "vulnerability": "Incorrect use of ether in deposit logic",
        "reason": "The function subtracts the transaction fee from the `msg.value` and incorrectly transfers the remainder back to the sender as WETH, which may not align with the user's intent. This can cause confusion and potential loss of funds if the user expected the entire `msg.value` to be deposited or managed differently.",
        "file_name": "0x12d82d7cf17d909fb5808707136200ed200b6d52.sol"
    }
]