[
    {
        "function_name": "function()",
        "code": "function() payable { if(now > 1519084800) price = 0.0105 * 1 ether; else if(now > 1516406400) price = 0.0070 * 1 ether; tokenFree = sharesTokenAddress.balanceOf(this); if (now < startICO) { msg.sender.transfer(msg.value); } else if (now > stopICO) { msg.sender.transfer(msg.value); if(!tokenWithdraw){ sharesTokenAddress.transfer(safeContract, sharesTokenAddress.balanceOf(this)); tokenFree = sharesTokenAddress.balanceOf(this); tokenWithdraw = true; crowdsaleClosed = true; } } else if (crowdsaleClosed) { msg.sender.transfer(msg.value); } else { uint256 tokenToBuy = msg.value / price * coeff; if(tokenToBuy <= 0) msg.sender.transfer(msg.value); require(tokenToBuy > 0); uint256 actualETHTransfer = tokenToBuy * price / coeff; if (tokenFree >= tokenToBuy) { owner.transfer(actualETHTransfer); if (msg.value > actualETHTransfer){ msg.sender.transfer(msg.value - actualETHTransfer); } sharesTokenAddress.transfer(msg.sender, tokenToBuy); tokenSold += tokenToBuy; tokenFree -= tokenToBuy; if(tokenFree==0) crowdsaleClosed = true; } else { uint256 sendETH = tokenFree * price / coeff; owner.transfer(sendETH); sharesTokenAddress.transfer(msg.sender, tokenFree); msg.sender.transfer(msg.value - sendETH); tokenSold += tokenFree; tokenFree = sharesTokenAddress.balanceOf(this); crowdsaleClosed = true; } } TokenFree(tokenFree); CrowdsaleClosed(crowdsaleClosed); }",
        "vulnerability": "Reentrancy Attack",
        "reason": "The fallback function includes multiple external calls (e.g., msg.sender.transfer and owner.transfer) without using any mutex or reentrancy guard. An attacker can exploit this by re-entering the function during a transfer, causing inconsistent state updates and potentially draining funds.",
        "file_name": "0xe7e0bb725a6c1ed81b89042b1d37756b21db4958.sol"
    },
    {
        "function_name": "function()",
        "code": "function() payable { if(now > 1519084800) price = 0.0105 * 1 ether; else if(now > 1516406400) price = 0.0070 * 1 ether; tokenFree = sharesTokenAddress.balanceOf(this); if (now < startICO) { msg.sender.transfer(msg.value); } else if (now > stopICO) { msg.sender.transfer(msg.value); if(!tokenWithdraw){ sharesTokenAddress.transfer(safeContract, sharesTokenAddress.balanceOf(this)); tokenFree = sharesTokenAddress.balanceOf(this); tokenWithdraw = true; crowdsaleClosed = true; } } else if (crowdsaleClosed) { msg.sender.transfer(msg.value); } else { uint256 tokenToBuy = msg.value / price * coeff; if(tokenToBuy <= 0) msg.sender.transfer(msg.value); require(tokenToBuy > 0); uint256 actualETHTransfer = tokenToBuy * price / coeff; if (tokenFree >= tokenToBuy) { owner.transfer(actualETHTransfer); if (msg.value > actualETHTransfer){ msg.sender.transfer(msg.value - actualETHTransfer); } sharesTokenAddress.transfer(msg.sender, tokenToBuy); tokenSold += tokenToBuy; tokenFree -= tokenToBuy; if(tokenFree==0) crowdsaleClosed = true; } else { uint256 sendETH = tokenFree * price / coeff; owner.transfer(sendETH); sharesTokenAddress.transfer(msg.sender, tokenFree); msg.sender.transfer(msg.value - sendETH); tokenSold += tokenFree; tokenFree = sharesTokenAddress.balanceOf(this); crowdsaleClosed = true; } } TokenFree(tokenFree); CrowdsaleClosed(crowdsaleClosed); }",
        "vulnerability": "Incorrect Ether Handling",
        "reason": "The fallback function does not correctly handle Ether refunds during the crowdsale. If msg.sender.transfer(msg.value - actualETHTransfer) fails, it may lead to loss of Ether for contributors. Additionally, the lack of checks on transfer success may cause the contract to behave unexpectedly.",
        "file_name": "0xe7e0bb725a6c1ed81b89042b1d37756b21db4958.sol"
    },
    {
        "function_name": "function()",
        "code": "function() payable { if(now > 1519084800) price = 0.0105 * 1 ether; else if(now > 1516406400) price = 0.0070 * 1 ether; tokenFree = sharesTokenAddress.balanceOf(this); if (now < startICO) { msg.sender.transfer(msg.value); } else if (now > stopICO) { msg.sender.transfer(msg.value); if(!tokenWithdraw){ sharesTokenAddress.transfer(safeContract, sharesTokenAddress.balanceOf(this)); tokenFree = sharesTokenAddress.balanceOf(this); tokenWithdraw = true; crowdsaleClosed = true; } } else if (crowdsaleClosed) { msg.sender.transfer(msg.value); } else { uint256 tokenToBuy = msg.value / price * coeff; if(tokenToBuy <= 0) msg.sender.transfer(msg.value); require(tokenToBuy > 0); uint256 actualETHTransfer = tokenToBuy * price / coeff; if (tokenFree >= tokenToBuy) { owner.transfer(actualETHTransfer); if (msg.value > actualETHTransfer){ msg.sender.transfer(msg.value - actualETHTransfer); } sharesTokenAddress.transfer(msg.sender, tokenToBuy); tokenSold += tokenToBuy; tokenFree -= tokenToBuy; if(tokenFree==0) crowdsaleClosed = true; } else { uint256 sendETH = tokenFree * price / coeff; owner.transfer(sendETH); sharesTokenAddress.transfer(msg.sender, tokenFree); msg.sender.transfer(msg.value - sendETH); tokenSold += tokenFree; tokenFree = sharesTokenAddress.balanceOf(this); crowdsaleClosed = true; } } TokenFree(tokenFree); CrowdsaleClosed(crowdsaleClosed); }",
        "vulnerability": "Timestamp Dependence",
        "reason": "The contract relies on block timestamps (now) to control the ICO phases and price changes, making it vulnerable to miner manipulation. Miners can adjust timestamps within a certain range to benefit specific transactions, potentially manipulating ICO timing and pricing.",
        "file_name": "0xe7e0bb725a6c1ed81b89042b1d37756b21db4958.sol"
    }
]