[
    {
        "function_name": "removeFromPool",
        "code": "function removeFromPool(uint256 amountToRemove, InvestmentLibrary.exitSwapParams[] memory exitSwapParams) public { require(balanceOf(msg.sender) > 0, \"You need to have pool tokens if you want to burn them!\"); require(amountToRemove > 0, \"You can't remove 0 of your tokens!\"); require(amountToRemove <= balanceOf(msg.sender), \"You can only remove 100% of your share!\"); require(exitSwapParams.length == _tokensHeld.length, \"Not enough params!\"); _burn(msg.sender, amountToRemove); if(balanceOf(msg.sender) == 0){ _totalHolders--; } uint256 userShare = amountToRemove * 10**18 / (totalSupply() + amountToRemove); uint256 wethPayout = IERC20(WETHAddress).balanceOf(address(this)) * userShare / 10**18; InvestmentLibrary.heldToken[] memory tokensHeldSnapshot = _tokensHeld; for (uint i = 0; i < tokensHeldSnapshot.length; i++){ IERC20 tokenContract = IERC20(tokensHeldSnapshot[i].tokenAddress); if(tokensHeldSnapshot[i].tokenAddress != WETHAddress){ if(exitSwapParams[i].fee == 0){ bytes memory emptyBytes; address[] memory path = new address[](2); path[0] = tokensHeldSnapshot[i].tokenAddress; path[1] = WETHAddress; uint256 wethRecieved = _swapTokens( path, emptyBytes, tokenContract.balanceOf(address(this)) * userShare / 10**18, exitSwapParams[i].minimumOut, address(0) ); wethPayout += wethRecieved; } else { address[] memory path; uint256 wethRecieved = _swapTokens( path, abi.encode(tokensHeldSnapshot[i].tokenAddress, exitSwapParams[i].fee, WETHAddress), tokenContract.balanceOf(address(this)) * userShare / 10**18, exitSwapParams[i].minimumOut, address(0) ); wethPayout += wethRecieved; } } } uint256 poolOwnerFeeAmount = wethPayout * _poolFee / 10**18; uint256 factoryFeeAmount = wethPayout * _factoryFee / 10**18; uint256 amountToPayToUser = wethPayout - factoryFeeAmount - poolOwnerFeeAmount; IWETH WETHContract = IWETH(WETHAddress); IERC20(WETHAddress).transfer(owner(), poolOwnerFeeAmount); processFee(WETHAddress, factoryFeeAmount, 0); WETHContract.withdraw(amountToPayToUser); msg.sender.call{value: amountToPayToUser}(\"\"); if(InvestmentLibrary.isTokenHeld(_tokensHeld, WETHAddress) == true && IERC20(WETHAddress).balanceOf(address(this)) == 0){ _removeAddressFromTokensHeld(WETHAddress); } emit InvestmentLibrary.feePaidToOwner(msg.sender, owner(), poolOwnerFeeAmount); emit InvestmentLibrary.poolRemovedFrom(msg.sender, amountToRemove, amountToPayToUser); }",
        "vulnerability": "Reentrancy",
        "reason": "The function sends Ether to the user using a low-level call without reentrancy protection, which can lead to reentrancy attacks where an attacker could recursively call removeFromPool to drain the contract.",
        "file_name": "0x38721079a72030ab1817fb9e1aaa86ae0d08356f.sol"
    },
    {
        "function_name": "_swapTokens",
        "code": "function _swapTokens(address[] memory v2Path, bytes memory v3Path, uint256 amountIn, uint256 amountOutMinimum, address quoteToken) internal returns (uint256) { _adjustTokensHeld(v2Path, v3Path, amountIn, quoteToken); if(v2Path.length != 0){ uint256 balanceOfTokenBeforeSwap = IERC20(v2Path[v2Path.length - 1]).balanceOf(address(this)); IERC20(v2Path[0]).approve(address(uniswapV2Router), amountIn); uniswapV2Router.swapExactTokensForTokensSupportingFeeOnTransferTokens( amountIn, amountOutMinimum, v2Path, address(this), block.timestamp ); return IERC20(v2Path[v2Path.length - 1]).balanceOf(address(this)) - balanceOfTokenBeforeSwap; } else { bytes memory formattedBytes; if(v3Path.length == 96){ (address decodedTokenIn, uint24 swapFee, address decodedTokenOut) = abi.decode(v3Path, (address, uint24, address)); formattedBytes = abi.encodePacked(decodedTokenIn, swapFee, decodedTokenOut); IERC20(decodedTokenIn).approve(address(swapRouter), amountIn); } else { (address decodedTokenIn, uint24 fee1, address middleToken, uint24 fee2, address decodedTokenOut) = abi.decode(v3Path, (address, uint24, address, uint24, address)); formattedBytes = abi.encodePacked(decodedTokenIn, fee1, middleToken, fee2, decodedTokenOut); IERC20(decodedTokenIn).approve(address(swapRouter), amountIn); } ISwapRouter.ExactInputParams memory params = ISwapRouter.ExactInputParams( formattedBytes, address(this), block.timestamp, amountIn, amountOutMinimum ); return swapRouter.exactInput(params); } }",
        "vulnerability": "Approval Front-running",
        "reason": "The function approves the maximum token amount to the Uniswap router without resetting to zero first, which could be exploited by a front-running attack to swap more tokens than intended.",
        "file_name": "0x38721079a72030ab1817fb9e1aaa86ae0d08356f.sol"
    },
    {
        "function_name": "addToPool",
        "code": "function addToPool(uint256[] memory minimumAmountsOut) public payable { require(msg.value > 0); if(totalSupply() == 0){ require(msg.value >= 10000000000000000 , \"You must initiate the pool with at least 0.01 ETH!\"); } uint256 factoryFeeAmount = msg.value * _factoryFee / 10**18; uint256 poolOwnerFeeAmount = msg.value * _poolFee / 10**18; uint256 amountIn = msg.value - factoryFeeAmount - poolOwnerFeeAmount; IWETH WETHContract = IWETH(WETHAddress); WETHContract.deposit{value: msg.value}(); IERC20(WETHAddress).transfer(owner(), poolOwnerFeeAmount); processFee(WETHAddress, factoryFeeAmount, 0); uint256 poolTokensToMint = InvestmentLibrary.getPoolTokensToMint( amountIn, _tokensHeld, totalSupply() ); if(_tokensToSwapIntoOnDeposit.length != 0){ for (uint i = 0; i < _tokensToSwapIntoOnDeposit.length; i++){ InvestmentLibrary.autoSwapToken memory autoSwapParams = _tokensToSwapIntoOnDeposit[i]; _swapTokens( autoSwapParams.v2Path, autoSwapParams.v3Path, amountIn * autoSwapParams.ratio / 10**18, minimumAmountsOut[i], autoSwapParams.quoteToken ); } } if(balanceOf(msg.sender) == 0){ _totalHolders++; } _mint(msg.sender, poolTokensToMint); if(InvestmentLibrary.isTokenHeld(_tokensHeld, WETHAddress) == false && IERC20(WETHAddress).balanceOf(address(this)) > 0){ _tokensHeld.push(InvestmentLibrary.heldToken(WETHAddress, address(0), false)); } emit InvestmentLibrary.feePaidToOwner(msg.sender, owner(), poolOwnerFeeAmount); emit InvestmentLibrary.poolAddedTo(msg.sender, msg.value, poolTokensToMint); }",
        "vulnerability": "Incorrect Ether Value Handling",
        "reason": "The function uses msg.value to calculate fees and amounts without verifying if the sender has sent enough Ether, potentially leading to unexpected behavior if msg.value is less than expected due to rounding issues or other errors.",
        "file_name": "0x38721079a72030ab1817fb9e1aaa86ae0d08356f.sol"
    }
]