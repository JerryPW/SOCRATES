[
    {
        "function_name": "swapAndLiquify",
        "code": "function swapAndLiquify(uint256 tokens) private { uint256 marketFeeFull = tokens.mul(marketFee).div(100); uint256 tokensAfterFee = tokens - marketFeeFull; uint256 initHalf = tokens.div(2); uint256 half = tokensAfterFee.div(2); uint256 otherHalf = tokensAfterFee.sub(half); uint256 initialBalance = address(this).balance; swapTokensForEth(initHalf); uint256 newBalance = address(this).balance.sub(initialBalance); uint256 marketFeeBalance = newBalance.mul(marketFee).div(100); uint256 finalBalance = newBalance - marketFeeBalance; uint256 finalHalf = otherHalf; if(marketTokenAddressForFee != address(0)){ swapEthForTokens(marketFeeBalance, marketTokenAddressForFee, marketAddress); }else{ (bool sent,) = marketAddress.call{value: marketFeeBalance}(\"\"); } addLiquidity(finalHalf, finalBalance); emit SwapAndLiquify(half, finalBalance, otherHalf); }",
        "vulnerability": "Reentrancy vulnerability",
        "reason": "The function calls an external contract via swapTokensForEth and swapEthForTokens without any reentrancy guard, which could lead to reentrancy attacks if the external calls are exploited.",
        "file_name": "0x0aabf9daefcd484405479d2748cbaedb53c33d87.sol"
    },
    {
        "function_name": "_transfer",
        "code": "function _transfer( address from, address to, uint256 amount ) internal override { require(!_isBlacklisted[from], \"Blacklisted address cannot transfer!\"); require(!_isBlacklisted[to], \"Blacklisted address cannot transfer!\"); require(from != address(0), \"ERC20: transfer to the zero address\"); require(to != address(0), \"ERC20: transfer to the zero address\"); bool tradingIsEnabled = getTradingIsEnabled(); if(!tradingIsEnabled) { require(canTransferBeforeTradingIsEnabled[from], \"MRFROG: This account cannot send tokens until trading is enabled\"); } if(amount == 0) { super._transfer(from, to, 0); return; } bool buyOrSell = false; if ( from != owner() && to != owner() && to != address(0) && to != address(0xdead) && to != uniswapV2Pair && automatedMarketMakerPairs[from] ) { require( amount <= maxBuyTranscationAmount, \"Transfer amount exceeds the maxTxAmount.\" ); uint256 contractBalanceRecepient = balanceOf(to); require( contractBalanceRecepient + amount <= _maxWalletToken, \"Exceeds maximum wallet token amount.\" ); previousMarketFee = marketFee; previousTokenRewardsFee = tokenRewardsFee; previousLiquidityFee = liquidityFee; previousTotalFees = totalFees; marketFee = buyMarketFee; tokenRewardsFee = buyTokenRewardsFee; liquidityFee = buyLiquidityFee; totalFees = buyTotalFees; buyOrSell = true; } if( !swapping && tradingIsEnabled && automatedMarketMakerPairs[to] && from != address(uniswapV2Router) && !_isExcludedFromFees[to] ) { require(amount <= maxSellTransactionAmount, \"Sell transfer amount exceeds the maxSellTransactionAmount.\"); previousMarketFee = marketFee; previousTokenRewardsFee = tokenRewardsFee; previousLiquidityFee = liquidityFee; previousTotalFees = totalFees; marketFee = sellMarketFee; tokenRewardsFee = sellTokenRewardsFee; liquidityFee = sellLiquidityFee; totalFees = sellTotalFees; buyOrSell = true; } uint256 contractTokenBalance = balanceOf(address(this)); bool canSwap = contractTokenBalance >= swapTokensAtAmount; if( tradingIsEnabled && canSwap && !swapping && !automatedMarketMakerPairs[from] && from != burnAddress && to != burnAddress ) { swapping = true; uint256 dividendAmount = swapTokensAtAmount.mul(tokenRewardsFee).div(100); uint256 adminAmount = swapTokensAtAmount.sub(dividendAmount); swapAndLiquify(adminAmount); swapAndSendDividends(dividendAmount); swapping = false; } bool takeFee = tradingIsEnabled && !swapping; if(_isExcludedFromFees[from] || _isExcludedFromFees[to]) { takeFee = false; } if(takeFee) { uint256 fees = amount.mul(totalFees).div(100); amount = amount.sub(fees); super._transfer(from, address(this), fees); } super._transfer(from, to, amount); restoreFees(); try dividendTracker.setBalance(payable(from), balanceOf(from)) {} catch {} try dividendTracker.setBalance(payable(to), balanceOf(to)) {} catch {} bool canDividend = block.timestamp >= processDividendTime; if(!swapping && canDividend) { uint256 gas = gasForProcessing; processDividendTime += dividendTime; try dividendTracker.process(gas) returns (uint256 iterations, uint256 claims, uint256 lastProcessedIndex) { emit ProcessedDividendTracker(iterations, claims, lastProcessedIndex, true, gas, tx.origin); } catch { } } }",
        "vulnerability": "Trading lock manipulation",
        "reason": "The function checks if trading is enabled and restricts transfers if not. An attacker with the ability to manipulate the tradingEnabledTimestamp could unlock or lock trading at will, enabling unauthorized trading.",
        "file_name": "0x0aabf9daefcd484405479d2748cbaedb53c33d87.sol"
    },
    {
        "function_name": "setAutomatedMarketMakerPair",
        "code": "function setAutomatedMarketMakerPair(address pair, bool value) external onlyOwner { require(pair != uniswapV2Pair, \"MRFROG: The PancakeSwap pair cannot be removed from automatedMarketMakerPairs\"); _setAutomatedMarketMakerPair(pair, value); } function _setAutomatedMarketMakerPair(address pair, bool value) private { require(automatedMarketMakerPairs[pair] != value, \"MRFROG: Automated market maker pair is already set to that value\"); automatedMarketMakerPairs[pair] = value; if(value) { dividendTracker.excludeFromDividends(pair); } emit SetAutomatedMarketMakerPair(pair, value); }",
        "vulnerability": "Market manipulation",
        "reason": "The contract owner can arbitrarily set or unset automated market maker pairs, which could be exploited to manipulate market conditions, such as altering liquidity pools or affecting trading conditions.",
        "file_name": "0x0aabf9daefcd484405479d2748cbaedb53c33d87.sol"
    }
]