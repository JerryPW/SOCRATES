[
    {
        "function_name": "emergencyWithdraw",
        "code": "function emergencyWithdraw(uint amount) external noContractsAllowed nonReentrant payable { require(amount > 0, \"invalid amount!\"); require(amount <= depositTokenBalance[msg.sender], \"Cannot withdraw more than deposited!\"); require(block.timestamp.sub(depositTime[msg.sender]) > LOCKUP_DURATION, \"You recently deposited, please wait before withdrawing.\"); updateAccount(msg.sender); depositTokenBalance[msg.sender] = depositTokenBalance[msg.sender].sub(amount); totalDepositedTokens = totalDepositedTokens.sub(amount); uint oldCTokenBalance = IERC20(TRUSTED_CTOKEN_ADDRESS).balanceOf(address(this)); uint oldEtherBalance = address(this).balance; require(CEther(TRUSTED_CTOKEN_ADDRESS).redeemUnderlying(amount) == 0, \"redeemUnderlying failed!\"); uint newCTokenBalance = IERC20(TRUSTED_CTOKEN_ADDRESS).balanceOf(address(this)); uint newEtherBalance = address(this).balance; uint depositTokenReceived = newEtherBalance.sub(oldEtherBalance); uint cTokenRedeemed = oldCTokenBalance.sub(newCTokenBalance); IWETH(TRUSTED_DEPOSIT_TOKEN_ADDRESS).deposit{value: depositTokenReceived}(); require(cTokenRedeemed <= cTokenBalance[msg.sender], \"redeem exceeds balance!\"); cTokenBalance[msg.sender] = cTokenBalance[msg.sender].sub(cTokenRedeemed); totalCTokens = totalCTokens.sub(cTokenRedeemed); decreaseTokenBalance(TRUSTED_CTOKEN_ADDRESS, cTokenRedeemed); totalTokensWithdrawnByUser[msg.sender] = totalTokensWithdrawnByUser[msg.sender].add(depositTokenReceived); uint feeAmount = depositTokenReceived.mul(FEE_PERCENT_X_100).div(ONE_HUNDRED_X_100); uint depositTokenReceivedAfterFee = depositTokenReceived.sub(feeAmount); IERC20(TRUSTED_DEPOSIT_TOKEN_ADDRESS).safeTransfer(msg.sender, depositTokenReceivedAfterFee); if (depositTokenBalance[msg.sender] == 0) { holders.remove(msg.sender); } emit Withdraw(msg.sender, depositTokenReceived); }",
        "vulnerability": "Potential front-running attack",
        "reason": "The `emergencyWithdraw` function allows users to withdraw their deposits after a lockup duration. An attacker could potentially monitor the mempool and try to front-run the transaction by executing a similar transaction to withdraw before the original transaction is mined. This could result in the original transaction failing or the attacker gaining an advantage.",
        "file_name": "0x01de5bce5c5ee4f92e8f4183f6f4e4f12f9a86cd.sol"
    },
    {
        "function_name": "claimAnyToken",
        "code": "function claimAnyToken(address token, uint amount) external onlyOwner { require(now > contractStartTime.add(ADMIN_CAN_CLAIM_AFTER), \"Contract not expired yet!\"); if (token == address(0)) { msg.sender.transfer(amount); return; } IERC20(token).safeTransfer(msg.sender, amount); }",
        "vulnerability": "Owner can drain tokens after expiry",
        "reason": "The `claimAnyToken` function allows the contract owner to transfer any token from the contract to the owner's address after a specific time period. This creates a centralization risk, as the owner could potentially drain all tokens from the contract, leaving users with no tokens.",
        "file_name": "0x01de5bce5c5ee4f92e8f4183f6f4e4f12f9a86cd.sol"
    },
    {
        "function_name": "handleFee",
        "code": "function handleFee(uint feeAmount, uint _amountOutMin_tokenFeeBuyBack, uint deadline) private { uint buyBackFeeAmount = feeAmount.mul(FEE_PERCENT_TO_BUYBACK_X_100).div(ONE_HUNDRED_X_100); uint remainingFeeAmount = feeAmount.sub(buyBackFeeAmount); distributeTokenDivs(remainingFeeAmount); IERC20(TRUSTED_DEPOSIT_TOKEN_ADDRESS).safeApprove(address(uniswapRouterV2), 0); IERC20(TRUSTED_DEPOSIT_TOKEN_ADDRESS).safeApprove(address(uniswapRouterV2), buyBackFeeAmount); uint oldPlatformTokenBalance = IERC20(TRUSTED_PLATFORM_TOKEN_ADDRESS).balanceOf(address(this)); address[] memory path = new address[](2); path[0] = TRUSTED_DEPOSIT_TOKEN_ADDRESS; path[1] = TRUSTED_PLATFORM_TOKEN_ADDRESS; uniswapRouterV2.swapExactTokensForTokens(buyBackFeeAmount, _amountOutMin_tokenFeeBuyBack, path, address(this), deadline); uint newPlatformTokenBalance = IERC20(TRUSTED_PLATFORM_TOKEN_ADDRESS).balanceOf(address(this)); uint platformTokensReceived = newPlatformTokenBalance.sub(oldPlatformTokenBalance); IERC20(TRUSTED_PLATFORM_TOKEN_ADDRESS).safeTransfer(BURN_ADDRESS, platformTokensReceived); }",
        "vulnerability": "Inadequate slippage protection",
        "reason": "The `handleFee` function uses Uniswap to swap tokens, but it does not adequately protect against slippage. The `_amountOutMin_tokenFeeBuyBack` parameter is meant to ensure a minimum amount of tokens are received, but if the market changes significantly, the swap might result in fewer tokens than expected, leading to potential losses.",
        "file_name": "0x01de5bce5c5ee4f92e8f4183f6f4e4f12f9a86cd.sol"
    }
]