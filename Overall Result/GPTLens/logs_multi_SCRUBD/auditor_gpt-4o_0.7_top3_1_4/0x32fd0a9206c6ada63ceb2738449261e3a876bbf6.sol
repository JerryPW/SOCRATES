[
    {
        "function_name": "sendExternalTokens",
        "code": "function sendExternalTokens(address official, address externalToken) external returns (bool) { Token tokenERC20 = Token(externalToken); uint256 balance = tokenERC20.allowance(official, address(this)); require(tokenERC20.balanceOf(official) >= balance, \"Official should have external tokens for approved\"); require(balance > 0, \"External tokens must be approved for town smart contract\"); tokenERC20.transferFrom(official, address(this), balance); ExternalTokenDistributionsInfo memory tokenInfo; tokenInfo._official = official; tokenInfo._distributionsCount = _distributionPeriodsNumber; tokenInfo._distributionAmount = balance.div(_distributionPeriodsNumber); ExternalToken storage tokenObj = _externalTokens[externalToken]; if (tokenObj._entities.length == 0) { _externalTokensAddresses.push(externalToken); } tokenObj._entities.push(tokenInfo); emit Proposal(balance, tokenInfo._official, tokenInfo._distributionsCount, tokenInfo._distributionAmount, externalToken); return true; }",
        "vulnerability": "Incorrect allowance check",
        "reason": "The function checks that the token balance is greater than or equal to the allowance, rather than checking if the allowance is set for the intended amount to transfer. This could lead to scenarios where the allowance is changed after the balance check, allowing tokens to be transferred without proper consent.",
        "file_name": "0x32fd0a9206c6ada63ceb2738449261e3a876bbf6.sol"
    },
    {
        "function_name": "claimFunds",
        "code": "function claimFunds(address payable official) public returns (bool) { require(_officialsLedger[official]._amount != 0, \"official address not found in ledger\"); if (block.timestamp >= _officialsLedger[official]._decayTimestamp) { RemunerationsOfficialsInfo memory info = RemunerationsOfficialsInfo(0, 0); _officialsLedger[official] = info; return false; } uint256 amount = _officialsLedger[official]._amount; if (address(this).balance >= amount) { official.transfer(amount); } else { RemunerationsInfo memory info = RemunerationsInfo(official, 1, amount); _remunerationsQueue.push(info); } RemunerationsOfficialsInfo memory info = RemunerationsOfficialsInfo(0, 0); _officialsLedger[official] = info; return true; }",
        "vulnerability": "Reentrancy vulnerability",
        "reason": "The function is vulnerable to reentrancy attacks because it updates the state _officialsLedger after transferring funds to the official. An attacker could exploit this by recursively calling claimFunds to drain the contract balance.",
        "file_name": "0x32fd0a9206c6ada63ceb2738449261e3a876bbf6.sol"
    },
    {
        "function_name": "getTownTokens",
        "code": "function getTownTokens(address holder) public payable returns (bool) { require(holder != address(0), \"holder address cannot be null\"); uint256 amount = msg.value; uint256 tokenAmount = IWantTakeTokensToAmount(amount); uint256 rate = currentRate(); if (_transactionsCount < _durationOfMinTokenGetAmount && tokenAmount < _minTokenGetAmount) { return false; } if (tokenAmount >= _maxTokenGetAmount) { tokenAmount = _maxTokenGetAmount; uint256 change = amount.sub(_maxTokenGetAmount.mul(rate).div(10 ** 18)); msg.sender.transfer(change); amount = amount.sub(change); } if (_token.balanceOf(address(this)) >= tokenAmount) { TransactionsInfo memory transactionsHistory = TransactionsInfo(rate, tokenAmount); _token.transfer(holder, tokenAmount); _historyTransactions[holder].push(transactionsHistory); _transactionsCount = _transactionsCount.add(1); } else { if (_token.balanceOf(address(this)) > 0) { uint256 tokenBalance = _token.balanceOf(address(this)); _token.transfer(holder, tokenBalance); TransactionsInfo memory transactionsHistory = TransactionsInfo(rate, tokenBalance); _historyTransactions[holder].push(transactionsHistory); tokenAmount = tokenAmount.sub(tokenBalance); } TransactionsInfo memory transactionsInfo = TransactionsInfo(rate, tokenAmount); TownTokenRequest memory tokenRequest = TownTokenRequest(holder, transactionsInfo); _queueTownTokenRequests.push(tokenRequest); } for (uint256 i = 0; i < _remunerationsQueue.length; ++i) { if (_remunerationsQueue[i]._priority == 1) { if (_remunerationsQueue[i]._amount > amount) { _remunerationsQueue[i]._address.transfer(_remunerationsQueue[i]._amount); amount = amount.sub(_remunerationsQueue[i]._amount); for (uint j = i + 1; j < _remunerationsQueue.length; ++j) { _remunerationsQueue[j - 1] = _remunerationsQueue[j]; } _remunerationsQueue.pop(); } else { _remunerationsQueue[i]._address.transfer(amount); _remunerationsQueue[i]._amount = _remunerationsQueue[i]._amount.sub(amount); break; } } } for (uint256 i = 0; i < _remunerationsQueue.length; ++i) { if (_remunerationsQueue[i]._amount > amount) { _remunerationsQueue[i]._address.transfer(_remunerationsQueue[i]._amount); amount = amount.sub(_remunerationsQueue[i]._amount); for (uint j = i + 1; j < _remunerationsQueue.length; ++j) { _remunerationsQueue[j - 1] = _remunerationsQueue[j]; } _remunerationsQueue.pop(); } else { _remunerationsQueue[i]._address.transfer(amount); _remunerationsQueue[i]._amount = _remunerationsQueue[i]._amount.sub(amount); break; } } return true; }",
        "vulnerability": "Improper balance checks",
        "reason": "The function does not properly handle the case where the token balance of the contract is insufficient to fulfill the token amount calculated. It attempts to adjust and queue the request, but this can be exploited if the token balance is manipulated externally, leading to a denial of service or unexpected behavior.",
        "file_name": "0x32fd0a9206c6ada63ceb2738449261e3a876bbf6.sol"
    }
]