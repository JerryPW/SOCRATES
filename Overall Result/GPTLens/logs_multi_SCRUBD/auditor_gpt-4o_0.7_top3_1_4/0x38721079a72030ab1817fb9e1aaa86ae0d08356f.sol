[
    {
        "function_name": "removeFromPool",
        "code": "function removeFromPool(uint256 amountToRemove, InvestmentLibrary.exitSwapParams[] memory exitSwapParams) public { require(balanceOf(msg.sender) > 0, \"You need to have pool tokens if you want to burn them!\"); require(amountToRemove > 0, \"You can't remove 0 of your tokens!\"); require(amountToRemove <= balanceOf(msg.sender), \"You can only remove 100% of your share!\"); require(exitSwapParams.length == _tokensHeld.length, \"Not enough params!\"); _burn(msg.sender, amountToRemove); if(balanceOf(msg.sender) == 0){ _totalHolders--; } uint256 userShare = amountToRemove * 10**18 / (totalSupply() + amountToRemove); uint256 wethPayout = IERC20(WETHAddress).balanceOf(address(this)) * userShare / 10**18; InvestmentLibrary.heldToken[] memory tokensHeldSnapshot = _tokensHeld; for (uint i = 0; i < tokensHeldSnapshot.length; i++){ IERC20 tokenContract = IERC20(tokensHeldSnapshot[i].tokenAddress); if(tokensHeldSnapshot[i].tokenAddress != WETHAddress){ if(exitSwapParams[i].fee == 0){ bytes memory emptyBytes; address[] memory path = new address[](2); path[0] = tokensHeldSnapshot[i].tokenAddress; path[1] = WETHAddress; uint256 wethRecieved = _swapTokens( path, emptyBytes, tokenContract.balanceOf(address(this)) * userShare / 10**18, exitSwapParams[i].minimumOut, address(0) ); wethPayout += wethRecieved; } else { address[] memory path; uint256 wethRecieved = _swapTokens( path, abi.encode(tokensHeldSnapshot[i].tokenAddress, exitSwapParams[i].fee, WETHAddress), tokenContract.balanceOf(address(this)) * userShare / 10**18, exitSwapParams[i].minimumOut, address(0) ); wethPayout += wethRecieved; } } } uint256 poolOwnerFeeAmount = wethPayout * _poolFee / 10**18; uint256 factoryFeeAmount = wethPayout * _factoryFee / 10**18; uint256 amountToPayToUser = wethPayout - factoryFeeAmount - poolOwnerFeeAmount; IWETH WETHContract = IWETH(WETHAddress); IERC20(WETHAddress).transfer(owner(), poolOwnerFeeAmount); processFee(WETHAddress, factoryFeeAmount, 0); WETHContract.withdraw(amountToPayToUser); msg.sender.call{value: amountToPayToUser}(\"\"); if(InvestmentLibrary.isTokenHeld(_tokensHeld, WETHAddress) == true && IERC20(WETHAddress).balanceOf(address(this)) == 0){ _removeAddressFromTokensHeld(WETHAddress); } emit InvestmentLibrary.feePaidToOwner(msg.sender, owner(), poolOwnerFeeAmount); emit InvestmentLibrary.poolRemovedFrom(msg.sender, amountToRemove, amountToPayToUser); }",
        "vulnerability": "Reentrancy Attack",
        "reason": "The function does not follow the checks-effects-interactions pattern. Specifically, the external call to `msg.sender.call{value: amountToPayToUser}(\"\");` occurs before the state changes are fully finalized. This could allow an attacker to reenter the contract and manipulate its state by calling `removeFromPool` repeatedly before the state change is finished.",
        "file_name": "0x38721079a72030ab1817fb9e1aaa86ae0d08356f.sol"
    },
    {
        "function_name": "addToPool",
        "code": "function addToPool(uint256[] memory minimumAmountsOut) public payable { require(msg.value > 0); if(totalSupply() == 0){ require(msg.value >= 10000000000000000 , \"You must initiate the pool with at least 0.01 ETH!\"); } uint256 factoryFeeAmount = msg.value * _factoryFee / 10**18; uint256 poolOwnerFeeAmount = msg.value * _poolFee / 10**18; uint256 amountIn = msg.value - factoryFeeAmount - poolOwnerFeeAmount; IWETH WETHContract = IWETH(WETHAddress); WETHContract.deposit{value: msg.value}(); IERC20(WETHAddress).transfer(owner(), poolOwnerFeeAmount); processFee(WETHAddress, factoryFeeAmount, 0); uint256 poolTokensToMint = InvestmentLibrary.getPoolTokensToMint( amountIn, _tokensHeld, totalSupply() ); if(_tokensToSwapIntoOnDeposit.length != 0){ for (uint i = 0; i < _tokensToSwapIntoOnDeposit.length; i++){ InvestmentLibrary.autoSwapToken memory autoSwapParams = _tokensToSwapIntoOnDeposit[i]; _swapTokens( autoSwapParams.v2Path, autoSwapParams.v3Path, amountIn * autoSwapParams.ratio / 10**18, minimumAmountsOut[i], autoSwapParams.quoteToken ); } } if(balanceOf(msg.sender) == 0){ _totalHolders++; } _mint(msg.sender, poolTokensToMint); if(InvestmentLibrary.isTokenHeld(_tokensHeld, WETHAddress) == false && IERC20(WETHAddress).balanceOf(address(this)) > 0){ _tokensHeld.push(InvestmentLibrary.heldToken(WETHAddress, address(0), false)); } emit InvestmentLibrary.feePaidToOwner(msg.sender, owner(), poolOwnerFeeAmount); emit InvestmentLibrary.poolAddedTo(msg.sender, msg.value, poolTokensToMint); }",
        "vulnerability": "Unauthorized Minting",
        "reason": "The function does not have any access control mechanism to prevent unauthorized users from minting tokens into the pool. This can result in unauthorized users exploiting this function to mint tokens and gain a larger share of the pool without proper authorization.",
        "file_name": "0x38721079a72030ab1817fb9e1aaa86ae0d08356f.sol"
    },
    {
        "function_name": "_swapTokens",
        "code": "function _swapTokens(address[] memory v2Path, bytes memory v3Path, uint256 amountIn, uint256 amountOutMinimum, address quoteToken) internal returns (uint256) { _adjustTokensHeld(v2Path, v3Path, amountIn, quoteToken); if(v2Path.length != 0){ uint256 balanceOfTokenBeforeSwap = IERC20(v2Path[v2Path.length - 1]).balanceOf(address(this)); IERC20(v2Path[0]).approve(address(uniswapV2Router), amountIn); uniswapV2Router.swapExactTokensForTokensSupportingFeeOnTransferTokens( amountIn, amountOutMinimum, v2Path, address(this), block.timestamp ); return IERC20(v2Path[v2Path.length - 1]).balanceOf(address(this)) - balanceOfTokenBeforeSwap; } else { bytes memory formattedBytes; if(v3Path.length == 96){ (address decodedTokenIn, uint24 swapFee, address decodedTokenOut) = abi.decode(v3Path, (address, uint24, address)); formattedBytes = abi.encodePacked(decodedTokenIn, swapFee, decodedTokenOut); IERC20(decodedTokenIn).approve(address(swapRouter), amountIn); } else { (address decodedTokenIn, uint24 fee1, address middleToken, uint24 fee2, address decodedTokenOut) = abi.decode(v3Path, (address, uint24, address, uint24, address)); formattedBytes = abi.encodePacked(decodedTokenIn, fee1, middleToken, fee2, decodedTokenOut); IERC20(decodedTokenIn).approve(address(swapRouter), amountIn); } ISwapRouter.ExactInputParams memory params = ISwapRouter.ExactInputParams( formattedBytes, address(this), block.timestamp, amountIn, amountOutMinimum ); return swapRouter.exactInput(params); } }",
        "vulnerability": "Unchecked External Call",
        "reason": "The function makes external calls to `uniswapV2Router.swapExactTokensForTokensSupportingFeeOnTransferTokens` and `swapRouter.exactInput` without checking the return values. This could lead to unexpected failures where the swap does not occur as expected, leading to a loss of tokens or a failed transaction not being properly handled.",
        "file_name": "0x38721079a72030ab1817fb9e1aaa86ae0d08356f.sol"
    }
]