[
    {
        "function_name": "acceptOwnership",
        "code": "function acceptOwnership() public { if (msg.sender == newOwner) { owner = newOwner; } }",
        "vulnerability": "Potential denial of service",
        "reason": "The 'acceptOwnership' function does not reset the 'newOwner' variable after ownership is transferred. If the new owner does not call 'acceptOwnership', the contract may be left in a state where ownership cannot be transferred again, effectively causing a denial of service for future ownership transfers.",
        "file_name": "0x0c2795fc4e1f57614eb78923dc78521ff0676fb8.sol"
    },
    {
        "function_name": "buy",
        "code": "function buy (address _address, uint _value, uint _time) internal returns(bool) { uint8 currentPhase = getPhase(_time); if (currentPhase == 1){ uint tokensToSend = _value.mul((uint)(10).pow(decimals))/(stage_1_price); if(stage_1_TokensSold.add(tokensToSend) <= STAGE_1_MAXCAP){ ethCollected = ethCollected.add(_value); token.transfer(_address,tokensToSend); distributionAddress.transfer(address(this).balance.sub(oraclizeBalance)); emit OnSuccessfullyBought(_address,_value,false,tokensToSend); stage_1_TokensSold = stage_1_TokensSold.add(tokensToSend); return true; }else{ if(stage_1_TokensSold == STAGE_1_MAXCAP){ return false; } uint availableTokens = STAGE_1_MAXCAP.sub(stage_1_TokensSold); uint ethRequire = availableTokens.mul(stage_1_price)/(uint(10).pow(decimals)); token.transfer(_address,availableTokens); msg.sender.transfer(_value.sub(ethRequire)); distributionAddress.transfer(address(this).balance.sub(oraclizeBalance)); emit OnSuccessfullyBought(_address,ethRequire,false,availableTokens); ethCollected = ethCollected.add(ethRequire); stage_1_TokensSold = STAGE_1_MAXCAP; return true; } } if(currentPhase == 2){ if(!phase2Flag){ stage_2_maxcap = stage_2_maxcap.add(STAGE_1_MAXCAP.sub(stage_1_TokensSold)); phase2Flag = true; } tokensToSend = _value.mul((uint)(10).pow(decimals))/stage_2_price; if(stage_2_TokensSold.add(tokensToSend) <= stage_2_maxcap){ ethCollected = ethCollected.add(_value); token.transfer(_address,tokensToSend); distributionAddress.transfer(address(this).balance.sub(oraclizeBalance)); emit OnSuccessfullyBought(_address,_value,false,tokensToSend); stage_2_TokensSold = stage_2_TokensSold.add(tokensToSend); return true; }else{ if(stage_2_TokensSold == stage_2_maxcap){ return false; } availableTokens = stage_2_maxcap.sub(stage_2_TokensSold); ethRequire = availableTokens.mul(stage_2_price)/(uint(10).pow(decimals)); token.transfer(_address,availableTokens); msg.sender.transfer(_value.sub(ethRequire)); distributionAddress.transfer(address(this).balance.sub(oraclizeBalance)); emit OnSuccessfullyBought(_address,ethRequire,false,availableTokens); ethCollected = ethCollected.add(ethRequire); stage_2_TokensSold = stage_2_maxcap; return true; } } if(currentPhase == 3){ tokensToSend = _value.mul((uint)(10).pow(decimals))/stage_3_price; if(stage_3_TokensSold.add(tokensToSend) <= STAGE_3_MAXCAP){ ethCollected = ethCollected.add(_value); token.transfer(_address,tokensToSend); distributionAddress.transfer(address(this).balance.sub(oraclizeBalance)); emit OnSuccessfullyBought(_address,_value,false,availableTokens); stage_3_TokensSold = stage_3_TokensSold.add(tokensToSend); return true; }else{ if(stage_3_TokensSold == STAGE_3_MAXCAP){ return false; } availableTokens = STAGE_3_MAXCAP.sub(stage_3_TokensSold); ethRequire = availableTokens.mul(stage_3_price)/(uint(10).pow(decimals)); token.transfer(_address,availableTokens); msg.sender.transfer(_value.sub(ethRequire)); distributionAddress.transfer(address(this).balance.sub(oraclizeBalance)); emit OnSuccessfullyBought(_address,ethRequire,false,availableTokens); ethCollected = ethCollected.add(ethRequire); stage_3_TokensSold = STAGE_3_MAXCAP; return true; } } return false; }",
        "vulnerability": "Incorrect Ether handling",
        "reason": "The function uses 'msg.sender.transfer' to refund excess ether, which is susceptible to reentrancy attacks. It should use the 'transfer' method on a trusted address or use a withdrawal pattern to safely handle excess ether.",
        "file_name": "0x0c2795fc4e1f57614eb78923dc78521ff0676fb8.sol"
    },
    {
        "function_name": "__callback",
        "code": "function __callback(bytes32, string result, bytes) public { require(msg.sender == oraclize_cbAddress()); uint256 price = 10 ** 23 / parseInt(result, 5); require(price > 0); stage_1_price = price*11/100; stage_2_price = price*16/100; stage_3_price = price*21/100; priceUpdateAt = block.timestamp; if(updateFlag){ update(); } }",
        "vulnerability": "Potential manipulation by Oraclize",
        "reason": "The contract relies on oraclize to update prices, but it does not validate the integrity of the data returned by oraclize. An attacker controlling oraclize or with the ability to manipulate the data source could provide incorrect data, leading to incorrect token pricing.",
        "file_name": "0x0c2795fc4e1f57614eb78923dc78521ff0676fb8.sol"
    }
]