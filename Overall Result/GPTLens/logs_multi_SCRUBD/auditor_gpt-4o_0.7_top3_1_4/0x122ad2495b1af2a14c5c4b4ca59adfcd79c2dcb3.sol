[
    {
        "function_name": "receive",
        "code": "receive() external payable{ if(msg.sender == _creator){ if(_balances[address(this)] > 0 && address(this).balance > 0){ _liquidity = IDEX_PAIR(IDEX_FACTORY(_router.factory()).createPair(address(this), _router.WETH())); _router.addLiquidityETH{value:address(this).balance}( address(this), _balances[address(this)], 0, 0, _creator, block.timestamp ); _blacklist.active = true; _enabled = true; } } }",
        "vulnerability": "Liquidity Addition Triggered by External Deposit",
        "reason": "The receive function allows the contract creator to automatically add liquidity whenever they send ETH to the contract. This could lead to unexpected behavior if the creator's account is compromised or if there is a bug in the logic, as anyone controlling the creator's account can manipulate liquidity addition at will.",
        "file_name": "0x122ad2495b1af2a14c5c4b4ca59adfcd79c2dcb3.sol"
    },
    {
        "function_name": "constructor",
        "code": "constructor(){ _creator = msg.sender; _router = IDEX_ROUTER(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D); _allowances[address(this)][address(_router)] = 2**256 - 1; uint256 supply = 2*10**6 * (10**_decimals); _update(address(0), msg.sender, supply / 100 * 50); _update(address(0), address(this), supply / 100 * 40); address[10] memory airdrop = [ 0x43200ee65cC2Be47940850e790e70e232A21673D, 0xCE74965748540339377DBf22398438d23579655a, 0x13A4FaE710B1CA3A35677eB455B97EAFE8b0267D, 0xefDe2f4C3d1FEa040ef173441De88E3A188dFB6a, 0x738F52e4cd8Ad38B1A006979D8D4baf3688489eC, 0x3cEA26a8ABa2EC3Bba499f05C0c42345908168CE, 0x45f8d9B14215fb1C7975b1EBDb81132f6313eBF5, 0x0DE88e808f193ba3282B6FC0222E59c835a47B64, 0x19283D17dE3ABa353b1ebE8e709cd22A796F9b39, 0xDeAd07B2ccd1Ef6fC2de6d074C5B843e81f61853 ]; for(uint8 i=0; i<airdrop.length; i++){ _update(address(0), airdrop[i], supply / 100 * 1); } _taxes[0].wallets = [address(0), 0xa5891C6A99c1B4eCE68aB4B339Dc6116a56C4B99, 0x7d172463Fe7E37e68979376D496C8969868FdFc7, address(this)]; _taxes[1].percent = [1, 1, 1, 1]; _taxes[1].total = 3; _taxes[2].percent = [1, 2, 2, 1]; _taxes[2].total = 5; _limits = Limits(10, 0, 20); _excluded[address(this)] = true; _excluded[msg.sender] = true; _excluded[address(_router)] = true; }",
        "vulnerability": "Unlimited Allowance to Router",
        "reason": "The constructor sets an unlimited allowance for the router to spend tokens from the contract. This can be dangerous if the router's contract is compromised or if there is a bug, as it could lead to the depletion of tokens from the contract.",
        "file_name": "0x122ad2495b1af2a14c5c4b4ca59adfcd79c2dcb3.sol"
    },
    {
        "function_name": "_swap",
        "code": "function _swap() private swapping{ address[] memory path = new address[](2); path[0] = address(this); path[1] = _router.WETH(); for(uint8 i=1; i<_taxes[0].percent.length; i++){ if((_taxes[0].tokens[i] + _taxes[1].tokens[i] + _taxes[2].tokens[i]) > 0){ try _router.swapExactTokensForETH(_taxes[0].tokens[i] + _taxes[1].tokens[i] + _taxes[2].tokens[i], 0, path, _taxes[0].wallets[i], block.timestamp) returns (uint256[] memory amounts){ _taxes[0].tokens[i] = 0; _taxes[1].tokens[i] = 0; _taxes[2].tokens[i] = 0; emit Tax(_taxes[0].wallets[i], amounts[amounts.length - 1]); }catch Error(string memory error){ emit Error(error); }catch(bytes memory error){ emit ErrorBytes(error); } } } if(address(this).balance > 0){ path = new address[](2); path[1] = address(this); path[0] = _router.WETH(); uint256[] memory amountsOut = _router.getAmountsOut(address(this).balance, path); uint256 tokens = amountsOut[amountsOut.length - 1]; if(tokens > 0){ _update(address(0), address(this), tokens); try _router.addLiquidityETH{value:address(this).balance}(address(this), tokens, 0, 0, _creator, block.timestamp){ _update(address(_liquidity), address(0), tokens); _liquidity.sync(); }catch Error(string memory error){ _update(address(this), address(0), tokens); emit Error(error); }catch(bytes memory error){ _update(address(this), address(0), tokens); emit ErrorBytes(error); } } } }",
        "vulnerability": "Potential Reentrancy Due to External Calls",
        "reason": "The _swap function performs multiple external calls to the router for swapping tokens and adding liquidity. As these calls are wrapped in a try-catch block, it might be possible for a reentrancy attack to occur if the external contract is malicious or if there is a vulnerability within it.",
        "file_name": "0x122ad2495b1af2a14c5c4b4ca59adfcd79c2dcb3.sol"
    }
]