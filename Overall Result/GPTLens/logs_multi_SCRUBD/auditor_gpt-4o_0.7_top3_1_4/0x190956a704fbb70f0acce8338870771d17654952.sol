[
    {
        "function_name": "withdraw",
        "code": "function withdraw(bytes calldata _proof, bytes32 _root, bytes32 _nullifierHash, address payable _recipient, address payable _relayer, uint256 _relayerFee, uint256 _refund) external payable nonReentrant { require(_refund == 0, \"refund is not zero\"); require(!Address.isContract(_recipient), \"recipient of cannot be contract\"); require(isKnownRoot(_root), \"Cannot find your merkle root\"); require(verifier.verifyProof(_proof, [uint256(_root), uint256(_nullifierHash), uint256(_recipient), uint256(_relayer), _relayerFee, _refund]), \"Invalid withdraw proof\"); verifier.verifyNullifier(_nullifierHash); uint256 td = tokenDenomination; if (td > 0) { safeTransfer(token, _recipient, td); } updateBlockReward(); uint256 relayerFee = 0; uint256 M87Deno = getAccumulateM87().div(numOfShares); if (M87Deno > 0) { accumulateM87 -= M87Deno; safeTransfer(M87Token, _recipient, M87Deno); } uint256 cd = coinDenomination - feeToCollectAmount; if (_relayerFee > cd) { _relayerFee = cd; } if (_relayerFee > 0) { (bool success,) = _relayer.call.value(_relayerFee)(\"\"); require(success, \"failed to send relayer fee\"); cd -= _relayerFee; } if (cd > 0) { (bool success,) = _recipient.call.value(cd)(\"\"); require(success, \"failed to withdraw coin\"); } numOfShares -= 1; emit Withdrawal(_recipient, _nullifierHash, _relayer, M87Deno, relayerFee); }",
        "vulnerability": "Recipient address check bypass",
        "reason": "The function attempts to prevent reentrancy by restricting the recipient as a non-contract address. However, the `_recipient` address check is only performed using `Address.isContract`, which can be bypassed by executing the withdrawal in a constructor of a contract. This could allow an attacker to perform reentrancy attacks.",
        "file_name": "0x190956a704fbb70f0acce8338870771d17654952.sol"
    },
    {
        "function_name": "safeTransfer",
        "code": "function safeTransfer(IERC20 _token, address _to, uint256 _amount) internal { uint256 balance = _token.balanceOf(address(this)); if (_amount > balance) { _token.safeTransfer(_to, balance); } else { _token.safeTransfer(_to, _amount); } }",
        "vulnerability": "Incorrect handling of transfer",
        "reason": "This function checks if the contract balance is less than the amount to transfer, and if so, it transfers the entire balance. However, this can lead to unexpected behavior or loss of funds if `safeTransfer` is called with an amount greater than the contract balance. An attacker could exploit this by inducing state changes that reduce the available balance after a check but before the transfer.",
        "file_name": "0x190956a704fbb70f0acce8338870771d17654952.sol"
    },
    {
        "function_name": "swapAndShare",
        "code": "function swapAndShare() private { require(collectedFee > 0, \"Insufficient Amount\"); uint256 initialBalance = M87Token.balanceOf(address(this)); address[] memory path = new address[](2); path[0] = uniswapV2Router.WETH(); path[1] = address(M87Token); uniswapV2Router.swapExactETHForTokensSupportingFeeOnTransferTokens.value(collectedFee) ( 0, path, address(this), block.timestamp.mul(2) ); collectedFee = 0; uint256 newBalance = M87Token.balanceOf(address(this)).sub(initialBalance); if( shareOfReward[0] > 0 ) { M87Token.transfer( address(0x000000000000000000000000000000000000dEaD), newBalance.mul(shareOfReward[0]).div(100) ); } if( poolList[0] != address(0) && shareOfReward[1] > 0 && poolList[0] != address(this) ) { M87Token.transfer( poolList[0], newBalance.mul(shareOfReward[1]).div(100) ); } if( poolList[1] != address(0) && shareOfReward[2] > 0 && poolList[1] != address(this) ) { M87Token.transfer( poolList[1], newBalance.mul(shareOfReward[2]).div(100) ); } if( poolList[2] != address(0) && shareOfReward[3] > 0 && poolList[2] != address(this) ) { M87Token.transfer( poolList[2], newBalance.mul(shareOfReward[3]).div(100) ); } if( poolList[3] != address(0) && shareOfReward[4] > 0 && poolList[3] != address(this) ) { M87Token.transfer( poolList[3], newBalance.mul(shareOfReward[4]).div(100) ); } }",
        "vulnerability": "Unchecked external call",
        "reason": "The `swapAndShare` function uses Uniswap's `swapExactETHForTokensSupportingFeeOnTransferTokens` without checking the return value. If the swap fails, `collectedFee` is set to 0 regardless, resulting in a loss of funds. An attacker could exploit this by manipulating Uniswap's state to fail the swap intentionally, causing a denial of service or financial loss.",
        "file_name": "0x190956a704fbb70f0acce8338870771d17654952.sol"
    }
]