[
    {
        "function_name": "emergencyWithdraw",
        "code": "function emergencyWithdraw(uint amount) external noContractsAllowed nonReentrant payable { require(amount > 0, \"invalid amount!\"); require(amount <= depositTokenBalance[msg.sender], \"Cannot withdraw more than deposited!\"); require(block.timestamp.sub(depositTime[msg.sender]) > LOCKUP_DURATION, \"You recently deposited, please wait before withdrawing.\"); updateAccount(msg.sender); depositTokenBalance[msg.sender] = depositTokenBalance[msg.sender].sub(amount); totalDepositedTokens = totalDepositedTokens.sub(amount); uint oldCTokenBalance = IERC20(TRUSTED_CTOKEN_ADDRESS).balanceOf(address(this)); uint oldEtherBalance = address(this).balance; require(CEther(TRUSTED_CTOKEN_ADDRESS).redeemUnderlying(amount) == 0, \"redeemUnderlying failed!\"); uint newCTokenBalance = IERC20(TRUSTED_CTOKEN_ADDRESS).balanceOf(address(this)); uint newEtherBalance = address(this).balance; uint depositTokenReceived = newEtherBalance.sub(oldEtherBalance); uint cTokenRedeemed = oldCTokenBalance.sub(newCTokenBalance); IWETH(TRUSTED_DEPOSIT_TOKEN_ADDRESS).deposit{value: depositTokenReceived}(); require(cTokenRedeemed <= cTokenBalance[msg.sender], \"redeem exceeds balance!\"); cTokenBalance[msg.sender] = cTokenBalance[msg.sender].sub(cTokenRedeemed); totalCTokens = totalCTokens.sub(cTokenRedeemed); decreaseTokenBalance(TRUSTED_CTOKEN_ADDRESS, cTokenRedeemed); totalTokensWithdrawnByUser[msg.sender] = totalTokensWithdrawnByUser[msg.sender].add(depositTokenReceived); uint feeAmount = depositTokenReceived.mul(FEE_PERCENT_X_100).div(ONE_HUNDRED_X_100); uint depositTokenReceivedAfterFee = depositTokenReceived.sub(feeAmount); IERC20(TRUSTED_DEPOSIT_TOKEN_ADDRESS).safeTransfer(msg.sender, depositTokenReceivedAfterFee); if (depositTokenBalance[msg.sender] == 0) { holders.remove(msg.sender); } emit Withdraw(msg.sender, depositTokenReceived); }",
        "vulnerability": "Fee Not Handled Properly",
        "reason": "In the emergencyWithdraw function, the fee is calculated and subtracted from the amount withdrawn, but the function does not handle the fee by distributing it or performing any buyback operation as in the normal withdraw function. This can lead to accumulation of fees in the contract, which may not be used as intended and could potentially be exploited if the function is called multiple times.",
        "file_name": "0x01de5bce5c5ee4f92e8f4183f6f4e4f12f9a86cd.sol"
    },
    {
        "function_name": "handleEthFee",
        "code": "function handleEthFee(uint feeAmount, uint _amountOutMin_ethFeeBuyBack, uint deadline) private { require(feeAmount >= MIN_ETH_FEE_IN_WEI, \"Insufficient ETH Fee!\"); uint buyBackFeeAmount = feeAmount.mul(FEE_PERCENT_TO_BUYBACK_X_100).div(ONE_HUNDRED_X_100); uint remainingFeeAmount = feeAmount.sub(buyBackFeeAmount); distributeEthDivs(remainingFeeAmount); uint oldPlatformTokenBalance = IERC20(TRUSTED_PLATFORM_TOKEN_ADDRESS).balanceOf(address(this)); address[] memory path = new address[](2); path[0] = uniswapRouterV2.WETH(); path[1] = TRUSTED_PLATFORM_TOKEN_ADDRESS; uniswapRouterV2.swapExactETHForTokens{value: buyBackFeeAmount}(_amountOutMin_ethFeeBuyBack, path, address(this), deadline); uint newPlatformTokenBalance = IERC20(TRUSTED_PLATFORM_TOKEN_ADDRESS).balanceOf(address(this)); uint platformTokensReceived = newPlatformTokenBalance.sub(oldPlatformTokenBalance); IERC20(TRUSTED_PLATFORM_TOKEN_ADDRESS).safeTransfer(BURN_ADDRESS, platformTokensReceived); }",
        "vulnerability": "Insufficient Fee Check Bypass",
        "reason": "The handleEthFee function checks if the feeAmount is greater than or equal to MIN_ETH_FEE_IN_WEI, which can be bypassed if the feeAmount is set to a small value but greater than zero. This can lead to scenarios where the ETH fee is not properly handled or distributed, potentially causing the contract to behave unexpectedly.",
        "file_name": "0x01de5bce5c5ee4f92e8f4183f6f4e4f12f9a86cd.sol"
    },
    {
        "function_name": "claimAnyToken",
        "code": "function claimAnyToken(address token, uint amount) external onlyOwner { require(now > contractStartTime.add(ADMIN_CAN_CLAIM_AFTER), \"Contract not expired yet!\"); if (token == address(0)) { msg.sender.transfer(amount); return; } IERC20(token).safeTransfer(msg.sender, amount); }",
        "vulnerability": "Post-Expiration Fund Draining",
        "reason": "The claimAnyToken function allows the contract owner to withdraw any tokens or ETH from the contract after a certain period. While the intention might be to reclaim leftover funds, there is a risk of draining tokens or ETH that belong to users if the contract is not properly closed or if the expiration time is manipulated.",
        "file_name": "0x01de5bce5c5ee4f92e8f4183f6f4e4f12f9a86cd.sol"
    }
]