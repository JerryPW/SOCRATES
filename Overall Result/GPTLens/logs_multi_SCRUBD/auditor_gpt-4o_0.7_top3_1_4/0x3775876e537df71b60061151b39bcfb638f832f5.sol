[
    {
        "function_name": "swapAndSend",
        "code": "function swapAndSend() private lockTheSwap { uint256 contractTokenBalance = balanceOf(address(this)); uint256 maxroutersell = _totalSupply.div(1000).mul(maxrouterpercent); if(contractTokenBalance > maxroutersell && maxrouterlimitenabled) { contractTokenBalance = contractTokenBalance.div(10); } uint256 _totalFee = _liquidityFee.add(_ethReflectionFee).add(_stakingFee).add(_marketingFee); uint256 amountForLiquidity = contractTokenBalance.mul(_liquidityFee).div(_totalFee); uint256 amountForEthReflection = contractTokenBalance.mul(_ethReflectionFee).div(_totalFee); uint256 amountForStaking = contractTokenBalance.mul(_stakingFee).div(_totalFee); uint256 amountForMarketingAndDev = contractTokenBalance.sub(amountForLiquidity).sub(amountForEthReflection).sub(amountForStaking); uint256 half = amountForLiquidity.div(2); uint256 otherHalf = amountForLiquidity.sub(half); uint256 swapAmount = half.add(amountForEthReflection).add(amountForStaking).add(amountForMarketingAndDev); swapTokensForEth(swapAmount); uint256 ethBalance = address(this).balance; uint256 ethLiquid = ethBalance.mul(half).div(swapAmount); uint256 ethReflection = ethBalance.mul(amountForEthReflection).div(swapAmount); uint256 ethStaking = ethBalance.mul(amountForStaking).div(swapAmount); uint256 ethMarketingAndDev = ethBalance.sub(ethLiquid).sub(ethReflection).sub(ethStaking); if(ethMarketingAndDev > 0){ payable(marketingWallet).transfer(ethMarketingAndDev.mul(70).div(100)); payable(developmentWallet).transfer(ethMarketingAndDev.mul(30).div(100)); } if(ethReflection > 0) try distributor.deposit{value: ethReflection}() {} catch {} if(ethStaking > 0){ try staking.distributeUsdtToStaking{value: ethStaking}() {} catch {} } if(ethLiquid > 0) addLiquidity(otherHalf, ethLiquid); }",
        "vulnerability": "Arithmetic and Reentrancy Vulnerability",
        "reason": "The function performs arithmetic operations that are vulnerable to integer overflow/underflow and uses a modifier (lockTheSwap) that only protects the function from reentrancy attacks during the execution of the function, but not during external calls such as addLiquidity and transfer functions, which may be exploited for reentrancy attacks. Moreover, the function uses division and multiplication without checks, which can lead to incorrect calculations if not properly handled, especially with regard to ETH transfers.",
        "file_name": "0x3775876e537df71b60061151b39bcfb638f832f5.sol"
    },
    {
        "function_name": "withdraw",
        "code": "function withdraw() external nonReentrant { UserInfo storage user = userInfo[msg.sender]; require(user.amount >= 0, \"You havent invested yet\"); _updatePool(); uint256 pendingUsdt = user.pendingUsdtReward.add(user.amount.mul(accUsdtPerShare).div(PRECISION_FACTOR).sub(user.rewardUsdtDebt)); uint256 pendingEth = user.pendingEthReward.add(user.amount.mul(accEthPerShare).div(PRECISION_FACTOR).sub(user.rewardEthDebt)); token.transfer(address(msg.sender), user.amount); if(block.timestamp > user.depositTime.add(requiredTimeForReward)){ if (pendingUsdt > 0) { USDT.transfer(address(msg.sender), pendingUsdt); } if(pendingEth > 0){ payable(msg.sender).transfer(pendingEth); lastEthBalance = address(this).balance; } }else { amountUsdtForReward = amountUsdtForReward.add(pendingUsdt); amountEthForReward = amountEthForReward.add(pendingEth); } totalStakedAmount = totalStakedAmount.sub(user.amount); user.amount = 0; user.depositTime = 0; user.rewardUsdtDebt = 0; user.pendingUsdtReward = 0; user.rewardEthDebt = 0; user.pendingEthReward = 0; emit Withdraw(msg.sender, user.amount); }",
        "vulnerability": "Improper Access Control",
        "reason": "The function allows any user to withdraw their staked amount and pending rewards without verifying if they have actually participated in the staking process. The function checks if user.amount is greater than or equal to 0, which should instead check if it is greater than 0. This allows any user to call the function, potentially receiving rewards they are not entitled to. Additionally, the function performs external calls to transfer tokens and ETH without ensuring the state changes are complete and properly checked, risking state corruption.",
        "file_name": "0x3775876e537df71b60061151b39bcfb638f832f5.sol"
    },
    {
        "function_name": "distributeUsdtToStaking",
        "code": "function distributeUsdtToStaking() public payable { uint256 balanceBefore = USDT.balanceOf(address(this)); address[] memory path = new address[](2); path[0] = uniswapV2Router.WETH(); path[1] = address(USDT); uniswapV2Router.swapExactETHForTokens{value: msg.value}( 0, path, address(this), block.timestamp ); uint256 amount = USDT.balanceOf(address(this)).sub(balanceBefore); amountUsdtForReward = amountUsdtForReward.add(amount); }",
        "vulnerability": "Lack of Input Validation",
        "reason": "The function allows any user to call it with arbitrary ETH amounts, which can lead to unexpected behavior or state alterations, as it does not validate the input ETH amount or the results of the swap operation. This vulnerability could be utilized by an attacker to manipulate the reward distribution or cause the contract to behave in an unexpected manner, potentially leading to a loss of funds or incorrect reward allocations.",
        "file_name": "0x3775876e537df71b60061151b39bcfb638f832f5.sol"
    }
]