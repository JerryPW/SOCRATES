[
    {
        "function_name": "distributeExternal",
        "code": "function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, BATMODatasets.EventReturns memory _eventData_) private returns(BATMODatasets.EventReturns) { uint256 _p1 = _eth / 100; uint256 _dev = _eth / 50; _dev = _dev.add(_p1); uint256 _OBOK; if (!address(admin).call.value(_dev/2)() && !address(admin2).call.value(_dev/2)()) { _OBOK = _dev; _dev = 0; } uint256 _aff = _eth / 10; if (_affID != _pID && plyr_[_affID].name != '') { plyr_[_affID].aff = _aff.add(plyr_[_affID].aff); emit FOMOEvents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now); } else { _OBOK = _aff; } _OBOK = _OBOK.add((_eth.mul(fees_[_team].obok)) / (100)); if (_OBOK > 0) { uint256 _potAmount = _OBOK / 2; address(ObokContract).call.value(_OBOK.sub(_potAmount))(bytes4(keccak256(\"donateDivs()\"))); round_[_rID].pot = round_[_rID].pot.add(_potAmount); _eventData_.tokenAmount = _OBOK.add(_eventData_.tokenAmount); } return(_eventData_); }",
        "vulnerability": "Reentrancy",
        "reason": "The function uses low-level calls to transfer ETH, which may lead to a reentrancy attack. If called reentrantly, an attacker could manipulate the state changes that happen after the call, potentially leading to unexpected behavior or draining of funds.",
        "file_name": "0x37238583c041a2f51964f23fde2710c4fbd29e9e.sol"
    },
    {
        "function_name": "endRound",
        "code": "function endRound(BATMODatasets.EventReturns memory _eventData_) private returns (BATMODatasets.EventReturns) { uint256 _rID = rID_; uint256 _winPID = round_[_rID].plyr; uint256 _winTID = round_[_rID].team; uint256 _pot = round_[_rID].pot; uint256 _win = (_pot.mul(48)) / 100; uint256 _dev = (_pot / 50); uint256 _gen = (_pot.mul(potSplit_[_winTID].gen)) / 100; uint256 _OBOK = (_pot.mul(potSplit_[_winTID].obok)) / 100; uint256 _res = (((_pot.sub(_win)).sub(_dev)).sub(_gen)).sub(_OBOK); uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys); uint256 _dust = _gen.sub((_ppt.mul(round_[_rID].keys)) / 1000000000000000000); if (_dust > 0) { _gen = _gen.sub(_dust); _res = _res.add(_dust); } plyr_[_winPID].win = _win.add(plyr_[_winPID].win); admin.transfer(_dev / 2); admin2.transfer(_dev / 2); address(ObokContract).call.value(_OBOK.sub((_OBOK / 3).mul(2)))(bytes4(keccak256(\"donateDivs()\"))); round_[_rID].pot = _pot.add(_OBOK / 3); round_[_rID].mask = _ppt.add(round_[_rID].mask); _eventData_.compressedData = _eventData_.compressedData + (round_[_rID].end * 1000000); _eventData_.compressedIDs = _eventData_.compressedIDs + (_winPID * 100000000000000000000000000) + (_winTID * 100000000000000000); _eventData_.winnerAddr = plyr_[_winPID].addr; _eventData_.winnerName = plyr_[_winPID].name; _eventData_.amountWon = _win; _eventData_.genAmount = _gen; _eventData_.tokenAmount = _OBOK; _eventData_.newPot = _res; rID_++; _rID++; round_[_rID].strt = now; round_[_rID].end = now.add(rndInit_).add(rndGap_); round_[_rID].pot += _res; return(_eventData_); }",
        "vulnerability": "Reentrancy",
        "reason": "The use of low-level calls for transferring ETH can lead to reentrancy issues. For example, if the `ObokContract` is compromised, it could exploit this call to reenter the function and execute malicious actions.",
        "file_name": "0x37238583c041a2f51964f23fde2710c4fbd29e9e.sol"
    },
    {
        "function_name": "withdraw",
        "code": "function withdraw() isActivated() isHuman() public { uint256 _rID = rID_; uint256 _now = now; uint256 _pID = pIDxAddr_[msg.sender]; uint256 _eth; if (_now > round_[_rID].end && round_[_rID].ended == false && round_[_rID].plyr != 0) { BATMODatasets.EventReturns memory _eventData_; round_[_rID].ended = true; _eventData_ = endRound(_eventData_); _eth = withdrawEarnings(_pID); if (_eth > 0) plyr_[_pID].addr.transfer(_eth); _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000); _eventData_.compressedIDs = _eventData_.compressedIDs + _pID; emit FOMOEvents.onWithdrawAndDistribute ( msg.sender, plyr_[_pID].name, _eth, _eventData_.compressedData, _eventData_.compressedIDs, _eventData_.winnerAddr, _eventData_.winnerName, _eventData_.amountWon, _eventData_.newPot, _eventData_.tokenAmount, _eventData_.genAmount ); } else { _eth = withdrawEarnings(_pID); if (_eth > 0) plyr_[_pID].addr.transfer(_eth); emit FOMOEvents.onWithdraw(_pID, msg.sender, plyr_[_pID].name, _eth, _now); } }",
        "vulnerability": "Reentrancy",
        "reason": "Directly transferring ETH using `.transfer` can lead to reentrancy vulnerabilities if the recipient is a contract. An attacker could exploit this by calling back into the contract before state changes are finalized, potentially leading to unauthorized withdrawals.",
        "file_name": "0x37238583c041a2f51964f23fde2710c4fbd29e9e.sol"
    }
]