[
    {
        "function_name": "mintProof",
        "code": "function mintProof(uint256 mintCount,address receiveAds,bytes32[] memory proof) public payable { require(!isContract(msg.sender),\"not supper contract mint\"); require(mintCount > 0, \"Invalid mint count\"); require(mintCount <= _maxMintPerAddress, \"Exceeded maximum mint count per address\"); require(msg.value >= mintCount*_mintPrice, \"illegal price\"); require(_mintCounts[msg.sender]+mintCount <= _maxMintPerAddress, \"over limit\"); receiveAds = msg.sender; if(isZero(wlRoot)){ require(block.timestamp >= mintStartTime, \"Minting has not started yet\"); require(block.timestamp <= mintEndTime, \"Minting has ended\"); }else { if (block.timestamp<wlMintedEndTime){ require(wlMintedCounts+mintCount<=wlMintCounts,\"over limit\"); bytes32 leaf = keccak256(abi.encodePacked(msg.sender)); require(MerkleProof.verify(proof, wlRoot, leaf),\"Not In Wl\"); wlMintedCounts += mintCount; } } if (block.timestamp<wlMintedEndTime){ require(_mintedCounts-wlMintedCounts+mintCount <= (_maxMintCount - wlMintedCounts), \"illegal mintAmount\"); } IWETH(wethAddress).deposit{value: msg.value*(1000-deployReserveEthPro-donateEthPro)/1000}(); IWETH(wethAddress).approve(lpContract, msg.value*(1000-deployReserveEthPro-donateEthPro)/1000); IWETH(wethAddress).transferFrom(address(this), lpContract, msg.value*(1000-deployReserveEthPro-donateEthPro)/1000); uint256 mintAmount = (totalSupply() * _maxPro * mintCount) / (_maxMintCount * 2000000); for (uint256 i = 0; i < contractAuths.length; i++) { if (contractAuths[i].contractType == ContractType.ERC721) { if(validateNftNumber==1){ IERC721Enumerable eRC721Enumerable = IERC721Enumerable(contractAuths[i].contractAddress); uint256 tokenId = eRC721Enumerable.tokenOfOwnerByIndex(msg.sender, 0); require(!tokenExists[tokenId],\"had used!\"); tokenExists[tokenId] = true; } uint256 tokenCount = getERC721TokenCount(contractAuths[i].contractAddress); require(tokenCount >= contractAuths[i].tokenCount, \"Insufficient ERC721 tokens\"); } else if (contractAuths[i].contractType == ContractType.ERC20) { uint256 tokenCount = getERC20TokenCount(contractAuths[i].contractAddress); require(tokenCount >= contractAuths[i].tokenCount, \"Insufficient ERC20 tokens\"); } else if (contractAuths[i].contractType == ContractType.ERC1155) { uint256 tokenCount = getERC1155TokenCount(contractAuths[i].contractAddress, 0); require(tokenCount >= contractAuths[i].tokenCount, \"Insufficient ERC1155 tokens\"); } } _transfer(address(this), receiveAds, mintAmount); _transfer(address(this), lpContract, mintAmount); IUniswapV2Pair(lpContract).sync(); _mintCounts[msg.sender] += mintCount; _mintedCounts += mintCount; }",
        "vulnerability": "Reentrancy vulnerability",
        "reason": "The function involves multiple external calls, including calls to the WETH contract and Uniswap V2 Pair contract. Since there are no reentrancy guards (such as a reentrancy modifier or updating state variables before external calls), an attacker could potentially use reentrancy to manipulate the logic of this function, leading to unexpected minting behavior or ETH manipulation.",
        "file_name": "0x0321be5f545ea569424aace4dc08d60f467229ac.sol"
    },
    {
        "function_name": "transfer",
        "code": "function transfer(address recipient, uint256 amount) public override returns (bool) { uint256 burnAddressAmount = amount * burnAddressPer / 1000; uint256 burnBlockAmount = amount * burnBlockPer / 1000; uint256 burnAirDropAmount = amount * burnAirDropPer / 1000; uint256 transferAmount = amount - burnAddressAmount -burnBlockAmount-burnAirDropAmount; super._transfer(msg.sender, recipient, transferAmount); if(burnAddressAmount>0){ super._transfer(msg.sender, burnAddress, burnAddressAmount); } if(burnBlockAmount>0){ super._transfer(msg.sender, blackHole, burnBlockAmount); } if(burnAirDropAmount>0){ super._transfer(msg.sender, airDropAddress, burnAirDropAmount); } return true; }",
        "vulnerability": "Potential overflow/underflow in transfer calculations",
        "reason": "The transfer function calculates multiple amounts based on the original amount and percentage values. If burnAddressPer, burnBlockPer, or burnAirDropPer are set incorrectly (e.g., excessively high values), the subtraction operations could result in negative values, leading to incorrect transfer amounts. Although Solidity 0.8+ includes overflow checks, an incorrect setup can still cause issues in the logic and expected behavior.",
        "file_name": "0x0321be5f545ea569424aace4dc08d60f467229ac.sol"
    },
    {
        "function_name": "devAwardEth",
        "code": "function devAwardEth() external { require(_mintedCounts==_maxMintCount,\"waiting mint finish\"); require(!devHadClaimEth,\"had claimed\"); require(msg.sender==_devAddress,\"only dev!\"); uint256 balance = address(this).balance; require(balance > 0, \"Contract has no ETH balance.\"); address payable sender = payable(_devAddress); uint256 devAmount = donateEthPro*balance/(deployReserveEthPro+donateEthPro); if(remainBalance==0){ sender.transfer(devAmount); remainBalance = balance-devAmount; }else{ sender.transfer(remainBalance); } devHadClaimEth = true; }",
        "vulnerability": "Incorrect ETH distribution logic",
        "reason": "The function calculates the amount of ETH to transfer to the developer based on the proportions of deployReserveEthPro and donateEthPro. If these values are not set correctly, or if the balance logic is flawed, the developer could receive an incorrect amount of ETH. Additionally, the function does not handle potential failures in the transfer operation (e.g., if the recipient's address is a smart contract without a payable fallback function), which could lead to unexpected behavior.",
        "file_name": "0x0321be5f545ea569424aace4dc08d60f467229ac.sol"
    }
]