[
    {
        "function_name": "withdraw",
        "code": "function withdraw(bytes calldata _proof, bytes32 _root, bytes32 _nullifierHash, address payable _recipient, address payable _relayer, uint256 _relayerFee, uint256 _refund) external payable nonReentrant {\n    require(_refund == 0, \"refund is not zero\");\n    require(!Address.isContract(_recipient), \"recipient of cannot be contract\");\n    require(isKnownRoot(_root), \"Cannot find your merkle root\");\n    require(verifier.verifyProof(_proof, [uint256(_root), uint256(_nullifierHash), uint256(_recipient), uint256(_relayer), _relayerFee, _refund]), \"Invalid withdraw proof\");\n    verifier.verifyNullifier(_nullifierHash);\n    uint256 td = tokenDenomination;\n    if (td > 0) {\n        safeTransfer(token, _recipient, td);\n    }\n    updateBlockReward();\n    uint256 relayerFee = 0;\n    uint256 M87Deno = getAccumulateM87().div(numOfShares);\n    if (M87Deno > 0) {\n        accumulateM87 -= M87Deno;\n        safeTransfer(M87Token, _recipient, M87Deno);\n    }\n    uint256 cd = coinDenomination - feeToCollectAmount;\n    if (_relayerFee > cd) {\n        _relayerFee = cd;\n    }\n    if (_relayerFee > 0) {\n        (bool success,) = _relayer.call.value(_relayerFee)(\"\");\n        require(success, \"failed to send relayer fee\");\n        cd -= _relayerFee;\n    }\n    if (cd > 0) {\n        (bool success,) = _recipient.call.value(cd)(\"\");\n        require(success, \"failed to withdraw coin\");\n    }\n    numOfShares -= 1;\n    sendRewardtoPool();\n    emit Withdrawal(_recipient, _nullifierHash, _relayer, M87Deno, relayerFee);\n}",
        "vulnerability": "Incorrect reentrancy protection",
        "reason": "The function withdraw is marked as nonReentrant, but the use of the call.value() pattern before checking the reentrancy guard allows reentrancy attacks. An attacker can exploit this to recursively call withdraw and deplete the contract's funds.",
        "file_name": "0x1963737af12d3649f6f319fb64af2aa29f7256b7.sol"
    },
    {
        "function_name": "deposit",
        "code": "function deposit(bytes32 _commitment) external payable nonReentrant returns (bytes32 commitment, uint32 insertedIndex, uint256 blocktime, uint256 M87Deno, uint256 fee){\n    require(!commitments[_commitment], \"The commitment has been submitted\");\n    require(msg.value >= coinDenomination, \"insufficient coin amount\");\n    commitment = _commitment;\n    blocktime = block.timestamp;\n    uint256 refund = msg.value - coinDenomination;\n    insertedIndex = _insert(_commitment);\n    commitments[_commitment] = true;\n    M87Deno = M87Denomination();\n    fee = anonymityFee;\n    uint256 td = tokenDenomination;\n    if (td > 0) {\n        token.safeTransferFrom(msg.sender, address(this), td);\n    }\n    accumulateM87 += M87Deno;\n    numOfShares += 1;\n    if (refund > 0) {\n        (bool success, ) = msg.sender.call.value(refund)(\"\");\n        require(success, \"failed to refund\");\n    }\n    collectedFee += feeToCollectAmount;\n    if(collectedFee > overMinEth) {\n        swapAndShare();\n    } else {\n        sendRewardtoPool();\n    }\n    updateBlockReward();\n    emit Deposit(_commitment, insertedIndex, block.timestamp, M87Deno, fee);\n}",
        "vulnerability": "Unsafe use of call.value()",
        "reason": "The deposit function uses call.value() for refunding ether, which is unsafe as it forwards all available gas, enabling reentrancy attacks. An attacker can exploit this by triggering a reentrant call during refund, possibly draining the contract.",
        "file_name": "0x1963737af12d3649f6f319fb64af2aa29f7256b7.sol"
    },
    {
        "function_name": "swapAndShare",
        "code": "function swapAndShare() private {\n    require(collectedFee > 0, \"Insufficient Amount\");\n    uint256 initialBalance = M87Token.balanceOf(address(this));\n    address[] memory path = new address[](2);\n    path[0] = uniswapV2Router.WETH();\n    path[1] = address(M87Token);\n    uniswapV2Router.swapExactETHForTokensSupportingFeeOnTransferTokens.value(collectedFee) (\n        0, path, address(this), block.timestamp.mul(2)\n    );\n    collectedFee = 0;\n    uint256 newBalance = M87Token.balanceOf(address(this)).sub(initialBalance);\n    if( shareOfReward[0] > 0 ) {\n        M87Token.transfer( address(0x000000000000000000000000000000000000dEaD), newBalance.mul(shareOfReward[0]).div(100) );\n    }\n    if( poolList[0] != address(0) && shareOfReward[1] > 0 && poolList[0] != address(this) ) {\n        rewardAmounts[0] = rewardAmounts[0].add( newBalance.mul(shareOfReward[1]).div(100) );\n    }\n    if( poolList[1] != address(0) && shareOfReward[2] > 0 && poolList[1] != address(this) ) {\n        rewardAmounts[1] = rewardAmounts[1].add( newBalance.mul(shareOfReward[2]).div(100) );\n    }\n    if( poolList[2] != address(0) && shareOfReward[3] > 0 && poolList[2] != address(this) ) {\n        rewardAmounts[2] = rewardAmounts[2].add( newBalance.mul(shareOfReward[3]).div(100) );\n    }\n    if( poolList[3] != address(0) && shareOfReward[4] > 0 && poolList[3] != address(this) ) {\n        rewardAmounts[3] = rewardAmounts[3].add( newBalance.mul(shareOfReward[4]).div(100) );\n    }\n}",
        "vulnerability": "Potential slippage in token swap",
        "reason": "The swapAndShare function uses swapExactETHForTokensSupportingFeeOnTransferTokens without specifying a minimum amount of tokens expected. This can result in significant slippage, potentially allowing an attacker to manipulate the token price and drain value from the contract.",
        "file_name": "0x1963737af12d3649f6f319fb64af2aa29f7256b7.sol"
    }
]