[
    {
        "function_name": "distributeDividends",
        "code": "function distributeDividends() public payable override { require(totalSupply() > 0); if (msg.value > 0) { magnifiedDividendPerShare = magnifiedDividendPerShare.add( (msg.value).mul(magnitude) / totalSupply() ); emit DividendsDistributed(msg.sender, msg.value); totalDividendsDistributed = totalDividendsDistributed.add( msg.value ); } }",
        "vulnerability": "Denial of Service (DoS) by blocking dividend distribution",
        "reason": "Since the function `distributeDividends` relies on a valid total supply, an attacker could potentially reduce the total supply to zero by transferring tokens to the dead address, thus blocking the dividend distribution altogether.",
        "file_name": "0x13c34380e14c47cdd089d466396e53f8a0a24442.sol"
    },
    {
        "function_name": "swapAndLiquify",
        "code": "function swapAndLiquify(uint256 tokens) private { uint256 half = tokens.div(2); uint256 otherHalf = tokens.sub(half); uint256 initialBalance = address(this).balance; swapTokensForEth(half); uint256 newBalance = address(this).balance.sub(initialBalance); addLiquidity(otherHalf, newBalance); emit SwapAndLiquify(half, newBalance, otherHalf); }",
        "vulnerability": "Potential front-running attack",
        "reason": "The swapAndLiquify function can be front-run by observing the mempool and executing transactions to benefit from the price impact caused by the liquidity addition, leading to a loss for the contract.",
        "file_name": "0x13c34380e14c47cdd089d466396e53f8a0a24442.sol"
    },
    {
        "function_name": "_transfer",
        "code": "function _transfer(address from, address to, uint256 amount) internal override { require(from != address(0), \"ERC20: transfer from the zero address\"); require(to != address(0), \"ERC20: transfer to the zero address\"); uint256 RewardsFee; uint256 deadFees; uint256 marketingFees; uint256 liquidityFee; uint256 devFees; if (!canTransferBeforeTradingIsEnabled[from]) { require(tradingEnabled, \"Trading has not yet been enabled\"); } if (amount == 0) { super._transfer(from, to, 0); return; } if (to == DEAD) { super._transfer(from, to, amount); _totalSupply = _totalSupply.sub(amount); return; } else if (!swapping && !_isExcludedFromFees[from] && !_isExcludedFromFees[to]) { bool isSelling = automatedMarketMakerPairs[to]; bool isBuying = automatedMarketMakerPairs[from]; if (!isBuying && !isSelling) { if (!_isExcludedFromFees[from] && !_isExcludedFromFees[to]) { uint256 tFees = amount.mul(transferFee).div(100); amount = amount.sub(tFees); super._transfer(from, address(this), tFees); super._transfer(from, to, amount); dividendTracker.setBalance(from, balanceOf(from)); dividendTracker.setBalance(to, balanceOf(to)); return; } else { super._transfer(from, to, amount); dividendTracker.setBalance(from, balanceOf(from)); dividendTracker.setBalance(to, balanceOf(to)); return; } } else if (isSelling) { RewardsFee = sellRewardsFee; deadFees = sellDeadFees; marketingFees = sellMarketingFees; liquidityFee = sellLiquidityFee; devFees = sellDevFee; if (limitsInEffect) { require(block.timestamp >= _holderLastTransferTimestamp[tx.origin] + cooldowntimer, \"cooldown period active\"); require(amount <= maxTX,\"above max transaction limit\"); _holderLastTransferTimestamp[tx.origin] = block.timestamp; } } else if (isBuying) { RewardsFee = buyRewardsFee; deadFees = buyDeadFees; marketingFees = buyMarketingFees; liquidityFee = buyLiquidityFee; devFees = buyDevFee; if (limitsInEffect) { require(block.timestamp > launchtimestamp + delay,\"you shall not pass\"); require(tx.gasprice <= gasPriceLimit,\"Gas price exceeds limit.\"); require(_holderLastTransferBlock[tx.origin] != block.number,\"Too many TX in block\"); require(amount <= maxTX,\"above max transaction limit\"); _holderLastTransferBlock[tx.origin] = block.number; } uint256 contractBalanceRecipient = balanceOf(to); require(contractBalanceRecipient + amount <= maxWallet,\"Exceeds maximum wallet token amount.\" ); } uint256 totalFees = RewardsFee.add(liquidityFee + marketingFees + devFees); uint256 contractTokenBalance = balanceOf(address(this)); bool canSwap = contractTokenBalance >= swapTokensAtAmount; if (canSwap && isSelling) { swapping = true; if (swapAndLiquifyEnabled && liquidityFee > 0 && totalBuyFees > 0) { uint256 totalBuySell = buyAmount.add(sellAmount); uint256 swapAmountBought = contractTokenBalance.mul(buyAmount).div(totalBuySell); uint256 swapAmountSold = contractTokenBalance.mul(sellAmount).div(totalBuySell); uint256 swapBuyTokens = swapAmountBought.mul(liquidityFee).div(totalBuyFees); uint256 swapSellTokens = swapAmountSold.mul(liquidityFee).div(totalSellFees); uint256 swapTokens = swapSellTokens.add(swapBuyTokens); swapAndLiquify(swapTokens); } uint256 remainingBalance = balanceOf(address(this)); swapAndSendDividends(remainingBalance); buyAmount = 1; sellAmount = 1; swapping = false; } uint256 fees = amount.mul(totalFees).div(100); uint256 burntokens; if (deadFees > 0) { burntokens = amount.mul(deadFees) / 100; super._transfer(from, DEAD, burntokens); _totalSupply = _totalSupply.sub(burntokens); } amount = amount.sub(fees + burntokens); if (isSelling) { sellAmount = sellAmount.add(fees); } else { buyAmount = buyAmount.add(fees); } super._transfer(from, address(this), fees); uint256 gas = gasForProcessing; try dividendTracker.process(gas) returns (uint256 iterations, uint256 claims, uint256 lastProcessedIndex) { emit ProcessedDividendTracker(iterations, claims, lastProcessedIndex, true, gas, tx.origin); } catch {} } super._transfer(from, to, amount); dividendTracker.setBalance(from, balanceOf(from)); dividendTracker.setBalance(to, balanceOf(to)); }",
        "vulnerability": "Excessive Gas Fees and Reentrancy",
        "reason": "The function `_transfer` contains multiple external calls, including dividend processing, which could lead to excessive gas consumption and potential reentrancy issues, especially if the dividend processing is manipulated by an attacker.",
        "file_name": "0x13c34380e14c47cdd089d466396e53f8a0a24442.sol"
    }
]