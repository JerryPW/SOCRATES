[
    {
        "function_name": "swapAndLiquify",
        "code": "function swapAndLiquify(uint256 tokens) private {\n    uint256 marketFeeFull = tokens.mul(marketFee).div(100);\n    uint256 tokensAfterFee = tokens - marketFeeFull;\n    uint256 initHalf = tokens.div(2);\n    uint256 half = tokensAfterFee.div(2);\n    uint256 otherHalf = tokensAfterFee.sub(half);\n    uint256 initialBalance = address(this).balance;\n    swapTokensForEth(initHalf);\n    uint256 newBalance = address(this).balance.sub(initialBalance);\n    uint256 marketFeeBalance = newBalance.mul(marketFee).div(100);\n    uint256 finalBalance = newBalance - marketFeeBalance;\n    uint256 finalHalf = otherHalf;\n    if(marketTokenAddressForFee != address(0)){\n        swapEthForTokens(marketFeeBalance, marketTokenAddressForFee, marketAddress);\n    }else{\n        (bool sent,) = marketAddress.call{value: marketFeeBalance}(\"\");\n    }\n    addLiquidity(finalHalf, finalBalance);\n    emit SwapAndLiquify(half, finalBalance, otherHalf);\n}",
        "vulnerability": "Reentrancy Vulnerability",
        "reason": "The function `swapAndLiquify` handles Ether and calls external contracts, specifically `marketAddress.call{value: marketFeeBalance}(\"\")`, which can lead to a reentrancy attack. An attacker can exploit this by re-entering the contract during the Ether transfer and potentially manipulate contract state or drain funds.",
        "file_name": "0x0aabf9daefcd484405479d2748cbaedb53c33d87.sol"
    },
    {
        "function_name": "_transfer",
        "code": "function _transfer(\n    address from,\n    address to,\n    uint256 amount\n) internal override {\n    require(!_isBlacklisted[from], \"Blacklisted address cannot transfer!\");\n    require(!_isBlacklisted[to], \"Blacklisted address cannot transfer!\");\n    require(from != address(0), \"ERC20: transfer to the zero address\");\n    require(to != address(0), \"ERC20: transfer to the zero address\");\n    bool tradingIsEnabled = getTradingIsEnabled();\n    if(!tradingIsEnabled) {\n        require(canTransferBeforeTradingIsEnabled[from], \"MRFROG: This account cannot send tokens until trading is enabled\");\n    }\n    if(amount == 0) {\n        super._transfer(from, to, 0);\n        return;\n    }\n    bool buyOrSell = false;\n    if ( from != owner() && to != owner() && to != address(0) && to != address(0xdead) && to != uniswapV2Pair && automatedMarketMakerPairs[from] ) {\n        require( amount <= maxBuyTranscationAmount, \"Transfer amount exceeds the maxTxAmount.\" );\n        uint256 contractBalanceRecepient = balanceOf(to);\n        require( contractBalanceRecepient + amount <= _maxWalletToken, \"Exceeds maximum wallet token amount.\" );\n        previousMarketFee = marketFee;\n        previousTokenRewardsFee = tokenRewardsFee;\n        previousLiquidityFee = liquidityFee;\n        previousTotalFees = totalFees;\n        marketFee = buyMarketFee;\n        tokenRewardsFee = buyTokenRewardsFee;\n        liquidityFee = buyLiquidityFee;\n        totalFees = buyTotalFees;\n        buyOrSell = true;\n    }\n    if( !swapping && tradingIsEnabled && automatedMarketMakerPairs[to] && from != address(uniswapV2Router) && !_isExcludedFromFees[to] ) {\n        require(amount <= maxSellTransactionAmount, \"Sell transfer amount exceeds the maxSellTransactionAmount.\");\n        previousMarketFee = marketFee;\n        previousTokenRewardsFee = tokenRewardsFee;\n        previousLiquidityFee = liquidityFee;\n        previousTotalFees = totalFees;\n        marketFee = sellMarketFee;\n        tokenRewardsFee = sellTokenRewardsFee;\n        liquidityFee = sellLiquidityFee;\n        totalFees = sellTotalFees;\n        buyOrSell = true;\n    }\n    uint256 contractTokenBalance = balanceOf(address(this));\n    bool canSwap = contractTokenBalance >= swapTokensAtAmount;\n    if( tradingIsEnabled && canSwap && !swapping && !automatedMarketMakerPairs[from] && from != burnAddress && to != burnAddress ) {\n        swapping = true;\n        uint256 dividendAmount = swapTokensAtAmount.mul(tokenRewardsFee).div(100);\n        uint256 adminAmount = swapTokensAtAmount.sub(dividendAmount);\n        swapAndLiquify(adminAmount);\n        swapAndSendDividends(dividendAmount);\n        swapping = false;\n    }\n    bool takeFee = tradingIsEnabled && !swapping;\n    if(_isExcludedFromFees[from] || _isExcludedFromFees[to]) {\n        takeFee = false;\n    }\n    if(takeFee) {\n        uint256 fees = amount.mul(totalFees).div(100);\n        amount = amount.sub(fees);\n        super._transfer(from, address(this), fees);\n    }\n    super._transfer(from, to, amount);\n    restoreFees();\n    try dividendTracker.setBalance(payable(from), balanceOf(from)) {} catch {}\n    try dividendTracker.setBalance(payable(to), balanceOf(to)) {} catch {}\n    bool canDividend = block.timestamp >= processDividendTime;\n    if(!swapping && canDividend) {\n        uint256 gas = gasForProcessing;\n        processDividendTime += dividendTime;\n        try dividendTracker.process(gas) returns (uint256 iterations, uint256 claims, uint256 lastProcessedIndex) {\n            emit ProcessedDividendTracker(iterations, claims, lastProcessedIndex, true, gas, tx.origin);\n        } catch { }\n    }\n}",
        "vulnerability": "Block Gas Limit",
        "reason": "The `_transfer` function performs multiple operations that can consume a substantial amount of gas. Specifically, the function includes a loop that processes dividend payouts, which can lead to exceeding the block gas limit if there are a large number of token holders. This could result in transactions being unable to complete, leading to a denial of service.",
        "file_name": "0x0aabf9daefcd484405479d2748cbaedb53c33d87.sol"
    },
    {
        "function_name": "claim",
        "code": "function claim() external {\n    dividendTracker.processAccount(msg.sender, false);\n}",
        "vulnerability": "Lack of Access Control",
        "reason": "The `claim` function does not implement any access control mechanisms, allowing any user to call `processAccount`. This can lead to potential misuse where users can trigger dividend processing on accounts, possibly impacting the intended dividend distribution logic or incurring unnecessary gas costs.",
        "file_name": "0x0aabf9daefcd484405479d2748cbaedb53c33d87.sol"
    }
]