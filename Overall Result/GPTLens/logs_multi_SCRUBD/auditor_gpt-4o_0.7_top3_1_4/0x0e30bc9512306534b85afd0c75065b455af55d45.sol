[
    {
        "function_name": "setFeesPercent",
        "code": "function setFeesPercent(uint256 distributionFee, uint256 liquidityFee, uint256 marketingFee, uint256 burnFee,uint256 devFee ) external onlyOwner() { require(distributionFee + liquidityFee + marketingFee + burnFee + devFee <= 900, \"Total tax should not more than 90% (900/1000)\"); _taxFee = distributionFee; _liquidityFee = liquidityFee; _marketingFee = marketingFee; _burnFee = burnFee; _devFee = devFee; _marketingDevLiquidNBurnFee = _liquidityFee + _marketingFee + _burnFee + _devFee; }",
        "vulnerability": "Excessive Fee Vulnerability",
        "reason": "The function allows the owner to set the total fees up to 90% (900/1000), which can be deemed excessive and could deter users from using the token as it significantly reduces the value transferred during transactions. High fees can also lead to liquidity issues and diminish user trust.",
        "file_name": "0x0e30bc9512306534b85afd0c75065b455af55d45.sol"
    },
    {
        "function_name": "_transfer",
        "code": "function _transfer( address from, address to, uint256 amount ) private { require(from != address(0), \"ERC20: transfer from the zero address\"); require(to != address(0), \"ERC20: transfer to the zero address\"); require(amount > 0, \"Transfer amount must be greater than zero\"); require(_isBlacklistWallet[from] == false, \"You're in blacklist\"); if(limitsEnabled){ if(!isExcludedFromMax[to] && !_isExcludedFromFee[to] && from != owner() && to != owner() && to != uniswapV2Pair ){ require(amount <= maxBuyLimit,\"Over the Max buy\"); require(amount.add(balanceOf(to)) <= maxWallet); } if ( from != owner() && to != owner() && to != address(0) && to != address(0xdead) && !inSwapAndLiquify ){ if(!trading){ require(_isExcludedFromFee[from] || _isExcludedFromFee[to] || isinwl[to], \"Trading is not active.\"); } if (transferDelayEnabled){ if (to != owner() && to != address(uniswapV2Router) && to != address(uniswapV2Pair)){ require(_holderLastTransferTimestamp[tx.origin] < block.number, \"_transfer:: Transfer Delay enabled. Only one purchase per block allowed.\"); _holderLastTransferTimestamp[tx.origin] = block.number; } } } } uint256 swapAmount = accumulatedForLiquid.add(accumulatedForMarketing).add(accumulatedForDev); bool overMinTokenBalance = swapAmount >= numTokensSellToAddToLiquidity; if ( !inSwapAndLiquify && from != uniswapV2Pair && swapAndLiquifyEnabled && overMinTokenBalance ) { swapAndLiquify(); } bool takeFee = true; if(_isExcludedFromFee[from] || _isExcludedFromFee[to] || (from != uniswapV2Pair && to != uniswapV2Pair)){ takeFee = false; } _tokenTransfer(from,to,amount,takeFee); }",
        "vulnerability": "Blacklist and Trading Restrictions",
        "reason": "The function includes conditions that restrict trading based on a blacklist and whether trading is enabled. Although this might be intended as a protective measure, it could also be exploited by malicious actors if they gain control over the contract's owner functions, potentially blocking users from transferring their tokens or participating in the market. This can lead to centralization concerns.",
        "file_name": "0x0e30bc9512306534b85afd0c75065b455af55d45.sol"
    },
    {
        "function_name": "swapAndLiquify",
        "code": "function swapAndLiquify() private lockTheSwap { uint256 totalcontracttokens = accumulatedForDev.add(accumulatedForLiquid).add(accumulatedForMarketing); uint256 remainForDev = 0; uint256 remainForMarketing = 0; uint256 remainForLiq = 0; if (routerselllimit && totalcontracttokens > numTokensSellToAddToLiquidity.mul(20)){ remainForDev = accumulatedForDev.div(20).mul(19); accumulatedForDev = accumulatedForDev.sub(remainForDev); remainForMarketing = accumulatedForMarketing.div(20).mul(19); accumulatedForMarketing = accumulatedForMarketing.sub(remainForMarketing); remainForLiq = accumulatedForLiquid.div(20).mul(19); accumulatedForLiquid = accumulatedForLiquid.sub(remainForLiq); } uint256 half = accumulatedForLiquid .div(2); uint256 otherHalf = accumulatedForLiquid.sub(half); uint256 swapAmount = half.add(accumulatedForMarketing).add(accumulatedForDev); uint256 initialBalance = address(this).balance; swapTokensForEth(swapAmount); uint256 delta = address(this).balance.sub(initialBalance); uint256 ethLiquid = delta.mul(half).div(swapAmount); uint256 ethMarketing = delta.mul(accumulatedForMarketing).div(swapAmount); uint256 ethDev = delta.sub(ethLiquid).sub(ethMarketing); uint256 ethpromo = ethMarketing.mul(2).div(6); uint256 ethmarketers = ethMarketing.mul(4).div(6); if(ethLiquid > 0){ addLiquidity(otherHalf, ethLiquid); emit SwapAndLiquify(half, ethLiquid, otherHalf); } if(ethMarketing > 0){ payable(marketingWallet).transfer(ethmarketers); payable(promotionWallet).transfer(ethpromo); } if(ethDev > 0){ payable(devWallet).transfer(ethDev); } accumulatedForLiquid = remainForLiq; accumulatedForMarketing = remainForMarketing; accumulatedForDev = remainForDev; }",
        "vulnerability": "Funds Handling and Gas Limitations",
        "reason": "The function handles a significant amount of token swaps and ETH transfers, which can hit block gas limits, especially when tokens are accumulated over time. This could result in failed transactions when trying to execute `swapAndLiquify` if the gas required exceeds the block limit. It also depends on external calls to Uniswap, which can lead to reentrancy issues if not properly guarded.",
        "file_name": "0x0e30bc9512306534b85afd0c75065b455af55d45.sol"
    }
]