[
    {
        "function_name": "transferFrom",
        "code": "function transferFrom( address from, address to, uint256 value ) public returns (bool) { _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value); _transfer(from, to, value); return true; }",
        "vulnerability": "Missing balance check before transfer",
        "reason": "The function does not check if the 'from' address has sufficient balance before attempting a transfer. An attacker could exploit this by setting a high allowance and then forcing the contract to try and transfer more tokens than the 'from' address owns, leading to unexpected failures or blocked tokens.",
        "file_name": "0x1f42f986f9ef31d6ef787565b211bce0eb877bcc.sol"
    },
    {
        "function_name": "setInfo",
        "code": "function setInfo(address _lastHero, uint256 _deposit) public { require(address(BearsContract) == msg.sender || address(BullsContract) == msg.sender); if (address(BearsContract) == msg.sender) { require(depositBulls[currentRound][_lastHero] == 0, \"You are already in bulls team\"); if (depositBears[currentRound][_lastHero] == 0) countOfBears++; totalSupplyOfBears = totalSupplyOfBears.add(_deposit.mul(90).div(100)); depositBears[currentRound][_lastHero] = depositBears[currentRound][_lastHero].add(_deposit.mul(90).div(100)); } if (address(BullsContract) == msg.sender) { require(depositBears[currentRound][_lastHero] == 0, \"You are already in bears team\"); if (depositBulls[currentRound][_lastHero] == 0) countOfBulls++; totalSupplyOfBulls = totalSupplyOfBulls.add(_deposit.mul(90).div(100)); depositBulls[currentRound][_lastHero] = depositBulls[currentRound][_lastHero].add(_deposit.mul(90).div(100)); } lastHero = _lastHero; if (currentDeadline.add(120) <= lastDeadline) { currentDeadline = currentDeadline.add(120); } else { currentDeadline = lastDeadline; } jackPot += _deposit.mul(10).div(100); calculateProbability(); }",
        "vulnerability": "Reentrancy vulnerability",
        "reason": "The function updates state variables after calling other functions like 'calculateProbability'. If any of these functions or the contracts they interact with are malicious, they could re-enter 'setInfo' and alter the state in an unintended manner, compromising the integrity of the data.",
        "file_name": "0x1f42f986f9ef31d6ef787565b211bce0eb877bcc.sol"
    },
    {
        "function_name": "getWinners",
        "code": "function getWinners() public { require(winner == 0 && !getState()); uint256 seed1 = address(this).balance; uint256 seed2 = totalSupplyOfBulls; uint256 seed3 = totalSupplyOfBears; uint256 seed4 = totalGWSupplyOfBulls; uint256 seed5 = totalGWSupplyOfBulls; uint256 seed6 = block.difficulty; uint256 seed7 = block.timestamp; bytes32 randomHash = keccak256(abi.encodePacked(seed1, seed2, seed3, seed4, seed5, seed6, seed7)); uint randomNumber = uint(randomHash); if (randomNumber == 0){ randomNumber = 1; } uint winningNumber = randomNumber % 10000; if (1 <= winningNumber && winningNumber <= probabilityOfBears){ winner = 1; } if (probabilityOfBears < winningNumber && winningNumber <= 10000){ winner = 2; } if (GameWaveContract.balanceOf(address(BullsContract)) > 0) GameWaveContract.transferFrom( address(BullsContract), address(this), GameWaveContract.balanceOf(address(BullsContract)) ); if (GameWaveContract.balanceOf(address(BearsContract)) > 0) GameWaveContract.transferFrom( address(BearsContract), address(this), GameWaveContract.balanceOf(address(BearsContract)) ); lastTotalSupplyOfBulls = totalSupplyOfBulls; lastTotalSupplyOfBears = totalSupplyOfBears; lastTotalGWSupplyOfBears = totalGWSupplyOfBears; lastTotalGWSupplyOfBulls = totalGWSupplyOfBulls; lastRoundHero = lastHero; lastJackPot = jackPot; lastWinner = winner; lastCountOfBears = countOfBears; lastCountOfBulls = countOfBulls; lastWithdrawn = withdrawn; lastWithdrawnGW = withdrawnGW; if (lastBalance > lastWithdrawn){ remainder = lastBalance.sub(lastWithdrawn); address(GameWaveContract).transfer(remainder); } lastBalance = lastTotalSupplyOfBears.add(lastTotalSupplyOfBulls).add(lastJackPot); if (lastBalanceGW > lastWithdrawnGW){ remainderGW = lastBalanceGW.sub(lastWithdrawnGW); tokenReturn = (totalGWSupplyOfBears.add(totalGWSupplyOfBulls)).mul(20).div(100).add(remainderGW); GameWaveContract.transfer(crowdSale, tokenReturn); } lastBalanceGW = GameWaveContract.balanceOf(address(this)); totalSupplyOfBulls = 0; totalSupplyOfBears = 0; totalGWSupplyOfBulls = 0; totalGWSupplyOfBears = 0; remainder = 0; remainderGW = 0; jackPot = 0; withdrawn = 0; winner = 0; withdrawnGW = 0; countOfBears = 0; countOfBulls = 0; probabilityOfBulls = 0; probabilityOfBears = 0; _setRoundTime(defaultCurrentDeadlineInHours, defaultLastDeadlineInHours); currentRound++; }",
        "vulnerability": "Predictable randomness",
        "reason": "The pseudo-random number generation uses block attributes like timestamp and difficulty, which can be influenced by miners. This predictability can be exploited by attackers to manipulate the outcome of the winner selection process.",
        "file_name": "0x1f42f986f9ef31d6ef787565b211bce0eb877bcc.sol"
    }
]