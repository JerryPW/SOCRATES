[
    {
        "function_name": "openTrading",
        "code": "function openTrading() external onlyOwner { isOpen = true; _d(); }",
        "vulnerability": "Potential high fee manipulation",
        "reason": "The openTrading function allows the contract owner to call the internal _d() function, which sets the treasuryFeeBPS to 9800 and liquidityFeeBPS to 0, resulting in a totalFeeBPS of 9800. This means that 98% of each transaction could be taken as fees. This high fee can be detrimental to users and can be exploited by the owner to extract significant value from the contract.",
        "file_name": "0x01886cabb4a19a89fad686810f2ee60459452cf3.sol"
    },
    {
        "function_name": "_transfer",
        "code": "function _transfer( address sender, address recipient, uint256 amount ) internal { require( isOpen || sender == owner() || recipient == owner() || _notDegens[sender] || _notDegens[recipient], \"Not Open\" ); require(!isDegenlisted[sender], \"DGA: Sender is degenlisted\"); require(!isDegenlisted[recipient], \"DGA: Recipient is degenlisted\"); require(sender != address(0), \"DGA: transfer from the zero address\"); require(recipient != address(0), \"DGA: transfer to the zero address\"); uint256 _maxTxAmount = (totalSupply() * maxTxBPS) / 10000; uint256 _maxWallet = (totalSupply() * maxWalletBPS) / 10000; require( amount <= _maxTxAmount || _isExcludedFromMaxTx[sender], \"TX Limit Exceeded\" ); if ( sender != owner() && recipient != address(this) && recipient != address(DEAD) && recipient != uniswapV2Pair ) { uint256 currentBalance = balanceOf(recipient); require( _isExcludedFromMaxWallet[recipient] || (currentBalance + amount <= _maxWallet));} uint256 senderBalance = _balances[sender]; require( senderBalance >= amount, \"DGA: transfer amount exceeds balance\" ); uint256 contractTokenBalance = balanceOf(address(this)); uint256 contractNativeBalance = address(this).balance; bool canSwap = contractTokenBalance >= swapTokensAtAmount; if ( swapEnabled && canSwap && !swapping && !automatedMarketMakerPairs[sender] && sender != address(uniswapV2Router) && sender != owner() && recipient != owner() ) { swapping = true; if (!swapAllToken) { contractTokenBalance = swapTokensAtAmount; } _executeSwap(contractTokenBalance, contractNativeBalance); lastSwapTime = block.timestamp; swapping = false; } bool takeFee; if ( sender == address(uniswapV2Pair) || recipient == address(uniswapV2Pair) ) { takeFee = true; } if (_isExcludedFromFees[sender] || _isExcludedFromFees[recipient]) { takeFee = false; } if (swapping || !taxEnabled) { takeFee = false; } if (takeFee) { uint256 jeetMulitplier = (recipient == uniswapV2Pair && jeetTaxEnabled) ? 2 : 1; uint256 fees = (amount * totalFeeBPS) / 10000; uint256 jeetFees = fees * jeetMulitplier; amount -= jeetFees; _executeTransfer(sender, address(this), jeetFees); } _executeTransfer(sender, recipient, amount); dividendTracker.setBalance(payable(sender), balanceOf(sender)); dividendTracker.setBalance(payable(recipient), balanceOf(recipient)); }",
        "vulnerability": "Insufficient access control on trading",
        "reason": "The _transfer function checks if the trading is open or if the sender or recipient is the owner or in the _notDegens list. This means that the owner or privileged addresses can bypass the trading restrictions, potentially allowing them to execute trades before the market is open to the public. This could lead to unfair advantages and market manipulation.",
        "file_name": "0x01886cabb4a19a89fad686810f2ee60459452cf3.sol"
    },
    {
        "function_name": "createSweepablePair",
        "code": "function createSweepablePair(IEmpireFactory _factory) external onlyOwner() { PairType pairType = address(this) < uniswapV2Router.WETH() ? PairType.SweepableToken1 : PairType.SweepableToken0; sweepablePair = _factory.createPair(uniswapV2Router.WETH(), address(this), pairType, 0); }",
        "vulnerability": "Potentially malicious pair creation",
        "reason": "The createSweepablePair function allows the contract owner to create a sweepable pair with an external factory contract. This could be exploited to create a pair that behaves unexpectedly or maliciously, such as by allowing the owner to sweep tokens from the pair without proper checks. The lack of detailed checks or restrictions on the created pair type and the immediate assignment to sweepablePair can lead to unexpected behaviors or security risks.",
        "file_name": "0x01886cabb4a19a89fad686810f2ee60459452cf3.sol"
    }
]