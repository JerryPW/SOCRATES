[
    {
        "function_name": "withdraw",
        "code": "function withdraw(address contractAddress) public nonReentrant { require(contractAddressRecord[contractAddress] == true); require(walletAddressRecord[msg.sender] == true); address _customerAddress = msg.sender; uint256 _dividends = myDividends(contractAddress, false); balanceLedger[_customerAddress][contractAddress].payOut += (int256) (_dividends * magnitude); _dividends += balanceLedger[_customerAddress][contractAddress].referralBalance; balanceLedger[_customerAddress][contractAddress].referralBalance = 0; if (contractAddress == address(0)){ payable(address(_customerAddress)).transfer(_dividends); } else{ ERC20(contractAddress).transfer(_customerAddress,_dividends); } emit onWithdraw(_customerAddress, contractAddress, _dividends); }",
        "vulnerability": "Missing zero-check for dividends",
        "reason": "The function does not check whether the dividends are greater than zero before attempting to transfer them. This could result in unnecessary gas consumption or erroneous behavior when the dividend amount is zero.",
        "file_name": "0x0e82b29a77a53880dd4ee8326cfea9b4c68db638.sol"
    },
    {
        "function_name": "sell",
        "code": "function sell(address contractAddress, uint256 _amountOfCollate) public { require(contractAddressRecord[contractAddress] == true); require(walletAddressRecord[msg.sender] == true); address _customerAddress = msg.sender; require(_amountOfCollate <= balanceLedger[_customerAddress][contractAddress].tokenBalance); uint256 _collates = _amountOfCollate; uint256 _tokens = collateralToToken_(contractAddress, _collates); uint256 _dividends = SafeMath.div(_tokens, dividendFee); uint256 _taxedToken = SafeMath.sub(_tokens, _dividends); tokenLedger[contractAddress].supply = SafeMath.sub(tokenLedger[contractAddress].supply, _collates); balanceLedger[_customerAddress][contractAddress].tokenBalance = SafeMath.sub(balanceLedger[_customerAddress][contractAddress].tokenBalance, _collates); int256 _updatedPayouts = (int256) (tokenLedger[contractAddress].dividend * _collates + (_taxedToken * magnitude)); balanceLedger[_customerAddress][contractAddress].payOut -= _updatedPayouts; if (tokenLedger[contractAddress].supply > 0) { tokenLedger[contractAddress].dividend = SafeMath.add(tokenLedger[contractAddress].dividend, (_dividends * magnitude) / tokenLedger[contractAddress].supply); } emit onSell(_customerAddress, contractAddress, _taxedToken, _collates); }",
        "vulnerability": "Incorrect dividend calculation and update",
        "reason": "The calculation of dividends and their subsequent update in the token ledger is incorrect when the supply of tokens is zero. This could potentially lead to division by zero errors or incorrect dividend calculations, resulting in inconsistent or erroneous financial states.",
        "file_name": "0x0e82b29a77a53880dd4ee8326cfea9b4c68db638.sol"
    },
    {
        "function_name": "purchaseCollate",
        "code": "function purchaseCollate(address contractAddress, uint256 _incomingToken, address _referredBy) internal returns(uint256) { address _customerAddress = msg.sender; uint256 _undividedDividends = SafeMath.div(_incomingToken, dividendFee); uint256 _referralBonus = SafeMath.div(_undividedDividends, 3); uint256 _dividends = SafeMath.sub(_undividedDividends, _referralBonus); uint256 _taxedToken = SafeMath.sub(_incomingToken, _undividedDividends); uint256 _amountOfCollate = tokentoCollateral_(contractAddress,_taxedToken); uint256 _fee = _dividends * magnitude; require(_amountOfCollate > 0 && (SafeMath.add(_amountOfCollate,tokenLedger[contractAddress].supply) > tokenLedger[contractAddress].supply)); if( _referredBy != address(0) && _referredBy != _customerAddress && walletAddressRecord[_referredBy] == true ){ balanceLedger[_referredBy][contractAddress].referralBalance = SafeMath.add(balanceLedger[_referredBy][contractAddress].referralBalance, _referralBonus); } else { _dividends = SafeMath.add(_dividends, _referralBonus); _fee = _dividends * magnitude; } if(tokenLedger[contractAddress].supply > 0){ tokenLedger[contractAddress].supply = SafeMath.add(tokenLedger[contractAddress].supply, _amountOfCollate); tokenLedger[contractAddress].dividend += (_dividends * magnitude / (tokenLedger[contractAddress].supply)); _fee = _fee - (_fee-(_amountOfCollate * (_dividends * magnitude / (tokenLedger[contractAddress].supply)))); } else { tokenLedger[contractAddress].supply = _amountOfCollate; } balanceLedger[_customerAddress][contractAddress].tokenBalance = SafeMath.add(balanceLedger[_customerAddress][contractAddress].tokenBalance, _amountOfCollate); int256 _updatedPayouts = (int256) ((tokenLedger[contractAddress].dividend * _amountOfCollate) - _fee); balanceLedger[_customerAddress][contractAddress].payOut += _updatedPayouts; emit onPurchase(_customerAddress, contractAddress, _incomingToken, _amountOfCollate, _referredBy); return _amountOfCollate; }",
        "vulnerability": "Reentrancy vulnerability",
        "reason": "Although the contract uses a nonReentrant modifier, the purchaseCollate function performs multiple state updates before any external calls. If the nonReentrant modifier fails or is bypassed, the function may be susceptible to reentrancy attacks, enabling attackers to manipulate balances and dividends.",
        "file_name": "0x0e82b29a77a53880dd4ee8326cfea9b4c68db638.sol"
    }
]