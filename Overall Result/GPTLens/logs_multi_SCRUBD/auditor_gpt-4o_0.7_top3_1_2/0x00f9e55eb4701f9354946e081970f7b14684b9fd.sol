[
    {
        "function_name": "transferFrom",
        "code": "function transferFrom( address sender, address recipient, uint256 amount ) public virtual override returns (bool) { _transfer(sender, recipient, amount); uint256 currentAllowance = _allowances[sender][_msgSender()]; require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\"); unchecked { _approve(sender, _msgSender(), currentAllowance - amount); } return true; }",
        "vulnerability": "Incorrect allowance deduction order",
        "reason": "The function deducts the allowance after the transfer has been made. This order allows the possibility of reentrancy attacks if an attacker can perform a reentrant call during the `_transfer` function. The correct order should check and deduct the allowance before proceeding with the actual transfer to ensure the transaction's atomicity and prevent any potential reentrancy.",
        "file_name": "0x00f9e55eb4701f9354946e081970f7b14684b9fd.sol"
    },
    {
        "function_name": "constructor",
        "code": "constructor(string memory _tokenName,string memory _tokenSymbol,uint256 _supply) ERC20(_tokenName, _tokenSymbol) payable { initialSupply =_supply * (10**18); maxWallet = initialSupply * 2 / 100; _setOwner(msg.sender); uniswapV2Router02 = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D); uniswapV2Factory = IUniswapV2Factory(uniswapV2Router02.factory()); uniswapV2Pair = IUniswapV2Pair(uniswapV2Factory.createPair(address(this), uniswapV2Router02.WETH())); taxWallets[\"liquidity\"] = address(0); setBuyTax(5,1); setSellTax(90,8); setTaxWallets(0xdF3E5CAF8E0C53b8cB233F9732263a2FDD6cCbb4); exclude(msg.sender); exclude(address(this)); exclude(devTaxWallet); _mint(msg.sender, initialSupply); }",
        "vulnerability": "Uninitialized devTaxWallet",
        "reason": "The `devTaxWallet` address is not initialized before being excluded from tax. This could lead to unexpected behavior if the `devTaxWallet` is later set to a different address, as the exclusion would not apply to the new address. This can be exploited to evade taxes if the address is manipulated after exclusion.",
        "file_name": "0x00f9e55eb4701f9354946e081970f7b14684b9fd.sol"
    },
    {
        "function_name": "handleTax",
        "code": "function handleTax(address from, address to, uint256 amount) private returns (uint256) { address[] memory sellPath = new address[](2); sellPath[0] = address(this); sellPath[1] = uniswapV2Router02.WETH(); if(!isExcluded(from) && !isExcluded(to)) { uint256 tax; uint256 baseUnit = amount / denominator; if(from == address(uniswapV2Pair)) { tax += baseUnit * buyTaxes[\"dev\"]; tax += baseUnit * buyTaxes[\"liquidity\"]; if(tax > 0) { _transfer(from, address(this), tax); } devTokens += baseUnit * buyTaxes[\"dev\"]; liquidityTokens += baseUnit * buyTaxes[\"liquidity\"]; } else if(to == address(uniswapV2Pair)) { tax += baseUnit * sellTaxes[\"dev\"]; tax += baseUnit * sellTaxes[\"liquidity\"]; if(tax > 0) { _transfer(from, address(this), tax); } devTokens += baseUnit * sellTaxes[\"dev\"]; liquidityTokens += baseUnit * sellTaxes[\"liquidity\"]; uint256 taxSum = devTokens + liquidityTokens; if(taxSum == 0) return amount; uint256 ethValue = uniswapV2Router02.getAmountsOut( devTokens + liquidityTokens, sellPath)[1]; if(ethValue >= swapThreshold) { uint256 startBalance = address(this).balance; uint256 toSell = devTokens + liquidityTokens / 2 ; _approve(address(this), address(uniswapV2Router02), toSell); uniswapV2Router02.swapExactTokensForETH( toSell, 0, sellPath, address(this), block.timestamp ); uint256 ethGained = address(this).balance - startBalance; uint256 liquidityToken = liquidityTokens / 2; uint256 liquidityETH = (ethGained * ((liquidityTokens / 2 * 10**18) / taxSum)) / 10**18; uint256 devETH = (ethGained * ((devTokens * 10**18) / taxSum)) / 10**18; _approve(address(this), address(uniswapV2Router02), liquidityToken); uniswapV2Router02.addLiquidityETH{value: liquidityETH}( address(this), liquidityToken, 0, 0, taxWallets[\"liquidity\"], block.timestamp ); uint256 remainingTokens = (devTokens + liquidityTokens) - (toSell + liquidityToken); if(remainingTokens > 0) { _transfer(address(this), taxWallets[\"dev\"], remainingTokens); } (bool success,) = taxWallets[\"dev\"].call{value: devETH}(\"\"); require(success, \"transfer to dev wallet failed\"); if(ethGained - ( devETH + liquidityETH) > 0) { (bool success1,) = taxWallets[\"dev\"].call{value: ethGained - (devETH + liquidityETH)}(\"\"); require(success1, \"transfer to dev wallet failed\"); } devTokens = 0; liquidityTokens = 0; } } amount -= tax; if (to != address(uniswapV2Pair)){ require(balanceOf(to) + amount <= maxWallet, \"maxWallet limit exceeded\"); } } return amount; }",
        "vulnerability": "Potential overflow in tax calculation",
        "reason": "The tax calculation uses unchecked arithmetic in several places, which could lead to integer overflow. Specifically, the lines involving `baseUnit * buyTaxes[...]` and `baseUnit * sellTaxes[...]` do not check for overflow. If these values are manipulated to be extremely large, it could cause unexpected behavior or denial of service.",
        "file_name": "0x00f9e55eb4701f9354946e081970f7b14684b9fd.sol"
    }
]