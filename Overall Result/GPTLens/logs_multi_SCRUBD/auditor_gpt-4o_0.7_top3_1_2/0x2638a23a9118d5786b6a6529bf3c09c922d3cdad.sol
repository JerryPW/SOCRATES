[
    {
        "function_name": "claimETH",
        "code": "function claimETH(address addr) private{\n    require(!_isWithdrawing);\n    _isWithdrawing=true;\n    uint256 amount;\n    if(isExcludedFromStaking(addr)){\n        amount=toBePaid[addr];\n        toBePaid[addr]=0;\n    } else{\n        uint256 newAmount=_newDividentsOf(addr);\n        alreadyPaidShares[addr] = profitPerShare * _balances[addr];\n        amount=toBePaid[addr]+newAmount;\n        toBePaid[addr]=0;\n    }\n    if(amount==0){\n        _isWithdrawing=false;\n        return;\n    }\n    totalPayouts+=amount;\n    address[] memory path = new address[](2);\n    path[0] = _uniswapv2Router.WETH();\n    path[1] = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\n    _uniswapv2Router.swapExactETHForTokensSupportingFeeOnTransferTokens{value: amount}(\n        0,\n        path,\n        addr,\n        block.timestamp\n    );\n    emit OnWithdrawETH(amount, addr);\n    _isWithdrawing=false;\n}",
        "vulnerability": "Reentrancy vulnerability",
        "reason": "The function allows for state changes before an external call is made. Specifically, ETH is sent to another contract via `swapExactETHForTokensSupportingFeeOnTransferTokens`, which can result in reentrancy if the external contract calls back into this function before `_isWithdrawing` is set to `false`.",
        "file_name": "0x2638a23a9118d5786b6a6529bf3c09c922d3cdad.sol"
    },
    {
        "function_name": "_taxedTransfer",
        "code": "function _taxedTransfer(address sender, address recipient, uint256 amount,bool isBuy,bool isSell) private{\n    uint256 recipientBalance = _balances[recipient];\n    uint256 senderBalance = _balances[sender];\n    require(senderBalance >= amount, \"Transfer exceeds balance\");\n    uint8 tax;\n    if(isSell){\n        if(!_excludedFromSellLock.contains(sender)){\n            require(_sellLock[sender]<=block.timestamp||sellLockDisabled,\"Seller in sellLock\");\n            _sellLock[sender]=block.timestamp+sellLockTime;\n        }\n        require(amount<=sellLimit,\"Dump protection\");\n        require(_isBlacklisted.contains(sender) == false, \"Address blacklisted!\");\n        if (block.timestamp <= tradingEnabledAt + autoBanTime && enableAutoBlacklist == 1) {\n            _isBlacklisted.add(sender);\n            emit antiBotBan(sender);\n        }\n        tax=_sellTax;\n    } else if(isBuy){\n        if(!_excludedFromBuyLock.contains(recipient)){\n            require(_buyLock[recipient]<=block.timestamp||buyLockDisabled,\"Buyer in buyLock\");\n            _buyLock[recipient]=block.timestamp+buyLockTime;\n        }\n        require(recipientBalance+amount<=balanceLimit,\"whale protection\");\n        require(amount <= MaxBuy,\"Tx amount exceeding max buy amount\");\n        require(_isBlacklisted.contains(recipient) == false, \"Address blacklisted!\");\n        if (block.timestamp <= tradingEnabledAt + autoBanTime && enableAutoBlacklist == 1) {\n            _isBlacklisted.add(recipient);\n            emit antiBotBan(recipient);\n        }\n        tax=_buyTax;\n    } else {\n        if(amount<=10**(_decimals)) claimETH(sender);\n        require(recipientBalance+amount<=balanceLimit,\"whale protection\");\n        if(!_excludedFromSellLock.contains(sender)) require(_sellLock[sender]<=block.timestamp||sellLockDisabled,\"Sender in Lock\");\n        require(_isBlacklisted.contains(sender) == false, \"Sender address blacklisted!\");\n        require(_isBlacklisted.contains(recipient) == false, \"Recipient address blacklisted!\");\n        if (block.timestamp <= tradingEnabledAt + autoBanTime && enableAutoBlacklist == 1) {\n            _isBlacklisted.add(sender);\n            emit antiBotBan(sender);\n        }\n        tax=_transferTax;\n    }\n    if((sender!=_uniswapv2PairAddress)&&(!manualConversion)&&(!_isSwappingContractModifier)&&isSell) _swapContractToken();\n    uint256 tokensToBeBurnt=_calculateFee(amount, tax, _burnTax);\n    uint256 contractToken=_calculateFee(amount, tax, _stakingTax+_liquidityTax);\n    uint256 taxedAmount=amount-(tokensToBeBurnt + contractToken);\n    _removeToken(sender,amount);\n    _balances[address(this)] += contractToken;\n    _circulatingSupply-=tokensToBeBurnt;\n    _addToken(recipient, taxedAmount);\n    emit Transfer(sender,recipient,taxedAmount);\n}",
        "vulnerability": "Improper blacklist implementation",
        "reason": "This function adds users to a blacklist based on certain conditions. However, blacklisting logic can be easily bypassed by sophisticated attackers. Furthermore, automatically blacklisting users based on trading conditions could result in legitimate users being unfairly blacklisted, leading to potential loss of funds or market manipulation.",
        "file_name": "0x2638a23a9118d5786b6a6529bf3c09c922d3cdad.sol"
    },
    {
        "function_name": "REL",
        "code": "function REL() public onlyOwner {\n    require(block.timestamp >= _liquidityUnlockTime, \"Not yet unlocked\");\n    IUniswapV2ERC20 liquidityToken = IUniswapV2ERC20(_liquidityTokenAddress);\n    uint256 amount = liquidityToken.balanceOf(address(this));\n    liquidityToken.transfer(Development, amount);\n}",
        "vulnerability": "Liquidity theft vulnerability",
        "reason": "The function allows the owner to transfer all liquidity tokens to a specific address once the liquidity lock time has expired. This is a significant risk as it allows the contract owner to potentially drain liquidity from the pool, leading to a loss of funds for liquidity providers.",
        "file_name": "0x2638a23a9118d5786b6a6529bf3c09c922d3cdad.sol"
    }
]