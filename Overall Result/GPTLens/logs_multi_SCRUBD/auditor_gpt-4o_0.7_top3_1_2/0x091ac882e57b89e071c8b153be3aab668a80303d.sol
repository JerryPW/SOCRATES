[
    {
        "function_name": "transfer",
        "code": "function transfer(address recipient, uint256 amount) public returns (bool) {\n    if (msg.sender != address(_town)) {\n        if (_town.checkProposal(recipient) == true) {\n            super.transfer(address(_town), amount);\n            return _town.voteOn(recipient, amount);\n        }\n    }\n    if (recipient != address(_town)) {\n        bool found = false;\n        for (uint i = 0; i < _holders.length; ++i) {\n            if (_holders[i] == recipient) {\n                found = true;\n                break;\n            }\n        }\n        if (found == false) {\n            _holders.push(recipient);\n        }\n    }\n    if (balanceOf(address(msg.sender)) == amount && msg.sender != address(_town)) {\n        uint i = 0;\n        for (; i < _holders.length; ++i) {\n            if (_holders[i] == address(msg.sender)) {\n                break;\n            }\n        }\n        if (i < (_holders.length - 1)) {\n            _holders[i] = _holders[_holders.length - 1];\n            delete _holders[_holders.length - 1];\n            _holders.length--;\n        }\n    }\n    return super.transfer(recipient, amount);\n}",
        "vulnerability": "Reentrancy vulnerability",
        "reason": "The function calls external contract functions (checkProposal and voteOn) before updating the _holders array. If the external calls lead to a reentrant call back to this transfer function, it could manipulate the _holders state, potentially allowing unauthorized transfers or modifications.",
        "file_name": "0x091ac882e57b89e071c8b153be3aab668a80303d.sol"
    },
    {
        "function_name": "claimExternalTokens",
        "code": "function claimExternalTokens(address holder) public returns (bool) {\n    address[] memory externalTokensForHolder = _ledgerExternalTokensAddresses[holder];\n    if (externalTokensForHolder.length > 0) {\n        for (uint256 i = externalTokensForHolder.length - 1; ; --i) {\n            ERC20(externalTokensForHolder[i]).transfer(holder, _townHoldersLedger[holder][externalTokensForHolder[i]]);\n            delete _townHoldersLedger[holder][externalTokensForHolder[i]];\n            delete _ledgerExternalTokensAddresses[holder][i];\n            _ledgerExternalTokensAddresses[holder].length--;\n            if (i == 0) break;\n        }\n    }\n    return true;\n}",
        "vulnerability": "Gas limit and out-of-gas vulnerability",
        "reason": "This function iterates over an array that can grow arbitrarily large, potentially causing the transaction to run out of gas and fail. This could prevent holders from claiming their tokens if the array length exceeds the gas limit for a transaction.",
        "file_name": "0x091ac882e57b89e071c8b153be3aab668a80303d.sol"
    },
    {
        "function_name": "getTownTokens",
        "code": "function getTownTokens(address holder) public payable returns (bool) {\n    require(holder != address(0), \"holder address cannot be null\");\n    uint256 amount = msg.value;\n    uint256 tokenAmount = IWantTakeTokensToAmount(amount);\n    uint256 rate = currentRate();\n    if (_transactionsCount < _durationOfMinTokenGetAmount && tokenAmount < _minTokenGetAmount) {\n        return false;\n    }\n    if (tokenAmount >= _maxTokenGetAmount) {\n        tokenAmount = _maxTokenGetAmount;\n        uint256 change = amount.sub(_maxTokenGetAmount.mul(rate).div(10 ** 18));\n        msg.sender.transfer(change);\n        amount = amount.sub(change);\n    }\n    if (_token.balanceOf(address(this)) >= tokenAmount) {\n        TransactionsInfo memory transactionsHistory = TransactionsInfo(rate, tokenAmount);\n        _token.transfer(holder, tokenAmount);\n        _historyTransactions[holder].push(transactionsHistory);\n        _transactionsCount = _transactionsCount.add(1);\n    } else {\n        if (_token.balanceOf(address(this)) > 0) {\n            uint256 tokenBalance = _token.balanceOf(address(this));\n            _token.transfer(holder, tokenBalance);\n            TransactionsInfo memory transactionsHistory = TransactionsInfo(rate, tokenBalance);\n            _historyTransactions[holder].push(transactionsHistory);\n            tokenAmount = tokenAmount.sub(tokenBalance);\n        }\n        TransactionsInfo memory transactionsInfo = TransactionsInfo(rate, tokenAmount);\n        TownTokenRequest memory tokenRequest = TownTokenRequest(holder, transactionsInfo);\n        _queueTownTokenRequests.push(tokenRequest);\n    }\n    for (uint256 i = 0; i < _remunerationsQueue.length; ++i) {\n        if (_remunerationsQueue[i]._priority == 1) {\n            if (_remunerationsQueue[i]._amount > amount) {\n                _remunerationsQueue[i]._address.transfer(_remunerationsQueue[i]._amount);\n                amount = amount.sub(_remunerationsQueue[i]._amount);\n                delete _remunerationsQueue[i];\n                for (uint j = i + 1; j < _remunerationsQueue.length; ++j) {\n                    _remunerationsQueue[j - 1] = _remunerationsQueue[j];\n                }\n                _remunerationsQueue.length--;\n            } else {\n                _remunerationsQueue[i]._address.transfer(amount);\n                _remunerationsQueue[i]._amount = _remunerationsQueue[i]._amount.sub(amount);\n                break;\n            }\n        }\n    }\n    for (uint256 i = 0; i < _remunerationsQueue.length; ++i) {\n        if (_remunerationsQueue[i]._amount > amount) {\n            _remunerationsQueue[i]._address.transfer(_remunerationsQueue[i]._amount);\n            amount = amount.sub(_remunerationsQueue[i]._amount);\n            delete _remunerationsQueue[i];\n            for (uint j = i + 1; j < _remunerationsQueue.length; ++j) {\n                _remunerationsQueue[j - 1] = _remunerationsQueue[j];\n            }\n            _remunerationsQueue.length--;\n        } else {\n            _remunerationsQueue[i]._address.transfer(amount);\n            _remunerationsQueue[i]._amount = _remunerationsQueue[i]._amount.sub(amount);\n            break;\n        }\n    }\n    return true;\n}",
        "vulnerability": "Integer underflow/overflow vulnerability",
        "reason": "The function contains arithmetic operations that are not protected against integer underflow and overflow, such as `amount.sub(change)`. If unchecked, this could lead to unintended behavior or exploitation, especially considering the use of msg.value and token balances.",
        "file_name": "0x091ac882e57b89e071c8b153be3aab668a80303d.sol"
    }
]