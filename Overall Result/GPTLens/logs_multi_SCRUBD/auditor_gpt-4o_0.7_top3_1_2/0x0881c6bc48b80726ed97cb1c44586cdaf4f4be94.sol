[
    {
        "function_name": "SwapPct",
        "code": "function SwapPct(uint256 pct) public { uint256 balance = (balanceOf(address(this)) * pct) / 100; if(balance > 0) { uint256 tokensForLP = (balance * LPDistributionPct)/100; uint256 tokensForLiquidity = tokensForLP / 2; uint256 tokensToSwap = balance - tokensForLiquidity; swapTokensForETH(tokensToSwap); uint256 contractBalance = address(this).balance; uint256 devShare = (contractBalance * DevDistributionPct)/100; uint256 mktShare = (contractBalance * MarketingDistributionPct)/100; DevAddress.transfer(devShare); MarketingAddress.transfer(mktShare); uint256 eth = address(this).balance; UniswapV2Router.addLiquidityETH{value: address(this).balance}( address(this), tokensForLiquidity, 0, 0, DevAddress, block.timestamp ); AccumulatedFeeForDistribution.LiquidityFee = 0; AccumulatedFeeForDistribution.DevFee = 0; AccumulatedFeeForDistribution.MarketingFee = 0; TotalSwapped += tokensForLiquidity; emit LiquidityAdded(tokensForLiquidity, eth); } }",
        "vulnerability": "Potential Reentrancy in swap and liquidity functions",
        "reason": "The SwapPct function transfers ETH to external addresses before re-entering into the UniswapV2Router's addLiquidityETH function. If an attacker controls the DevAddress or MarketingAddress, they could potentially perform a reentrancy attack by executing code upon receiving the ETH transfer. This could lead to undesired behavior such as draining the contract balance.",
        "file_name": "0x0881c6bc48b80726ed97cb1c44586cdaf4f4be94.sol"
    },
    {
        "function_name": "_transfer",
        "code": "function _transfer(address from, address to, uint256 amount) private { if (liqAddedBlockNumber == 0 && AutomatedMarketMakerPairs[to]) { liqAddedBlockNumber = block.number; } require(from != address(0), \"ERC20: transfer from the zero address\"); require(to != address(0), \"ERC20: transfer to the zero address\"); require(!IsBot(from), \"ERC20: address blacklisted (bot)\"); require(amount > 0, \"Transfer amount must be greater than zero\"); require(amount <= balanceOf(from), \"You are trying to transfer more than your balance\"); bool takeFee = !(IsWalletExcludedFromFee(from) || IsWalletExcludedFromFee(to)); if (takeFee) { if (AutomatedMarketMakerPairs[from]) { if (block.number < liqAddedBlockNumber + blocksToWait) { MarkBot(to, true); } AppliedRatesPercentage = BuyingTaxes; require(amount <= HardCapBuy, \"amount must be <= maxTxAmountBuy\" ); } else { AppliedRatesPercentage = SellTaxes; require(amount <= HardCapSell,\"amount must be <= maxTxAmountSell\"); } } if ( !InSwap && !AutomatedMarketMakerPairs[from] && SwapEnabled && from != owner() && to != owner() && from != address(UniswapV2Router) ) { swapAndLiquify(); } _tokenTransfer(from, to, amount, takeFee); }",
        "vulnerability": "Potential Denial of Service (DoS) via Bot Marking",
        "reason": "The _transfer function marks an address as a bot if a transaction occurs within a specific number of blocks after liquidity is added. An attacker could potentially exploit this by front-running the liquidity addition, causing legitimate users to be marked as bots and preventing them from participating in token transfers. This can lead to a Denial of Service (DoS) attack on legitimate users.",
        "file_name": "0x0881c6bc48b80726ed97cb1c44586cdaf4f4be94.sol"
    },
    {
        "function_name": "swapAndLiquify",
        "code": "function swapAndLiquify() private swaping { if(balanceOf(address(this)) > 0) { uint256 tokensToSwap = AccumulatedFeeForDistribution.LiquidityFee / 2; uint256 tokensForLiquidity = AccumulatedFeeForDistribution.LiquidityFee - tokensToSwap; swapTokensForETH(AccumulatedFeeForDistribution.DevFee + AccumulatedFeeForDistribution.MarketingFee + tokensToSwap); uint256 contractBalance = address(this).balance; uint256 devShare = (contractBalance* DevDistributionPct)/100; uint256 mktShare = (contractBalance * MarketingDistributionPct)/100; DevAddress.transfer(devShare); MarketingAddress.transfer(mktShare); uint256 eth = address(this).balance; UniswapV2Router.addLiquidityETH{value: address(this).balance}( address(this), tokensForLiquidity, 0, 0, DevAddress, block.timestamp ); AccumulatedFeeForDistribution.LiquidityFee = 0; AccumulatedFeeForDistribution.DevFee = 0; AccumulatedFeeForDistribution.MarketingFee = 0; TotalSwapped += tokensForLiquidity; emit LiquidityAdded(tokensForLiquidity, eth); } }",
        "vulnerability": "Reentrancy Risk in swapAndLiquify",
        "reason": "Similar to the SwapPct function, the swapAndLiquify function transfers ETH to two external addresses (DevAddress and MarketingAddress) before executing the addLiquidityETH function. If the DevAddress or MarketingAddress is compromised, or if the external address is able to execute code on receiving ETH, it could lead to a reentrancy attack, potentially draining the contract's ETH balance.",
        "file_name": "0x0881c6bc48b80726ed97cb1c44586cdaf4f4be94.sol"
    }
]