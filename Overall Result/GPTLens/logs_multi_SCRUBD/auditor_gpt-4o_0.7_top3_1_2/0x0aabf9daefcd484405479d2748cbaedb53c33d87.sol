[
    {
        "function_name": "swapAndLiquify",
        "code": "function swapAndLiquify(uint256 tokens) private {\n    uint256 marketFeeFull = tokens.mul(marketFee).div(100);\n    uint256 tokensAfterFee = tokens - marketFeeFull;\n    uint256 initHalf = tokens.div(2);\n    uint256 half = tokensAfterFee.div(2);\n    uint256 otherHalf = tokensAfterFee.sub(half);\n    uint256 initialBalance = address(this).balance;\n    swapTokensForEth(initHalf);\n    uint256 newBalance = address(this).balance.sub(initialBalance);\n    uint256 marketFeeBalance = newBalance.mul(marketFee).div(100);\n    uint256 finalBalance = newBalance - marketFeeBalance;\n    uint256 finalHalf = otherHalf;\n    if(marketTokenAddressForFee != address(0)){\n        swapEthForTokens(marketFeeBalance, marketTokenAddressForFee, marketAddress);\n    }else{\n        (bool sent,) = marketAddress.call{value: marketFeeBalance}(\"\");\n    }\n    addLiquidity(finalHalf, finalBalance);\n    emit SwapAndLiquify(half, finalBalance, otherHalf);\n}",
        "vulnerability": "Potential reentrancy through external calls",
        "reason": "This function involves multiple external calls (e.g., swapTokensForEth, swapEthForTokens) and Ether transfers. If any of these external calls are made to untrusted contracts, they could potentially exploit reentrancy vulnerabilities by calling back into this contract, especially since the state changes (like updating balances) are made after these external calls.",
        "file_name": "0x0aabf9daefcd484405479d2748cbaedb53c33d87.sol"
    },
    {
        "function_name": "_transfer",
        "code": "function _transfer( address from, address to, uint256 amount ) internal override { require(!_isBlacklisted[from], \"Blacklisted address cannot transfer!\"); require(!_isBlacklisted[to], \"Blacklisted address cannot transfer!\"); require(from != address(0), \"ERC20: transfer to the zero address\"); require(to != address(0), \"ERC20: transfer to the zero address\"); bool tradingIsEnabled = getTradingIsEnabled(); if(!tradingIsEnabled) { require(canTransferBeforeTradingIsEnabled[from], \"MRFROG: This account cannot send tokens until trading is enabled\"); } if(amount == 0) { super._transfer(from, to, 0); return; } bool buyOrSell = false; if ( from != owner() && to != owner() && to != address(0) && to != address(0xdead) && to != uniswapV2Pair && automatedMarketMakerPairs[from] ) { require( amount <= maxBuyTranscationAmount, \"Transfer amount exceeds the maxTxAmount.\" ); uint256 contractBalanceRecepient = balanceOf(to); require( contractBalanceRecepient + amount <= _maxWalletToken, \"Exceeds maximum wallet token amount.\" ); previousMarketFee = marketFee; previousTokenRewardsFee = tokenRewardsFee; previousLiquidityFee = liquidityFee; previousTotalFees = totalFees; marketFee = buyMarketFee; tokenRewardsFee = buyTokenRewardsFee; liquidityFee = buyLiquidityFee; totalFees = buyTotalFees; buyOrSell = true; } if( !swapping && tradingIsEnabled && automatedMarketMakerPairs[to] && from != address(uniswapV2Router) && !_isExcludedFromFees[to] ) { require(amount <= maxSellTransactionAmount, \"Sell transfer amount exceeds the maxSellTransactionAmount.\"); previousMarketFee = marketFee; previousTokenRewardsFee = tokenRewardsFee; previousLiquidityFee = liquidityFee; previousTotalFees = totalFees; marketFee = sellMarketFee; tokenRewardsFee = sellTokenRewardsFee; liquidityFee = sellLiquidityFee; totalFees = sellTotalFees; buyOrSell = true; } uint256 contractTokenBalance = balanceOf(address(this)); bool canSwap = contractTokenBalance >= swapTokensAtAmount; if( tradingIsEnabled && canSwap && !swapping && !automatedMarketMakerPairs[from] && from != burnAddress && to != burnAddress ) { swapping = true; uint256 dividendAmount = swapTokensAtAmount.mul(tokenRewardsFee).div(100); uint256 adminAmount = swapTokensAtAmount.sub(dividendAmount); swapAndLiquify(adminAmount); swapAndSendDividends(dividendAmount); swapping = false; } bool takeFee = tradingIsEnabled && !swapping; if(_isExcludedFromFees[from] || _isExcludedFromFees[to]) { takeFee = false; } if(takeFee) { uint256 fees = amount.mul(totalFees).div(100); amount = amount.sub(fees); super._transfer(from, address(this), fees); } super._transfer(from, to, amount); restoreFees(); try dividendTracker.setBalance(payable(from), balanceOf(from)) {} catch {} try dividendTracker.setBalance(payable(to), balanceOf(to)) {} catch {} bool canDividend = block.timestamp >= processDividendTime; if(!swapping && canDividend) { uint256 gas = gasForProcessing; processDividendTime += dividendTime; try dividendTracker.process(gas) returns (uint256 iterations, uint256 claims, uint256 lastProcessedIndex) { emit ProcessedDividendTracker(iterations, claims, lastProcessedIndex, true, gas, tx.origin); } catch { } } }",
        "vulnerability": "Potential denial of service through blacklisting",
        "reason": "The _transfer function checks if either the sender or receiver is blacklisted and reverts if they are. This allows the contract owner to freeze any address from transferring tokens by blacklisting them, which can be used maliciously or result in unexpected freezing of legitimate users.",
        "file_name": "0x0aabf9daefcd484405479d2748cbaedb53c33d87.sol"
    },
    {
        "function_name": "_withdrawDividendOfUser",
        "code": "function _withdrawDividendOfUser(address payable user) internal returns (uint256) { uint256 _withdrawableDividend = withdrawableDividendOf(user); if (_withdrawableDividend > 0) { withdrawnDividends[user] = withdrawnDividends[user].add(_withdrawableDividend); bool success = false; if(DividendToken == address(0)){ (bool sent, bytes memory data) = user.call{value: _withdrawableDividend}(\"\"); success = sent; emit DividendWithdrawn(user, _withdrawableDividend, DividendToken); }else{ success = IERC20(DividendToken).transfer(user, _withdrawableDividend); emit DividendWithdrawn(user, _withdrawableDividend, DividendToken); } if(!success) { withdrawnDividends[user] = withdrawnDividends[user].sub(_withdrawableDividend); return 0; } return _withdrawableDividend; } return 0; }",
        "vulnerability": "Reentrancy vulnerability through Ether transfer",
        "reason": "The _withdrawDividendOfUser function transfers Ether directly to a user via a low-level call. This makes the function susceptible to reentrancy attacks if the user is a contract that can call back into this contract before the state is updated, potentially allowing for multiple withdrawals.",
        "file_name": "0x0aabf9daefcd484405479d2748cbaedb53c33d87.sol"
    }
]