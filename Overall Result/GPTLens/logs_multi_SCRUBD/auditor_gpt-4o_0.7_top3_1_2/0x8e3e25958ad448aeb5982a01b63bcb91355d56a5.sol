[
    {
        "function_name": "function () payable external",
        "code": "function () payable external { require(check[msg.sender] == false); require(msg.value < 1000000000000000001 wei); uint amount = msg.value; balanceOf[msg.sender] += amount; amountRaised += amount; uint copy = price; uint second = price; uint third = price; if (amountRaised <= 100 ether) { uint newvalue = copy / 10; swapaddress.transfer(msg.sender, amount / newvalue); } else if (amountRaised <= 2100 ether) { uint secondvalue = second / 2; swapaddress.transfer(msg.sender, amount / secondvalue); } else { swapaddress.transfer(msg.sender, amount / third); } beneficiary.send(msg.value); emit FundTransfer(msg.sender, amount, true); check[msg.sender] = true; }",
        "vulnerability": "Reentrancy",
        "reason": "The function sends Ether before updating the state variable `check[msg.sender]`. An attacker can exploit this by re-entering the contract and repeatedly calling the function, allowing them to drain the contract\u2019s funds before the `check` mapping is updated to prevent further contributions.",
        "file_name": "0x8e3e25958ad448aeb5982a01b63bcb91355d56a5.sol"
    },
    {
        "function_name": "function () payable external",
        "code": "function () payable external { require(check[msg.sender] == false); require(msg.value < 1000000000000000001 wei); uint amount = msg.value; balanceOf[msg.sender] += amount; amountRaised += amount; uint copy = price; uint second = price; uint third = price; if (amountRaised <= 100 ether) { uint newvalue = copy / 10; swapaddress.transfer(msg.sender, amount / newvalue); } else if (amountRaised <= 2100 ether) { uint secondvalue = second / 2; swapaddress.transfer(msg.sender, amount / secondvalue); } else { swapaddress.transfer(msg.sender, amount / third); } beneficiary.send(msg.value); emit FundTransfer(msg.sender, amount, true); check[msg.sender] = true; }",
        "vulnerability": "Unchecked External Call",
        "reason": "The `beneficiary.send(msg.value);` call does not check the return value for success. If the transfer fails, the transaction proceeds without reverting, potentially leaving the contract in an inconsistent state, where funds are deducted but not actually transferred.",
        "file_name": "0x8e3e25958ad448aeb5982a01b63bcb91355d56a5.sol"
    },
    {
        "function_name": "function () payable external",
        "code": "function () payable external { require(check[msg.sender] == false); require(msg.value < 1000000000000000001 wei); uint amount = msg.value; balanceOf[msg.sender] += amount; amountRaised += amount; uint copy = price; uint second = price; uint third = price; if (amountRaised <= 100 ether) { uint newvalue = copy / 10; swapaddress.transfer(msg.sender, amount / newvalue); } else if (amountRaised <= 2100 ether) { uint secondvalue = second / 2; swapaddress.transfer(msg.sender, amount / secondvalue); } else { swapaddress.transfer(msg.sender, amount / third); } beneficiary.send(msg.value); emit FundTransfer(msg.sender, amount, true); check[msg.sender] = true; }",
        "vulnerability": "Incorrect Token Calculation",
        "reason": "The calculation for the number of tokens to be transferred is based on `amount / newvalue`, `amount / secondvalue`, or `amount / third`. This might not align with the actual token decimals or pricing logic, potentially leading to incorrect token distribution, benefiting the attacker with more tokens than intended.",
        "file_name": "0x8e3e25958ad448aeb5982a01b63bcb91355d56a5.sol"
    }
]