[
    {
        "function_name": "withdraw",
        "vulnerability": "Improper nullifier handling",
        "criticism": "The reasoning is correct. The function does not store the used `_nullifierHash`, which is crucial for preventing double spending. This oversight allows an attacker to reuse the same proof to withdraw multiple times, effectively stealing funds from the contract. The severity is high because it directly impacts the integrity of the contract's funds. The profitability is also high, as an attacker can repeatedly exploit this to drain funds.",
        "correctness": 9,
        "severity": 8,
        "profitability": 8,
        "reason": "The `withdraw` function does not store the used `_nullifierHash` to prevent double spending. Without storing used nullifiers, an attacker could potentially reuse the same proof to withdraw multiple times, thus stealing funds from the contract.",
        "code": "function withdraw(bytes calldata _proof, bytes32 _root, bytes32 _nullifierHash, address payable _recipient, address payable _relayer, uint256 _relayerFee, uint256 _refund) external payable nonReentrant { require(_refund == 0, \"refund is not zero\"); require(!Address.isContract(_recipient), \"recipient of cannot be contract\"); require(isKnownRoot(_root), \"Cannot find your merkle root\"); require(verifier.verifyProof(_proof, [uint256(_root), uint256(_nullifierHash), uint256(_recipient), uint256(_relayer), _relayerFee, _refund]), \"Invalid withdraw proof\"); verifier.verifyNullifier(_nullifierHash); uint256 td = tokenDenomination; if (td > 0) { safeTransfer(token, _recipient, td); } updateBlockReward(); uint256 relayerFee = 0; uint256 M87Deno = getAccumulateM87().div(numOfShares); if (M87Deno > 0) { accumulateM87 -= M87Deno; safeTransfer(M87Token, _recipient, M87Deno); } uint256 cd = coinDenomination - feeToCollectAmount; if (_relayerFee > cd) { _relayerFee = cd; } if (_relayerFee > 0) { (bool success,) = _relayer.call.value(_relayerFee)(\"\"); require(success, \"failed to send relayer fee\"); cd -= _relayerFee; } if (cd > 0) { (bool success,) = _recipient.call.value(cd)(\"\"); require(success, \"failed to withdraw coin\"); } numOfShares -= 1; sendRewardtoPool(); emit Withdrawal(_recipient, _nullifierHash, _relayer, M87Deno, relayerFee); }",
        "file_name": "0x1963737af12d3649f6f319fb64af2aa29f7256b7.sol"
    },
    {
        "function_name": "swapAndShare",
        "vulnerability": "Reentrancy through Uniswap call",
        "criticism": "The reasoning is partially correct. While the function does make an external call to the Uniswap contract and updates the state variable `collectedFee` afterward, the use of `nonReentrant` modifier in the calling function `deposit` mitigates reentrancy risks. However, if `swapAndShare` is called from another function without reentrancy protection, it could be vulnerable. The severity is moderate due to the potential for reentrancy if not properly protected. The profitability is moderate, as an attacker could potentially manipulate the state to their advantage.",
        "correctness": 6,
        "severity": 5,
        "profitability": 5,
        "reason": "The function `swapAndShare` calls an external contract (`uniswapV2Router.swapExactETHForTokensSupportingFeeOnTransferTokens`) and then updates the state variable `collectedFee`. This allows for a potential reentrancy attack, as the state update happens after the external call. If an attacker can influence the Uniswap contract to reenter the current contract, they may manipulate the current state and drain funds.",
        "code": "function swapAndShare() private { require(collectedFee > 0, \"Insufficient Amount\"); uint256 initialBalance = M87Token.balanceOf(address(this)); address[] memory path = new address[](2); path[0] = uniswapV2Router.WETH(); path[1] = address(M87Token); uniswapV2Router.swapExactETHForTokensSupportingFeeOnTransferTokens.value(collectedFee) ( 0, path, address(this), block.timestamp.mul(2) ); collectedFee = 0; uint256 newBalance = M87Token.balanceOf(address(this)).sub(initialBalance); if( shareOfReward[0] > 0 ) { M87Token.transfer( address(0x000000000000000000000000000000000000dEaD), newBalance.mul(shareOfReward[0]).div(100) ); } if( poolList[0] != address(0) && shareOfReward[1] > 0 && poolList[0] != address(this) ) { rewardAmounts[0] = rewardAmounts[0].add( newBalance.mul(shareOfReward[1]).div(100) ); } if( poolList[1] != address(0) && shareOfReward[2] > 0 && poolList[1] != address(this) ) { rewardAmounts[1] = rewardAmounts[1].add( newBalance.mul(shareOfReward[2]).div(100) ); } if( poolList[2] != address(0) && shareOfReward[3] > 0 && poolList[2] != address(this) ) { rewardAmounts[2] = rewardAmounts[2].add( newBalance.mul(shareOfReward[3]).div(100) ); } if( poolList[3] != address(0) && shareOfReward[4] > 0 && poolList[3] != address(this) ) { rewardAmounts[3] = rewardAmounts[3].add( newBalance.mul(shareOfReward[4]).div(100) ); } }",
        "file_name": "0x1963737af12d3649f6f319fb64af2aa29f7256b7.sol"
    },
    {
        "function_name": "deposit",
        "vulnerability": "Improper refund handling",
        "criticism": "The reasoning is correct. The function uses a low-level call to refund excess ether, which can be risky if not handled properly. Although the function is marked `nonReentrant`, the use of a low-level call without proper gas checks can still lead to issues such as denial of service or unexpected behavior if the recipient is a contract. The severity is moderate because it could lead to denial of service or unexpected behavior. The profitability is low, as exploiting this would not directly lead to theft of funds but could disrupt the contract's operations.",
        "correctness": 8,
        "severity": 5,
        "profitability": 3,
        "reason": "The function `deposit` attempts to refund excess ether to the sender using a low-level call without proper checks on gas usage or reentrancy protection. This can be exploited by attackers to cause a denial of service or to execute further logic before the refund is processed, potentially leading to theft of funds.",
        "code": "function deposit(bytes32 _commitment) external payable nonReentrant returns (bytes32 commitment, uint32 insertedIndex, uint256 blocktime, uint256 M87Deno, uint256 fee){ require(!commitments[_commitment], \"The commitment has been submitted\"); require(msg.value >= coinDenomination, \"insufficient coin amount\"); commitment = _commitment; blocktime = block.timestamp; uint256 refund = msg.value - coinDenomination; insertedIndex = _insert(_commitment); commitments[_commitment] = true; M87Deno = M87Denomination(); fee = anonymityFee; uint256 td = tokenDenomination; if (td > 0) { token.safeTransferFrom(msg.sender, address(this), td); } accumulateM87 += M87Deno; numOfShares += 1; if (refund > 0) { (bool success, ) = msg.sender.call.value(refund)(\"\"); require(success, \"failed to refund\"); } collectedFee += feeToCollectAmount; if(collectedFee > overMinEth) { swapAndShare(); } else { sendRewardtoPool(); } updateBlockReward(); emit Deposit(_commitment, insertedIndex, block.timestamp, M87Deno, fee); }",
        "file_name": "0x1963737af12d3649f6f319fb64af2aa29f7256b7.sol"
    }
]