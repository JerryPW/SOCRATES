[
    {
        "function_name": "_withdrawDividendOfUser",
        "vulnerability": "Reentrancy vulnerability through Ether transfer",
        "criticism": "The reasoning correctly identifies the potential for reentrancy due to the use of a low-level call to transfer Ether. The function does not update the state before the external call, which could allow a reentrant contract to exploit this and withdraw multiple times. The severity is high because it can lead to significant financial loss, and the profitability is also high as an attacker could repeatedly drain funds.",
        "correctness": 9,
        "severity": 8,
        "profitability": 8,
        "reason": "The _withdrawDividendOfUser function transfers Ether directly to a user via a low-level call. This makes the function susceptible to reentrancy attacks if the user is a contract that can call back into this contract before the state is updated, potentially allowing for multiple withdrawals.",
        "code": "function _withdrawDividendOfUser(address payable user) internal returns (uint256) { uint256 _withdrawableDividend = withdrawableDividendOf(user); if (_withdrawableDividend > 0) { withdrawnDividends[user] = withdrawnDividends[user].add(_withdrawableDividend); bool success = false; if(DividendToken == address(0)){ (bool sent, bytes memory data) = user.call{value: _withdrawableDividend}(\"\"); success = sent; emit DividendWithdrawn(user, _withdrawableDividend, DividendToken); }else{ success = IERC20(DividendToken).transfer(user, _withdrawableDividend); emit DividendWithdrawn(user, _withdrawableDividend, DividendToken); } if(!success) { withdrawnDividends[user] = withdrawnDividends[user].sub(_withdrawableDividend); return 0; } return _withdrawableDividend; } return 0; }",
        "file_name": "0x0aabf9daefcd484405479d2748cbaedb53c33d87.sol",
        "final_score": 8.5
    },
    {
        "function_name": "_transfer",
        "vulnerability": "Potential denial of service through blacklisting",
        "criticism": "The reasoning is correct in identifying that the blacklisting mechanism can be used to freeze accounts, which could be considered a denial of service. However, this is a design choice rather than a vulnerability, as it is intended to provide control over malicious actors. The severity is low because it is an intended feature, and the profitability is also low since it does not provide direct financial gain to an attacker.",
        "correctness": 8,
        "severity": 3,
        "profitability": 1,
        "reason": "The _transfer function checks if either the sender or receiver is blacklisted and reverts if they are. This allows the contract owner to freeze any address from transferring tokens by blacklisting them, which can be used maliciously or result in unexpected freezing of legitimate users.",
        "code": "function _transfer( address from, address to, uint256 amount ) internal override { require(!_isBlacklisted[from], \"Blacklisted address cannot transfer!\"); require(!_isBlacklisted[to], \"Blacklisted address cannot transfer!\"); require(from != address(0), \"ERC20: transfer to the zero address\"); require(to != address(0), \"ERC20: transfer to the zero address\"); bool tradingIsEnabled = getTradingIsEnabled(); if(!tradingIsEnabled) { require(canTransferBeforeTradingIsEnabled[from], \"MRFROG: This account cannot send tokens until trading is enabled\"); } if(amount == 0) { super._transfer(from, to, 0); return; } bool buyOrSell = false; if ( from != owner() && to != owner() && to != address(0) && to != address(0xdead) && to != uniswapV2Pair && automatedMarketMakerPairs[from] ) { require( amount <= maxBuyTranscationAmount, \"Transfer amount exceeds the maxTxAmount.\" ); uint256 contractBalanceRecepient = balanceOf(to); require( contractBalanceRecepient + amount <= _maxWalletToken, \"Exceeds maximum wallet token amount.\" ); previousMarketFee = marketFee; previousTokenRewardsFee = tokenRewardsFee; previousLiquidityFee = liquidityFee; previousTotalFees = totalFees; marketFee = buyMarketFee; tokenRewardsFee = buyTokenRewardsFee; liquidityFee = buyLiquidityFee; totalFees = buyTotalFees; buyOrSell = true; } if( !swapping && tradingIsEnabled && automatedMarketMakerPairs[to] && from != address(uniswapV2Router) && !_isExcludedFromFees[to] ) { require(amount <= maxSellTransactionAmount, \"Sell transfer amount exceeds the maxSellTransactionAmount.\"); previousMarketFee = marketFee; previousTokenRewardsFee = tokenRewardsFee; previousLiquidityFee = liquidityFee; previousTotalFees = totalFees; marketFee = sellMarketFee; tokenRewardsFee = sellTokenRewardsFee; liquidityFee = sellLiquidityFee; totalFees = sellTotalFees; buyOrSell = true; } uint256 contractTokenBalance = balanceOf(address(this)); bool canSwap = contractTokenBalance >= swapTokensAtAmount; if( tradingIsEnabled && canSwap && !swapping && !automatedMarketMakerPairs[from] && from != burnAddress && to != burnAddress ) { swapping = true; uint256 dividendAmount = swapTokensAtAmount.mul(tokenRewardsFee).div(100); uint256 adminAmount = swapTokensAtAmount.sub(dividendAmount); swapAndLiquify(adminAmount); swapAndSendDividends(dividendAmount); swapping = false; } bool takeFee = tradingIsEnabled && !swapping; if(_isExcludedFromFees[from] || _isExcludedFromFees[to]) { takeFee = false; } if(takeFee) { uint256 fees = amount.mul(totalFees).div(100); amount = amount.sub(fees); super._transfer(from, address(this), fees); } super._transfer(from, to, amount); restoreFees(); try dividendTracker.setBalance(payable(from), balanceOf(from)) {} catch {} try dividendTracker.setBalance(payable(to), balanceOf(to)) {} catch {} bool canDividend = block.timestamp >= processDividendTime; if(!swapping && canDividend) { uint256 gas = gasForProcessing; processDividendTime += dividendTime; try dividendTracker.process(gas) returns (uint256 iterations, uint256 claims, uint256 lastProcessedIndex) { emit ProcessedDividendTracker(iterations, claims, lastProcessedIndex, true, gas, tx.origin); } catch { } } }",
        "file_name": "0x0aabf9daefcd484405479d2748cbaedb53c33d87.sol",
        "final_score": 5.0
    },
    {
        "function_name": "swapAndLiquify",
        "vulnerability": "Potential reentrancy through external calls",
        "criticism": "The reasoning correctly identifies the potential for reentrancy due to multiple external calls and Ether transfers. However, the function does not directly interact with untrusted contracts, as it primarily deals with token swaps and liquidity provision. The risk of reentrancy is mitigated by the fact that state changes are made before external calls, and the function is marked as private, reducing exposure. The severity is moderate due to the complexity of the function, but the profitability is low as it requires specific conditions to exploit.",
        "correctness": 6,
        "severity": 4,
        "profitability": 2,
        "reason": "This function involves multiple external calls (e.g., swapTokensForEth, swapEthForTokens) and Ether transfers. If any of these external calls are made to untrusted contracts, they could potentially exploit reentrancy vulnerabilities by calling back into this contract, especially since the state changes (like updating balances) are made after these external calls.",
        "code": "function swapAndLiquify(uint256 tokens) private {\n    uint256 marketFeeFull = tokens.mul(marketFee).div(100);\n    uint256 tokensAfterFee = tokens - marketFeeFull;\n    uint256 initHalf = tokens.div(2);\n    uint256 half = tokensAfterFee.div(2);\n    uint256 otherHalf = tokensAfterFee.sub(half);\n    uint256 initialBalance = address(this).balance;\n    swapTokensForEth(initHalf);\n    uint256 newBalance = address(this).balance.sub(initialBalance);\n    uint256 marketFeeBalance = newBalance.mul(marketFee).div(100);\n    uint256 finalBalance = newBalance - marketFeeBalance;\n    uint256 finalHalf = otherHalf;\n    if(marketTokenAddressForFee != address(0)){\n        swapEthForTokens(marketFeeBalance, marketTokenAddressForFee, marketAddress);\n    }else{\n        (bool sent,) = marketAddress.call{value: marketFeeBalance}(\"\");\n    }\n    addLiquidity(finalHalf, finalBalance);\n    emit SwapAndLiquify(half, finalBalance, otherHalf);\n}",
        "file_name": "0x0aabf9daefcd484405479d2748cbaedb53c33d87.sol",
        "final_score": 4.5
    }
]