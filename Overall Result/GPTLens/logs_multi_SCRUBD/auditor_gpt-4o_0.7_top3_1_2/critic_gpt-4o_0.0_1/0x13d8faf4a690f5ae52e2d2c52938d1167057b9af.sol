[
    {
        "function_name": "createSwapIntent",
        "vulnerability": "Missing validation for zero address",
        "criticism": "The reasoning is correct in identifying that the function does not validate if _swapIntent.addressTwo is the zero address. This could lead to swaps being created with a zero address as the counterparty, which is a special address in Ethereum and can lead to unexpected behaviors. The severity is moderate because it can disrupt the intended functionality of the swap, but it does not directly lead to a loss of funds. The profitability is low because an attacker cannot directly profit from this vulnerability.",
        "correctness": 8,
        "severity": 5,
        "profitability": 1,
        "reason": "The function does not validate that _swapIntent.addressTwo is not the zero address before assigning it to checksCounterparty and swapList. This can lead to swaps being created with a zero address as the counterparty, potentially allowing for unexpected behaviors or exploits since the zero address is a special, non-ownable address in Ethereum.",
        "code": "function createSwapIntent(swapIntent memory _swapIntent, swapStruct[] memory _nftsOne, swapStruct[] memory _nftsTwo) payable public whenNotPaused nonReentrant { if(payment.status) { if(ERC721Interface(TRADESQUAD).balanceOf(msg.sender)==0) { require(msg.value>=payment.value.add(_swapIntent.valueOne), \"Not enought WEI for handle the transaction\"); _swapIntent.swapFee = getWeiPayValueAmount() ; } else { require(msg.value>=_swapIntent.valueOne, \"Not enought WEI for handle the transaction\"); _swapIntent.swapFee = 0 ; } } else require(msg.value>=_swapIntent.valueOne, \"Not enought WEI for handle the transaction\"); _swapIntent.addressOne = payable(msg.sender); _swapIntent.id = _swapIds.current(); checksCreator[_swapIntent.id] = _swapIntent.addressOne ; checksCounterparty[_swapIntent.id] = _swapIntent.addressTwo ; _swapIntent.swapStart = block.timestamp; _swapIntent.swapEnd = 0; _swapIntent.status = swapStatus.Opened ; swapMatch[_swapIds.current()] = swapList[msg.sender].length; swapList[msg.sender].push(_swapIntent); uint256 i; for(i=0; i<_nftsOne.length; i++) nftsOne[_swapIntent.id].push(_nftsOne[i]); for(i=0; i<_nftsTwo.length; i++) nftsTwo[_swapIntent.id].push(_nftsTwo[i]); for(i=0; i<nftsOne[_swapIntent.id].length; i++) { require(whiteList[nftsOne[_swapIntent.id][i].dapp], \"A DAPP is not handled by the system\"); if(nftsOne[_swapIntent.id][i].typeStd == ERC20) { ERC20Interface(nftsOne[_swapIntent.id][i].dapp).transferFrom(_swapIntent.addressOne, address(this), nftsOne[_swapIntent.id][i].blc[0]); } else if(nftsOne[_swapIntent.id][i].typeStd == ERC721) { ERC721Interface(nftsOne[_swapIntent.id][i].dapp).safeTransferFrom(_swapIntent.addressOne, address(this), nftsOne[_swapIntent.id][i].tokenId[0], nftsOne[_swapIntent.id][i].data); } else if(nftsOne[_swapIntent.id][i].typeStd == ERC1155) { ERC1155Interface(nftsOne[_swapIntent.id][i].dapp).safeBatchTransferFrom(_swapIntent.addressOne, address(this), nftsOne[_swapIntent.id][i].tokenId, nftsOne[_swapIntent.id][i].blc, nftsOne[_swapIntent.id][i].data); } else { customInterface(dappRelations[nftsOne[_swapIntent.id][i].dapp]).bridgeSafeTransferFrom(nftsOne[_swapIntent.id][i].dapp, _swapIntent.addressOne, dappRelations[nftsOne[_swapIntent.id][i].dapp], nftsOne[_swapIntent.id][i].tokenId, nftsOne[_swapIntent.id][i].blc, nftsOne[_swapIntent.id][i].data); } } emit swapEvent(msg.sender, (block.timestamp-(block.timestamp%secs)), _swapIntent.status, _swapIntent.id, _swapIntent.addressTwo); _swapIds.increment(); }",
        "file_name": "0x13d8faf4a690f5ae52e2d2c52938d1167057b9af.sol"
    },
    {
        "function_name": "closeSwapIntent",
        "vulnerability": "Reentrancy vulnerability",
        "criticism": "The reasoning is partially correct. While the function uses the transfer method, which forwards only 2300 gas, the use of the nonReentrant modifier mitigates reentrancy attacks. However, the concern about using transfer is valid, as it can lead to issues if the gas cost changes in the Ethereum network. The severity is low because the nonReentrant modifier is in place, and the profitability is low because an attacker cannot exploit this for direct financial gain.",
        "correctness": 6,
        "severity": 3,
        "profitability": 1,
        "reason": "The function transfers Ether using the transfer method to the addressTwo and addressOne. Although the contract uses a nonReentrant modifier, the transfer method only forwards 2300 gas. If the receiving contracts are malicious and can function within this gas limit, they could potentially disrupt the flow of execution or cause denial-of-service scenarios. It is advised to use call instead of transfer, and handle return values and gas limits appropriately.",
        "code": "function closeSwapIntent(address _swapCreator, uint256 _swapId) payable public whenNotPaused nonReentrant { require(checksCounterparty[_swapId] == msg.sender, \"You're not the interested counterpart\"); require(swapList[_swapCreator][swapMatch[_swapId]].status == swapStatus.Opened, \"Swap Status is not opened\"); require(swapList[_swapCreator][swapMatch[_swapId]].addressTwo == msg.sender, \"You're not the interested counterpart\"); if(payment.status) { if(ERC721Interface(TRADESQUAD).balanceOf(msg.sender)==0) { require(msg.value>=payment.value.add(swapList[_swapCreator][swapMatch[_swapId]].valueTwo), \"Not enought WEI for handle the transaction\"); if(payment.value.add(swapList[_swapCreator][swapMatch[_swapId]].swapFee) > 0) VAULT.transfer(payment.value.add(swapList[_swapCreator][swapMatch[_swapId]].swapFee)); } else { require(msg.value>=swapList[_swapCreator][swapMatch[_swapId]].valueTwo, \"Not enought WEI for handle the transaction\"); if(swapList[_swapCreator][swapMatch[_swapId]].swapFee>0) VAULT.transfer(swapList[_swapCreator][swapMatch[_swapId]].swapFee); } } else require(msg.value>=swapList[_swapCreator][swapMatch[_swapId]].valueTwo, \"Not enought WEI for handle the transaction\"); swapList[_swapCreator][swapMatch[_swapId]].addressTwo = payable(msg.sender); swapList[_swapCreator][swapMatch[_swapId]].swapEnd = block.timestamp; swapList[_swapCreator][swapMatch[_swapId]].status = swapStatus.Closed; uint256 i; for(i=0; i<nftsOne[_swapId].length; i++) { require(whiteList[nftsOne[_swapId][i].dapp], \"A DAPP is not handled by the system\"); if(nftsOne[_swapId][i].typeStd == ERC20) { ERC20Interface(nftsOne[_swapId][i].dapp).transfer(swapList[_swapCreator][swapMatch[_swapId]].addressTwo, nftsOne[_swapId][i].blc[0]); } else if(nftsOne[_swapId][i].typeStd == ERC721) { ERC721Interface(nftsOne[_swapId][i].dapp).safeTransferFrom(address(this), swapList[_swapCreator][swapMatch[_swapId]].addressTwo, nftsOne[_swapId][i].tokenId[0], nftsOne[_swapId][i].data); } else if(nftsOne[_swapId][i].typeStd == ERC1155) { ERC1155Interface(nftsOne[_swapId][i].dapp).safeBatchTransferFrom(address(this), swapList[_swapCreator][swapMatch[_swapId]].addressTwo, nftsOne[_swapId][i].tokenId, nftsOne[_swapId][i].blc, nftsOne[_swapId][i].data); } else { customInterface(dappRelations[nftsOne[_swapId][i].dapp]).bridgeSafeTransferFrom(nftsOne[_swapId][i].dapp, dappRelations[nftsOne[_swapId][i].dapp], swapList[_swapCreator][swapMatch[_swapId]].addressTwo, nftsOne[_swapId][i].tokenId, nftsOne[_swapId][i].blc, nftsOne[_swapId][i].data); } } if(swapList[_swapCreator][swapMatch[_swapId]].valueOne > 0) swapList[_swapCreator][swapMatch[_swapId]].addressTwo.transfer(swapList[_swapCreator][swapMatch[_swapId]].valueOne); for(i=0; i<nftsTwo[_swapId].length; i++) { require(whiteList[nftsTwo[_swapId][i].dapp], \"A DAPP is not handled by the system\"); if(nftsTwo[_swapId][i].typeStd == ERC20) { ERC20Interface(nftsTwo[_swapId][i].dapp).transferFrom(swapList[_swapCreator][swapMatch[_swapId]].addressTwo, swapList[_swapCreator][swapMatch[_swapId]].addressOne, nftsTwo[_swapId][i].blc[0]); } else if(nftsTwo[_swapId][i].typeStd == ERC721) { ERC721Interface(nftsTwo[_swapId][i].dapp).safeTransferFrom(swapList[_swapCreator][swapMatch[_swapId]].addressTwo, swapList[_swapCreator][swapMatch[_swapId]].addressOne, nftsTwo[_swapId][i].tokenId[0], nftsTwo[_swapId][i].data); } else if(nftsTwo[_swapId][i].typeStd == ERC1155) { ERC1155Interface(nftsTwo[_swapId][i].dapp).safeBatchTransferFrom(swapList[_swapCreator][swapMatch[_swapId]].addressTwo, swapList[_swapCreator][swapMatch[_swapId]].addressOne, nftsTwo[_swapId][i].tokenId, nftsTwo[_swapId][i].blc, nftsTwo[_swapId][i].data); } else { customInterface(dappRelations[nftsTwo[_swapId][i].dapp]).bridgeSafeTransferFrom(nftsTwo[_swapId][i].dapp, swapList[_swapCreator][swapMatch[_swapId]].addressTwo, swapList[_swapCreator][swapMatch[_swapId]].addressOne, nftsTwo[_swapId][i].tokenId, nftsTwo[_swapId][i].blc, nftsTwo[_swapId][i].data); } } if(swapList[_swapCreator][swapMatch[_swapId]].valueTwo>0) swapList[_swapCreator][swapMatch[_swapId]].addressOne.transfer(swapList[_swapCreator][swapMatch[_swapId]].valueTwo); emit swapEvent(msg.sender, (block.timestamp-(block.timestamp%secs)), swapStatus.Closed, _swapId, _swapCreator); }",
        "file_name": "0x13d8faf4a690f5ae52e2d2c52938d1167057b9af.sol"
    },
    {
        "function_name": "cancelSwapIntent",
        "vulnerability": "Improper handling of Ether transfers",
        "criticism": "The reasoning is correct in identifying the use of transfer, which can be problematic if the gas stipend is sufficient for the receiving contract to execute further logic. However, the use of the nonReentrant modifier reduces the risk of reentrancy. The severity is low because the primary issue is the potential for the contract to break if gas costs change, rather than a direct exploit. The profitability is low because an attacker cannot directly profit from this vulnerability.",
        "correctness": 7,
        "severity": 3,
        "profitability": 1,
        "reason": "The function uses transfer to send Ether back to the creator. If the receiver is a contract, there is a risk of reentrancy if the gas stipend is sufficient for the receiving contract to execute further logic, potentially leading to vulnerabilities. Moreover, using transfer can lead to issues if the gas cost changes in the Ethereum network, potentially breaking the contract. It's recommended to use call for transferring Ether and handle the return value properly.",
        "code": "function cancelSwapIntent(uint256 _swapId) public nonReentrant { require(checksCreator[_swapId] == msg.sender, \"You're not the interested counterpart\"); require(swapList[msg.sender][swapMatch[_swapId]].addressOne == msg.sender, \"You're not the interested counterpart\"); require(swapList[msg.sender][swapMatch[_swapId]].status == swapStatus.Opened, \"Swap Status is not opened\"); if(swapList[msg.sender][swapMatch[_swapId]].swapFee>0) payable(msg.sender).transfer(swapList[msg.sender][swapMatch[_swapId]].swapFee); uint256 i; for(i=0; i<nftsOne[_swapId].length; i++) { if(nftsOne[_swapId][i].typeStd == ERC20) { ERC20Interface(nftsOne[_swapId][i].dapp).transfer(swapList[msg.sender][swapMatch[_swapId]].addressOne, nftsOne[_swapId][i].blc[0]); } else if(nftsOne[_swapId][i].typeStd == ERC721) { ERC721Interface(nftsOne[_swapId][i].dapp).safeTransferFrom(address(this), swapList[msg.sender][swapMatch[_swapId]].addressOne, nftsOne[_swapId][i].tokenId[0], nftsOne[_swapId][i].data); } else if(nftsOne[_swapId][i].typeStd == ERC1155) { ERC1155Interface(nftsOne[_swapId][i].dapp).safeBatchTransferFrom(address(this), swapList[msg.sender][swapMatch[_swapId]].addressOne, nftsOne[_swapId][i].tokenId, nftsOne[_swapId][i].blc, nftsOne[_swapId][i].data); } else { customInterface(dappRelations[nftsOne[_swapId][i].dapp]).bridgeSafeTransferFrom(nftsOne[_swapId][i].dapp, dappRelations[nftsOne[_swapId][i].dapp], swapList[msg.sender][swapMatch[_swapId]].addressOne, nftsOne[_swapId][i].tokenId, nftsOne[_swapId][i].blc, nftsOne[_swapId][i].data); } } if(swapList[msg.sender][swapMatch[_swapId]].valueOne > 0) swapList[msg.sender][swapMatch[_swapId]].addressOne.transfer(swapList[msg.sender][swapMatch[_swapId]].valueOne); swapList[msg.sender][swapMatch[_swapId]].swapEnd = block.timestamp; swapList[msg.sender][swapMatch[_swapId]].status = swapStatus.Cancelled; emit swapEvent(msg.sender, (block.timestamp-(block.timestamp%secs)), swapStatus.Cancelled, _swapId, address(0)); }",
        "file_name": "0x13d8faf4a690f5ae52e2d2c52938d1167057b9af.sol"
    }
]