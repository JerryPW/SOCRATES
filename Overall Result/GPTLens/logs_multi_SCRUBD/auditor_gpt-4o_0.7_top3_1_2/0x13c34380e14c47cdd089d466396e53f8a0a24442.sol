[
    {
        "function_name": "_transfer",
        "code": "function _transfer(address from, address to, uint256 amount) internal override { require(from != address(0), \"ERC20: transfer from the zero address\"); require(to != address(0), \"ERC20: transfer to the zero address\"); uint256 RewardsFee; uint256 deadFees; uint256 marketingFees; uint256 liquidityFee; uint256 devFees; if (!canTransferBeforeTradingIsEnabled[from]) { require(tradingEnabled, \"Trading has not yet been enabled\"); } if (amount == 0) { super._transfer(from, to, 0); return; } if (to == DEAD) { super._transfer(from, to, amount); _totalSupply = _totalSupply.sub(amount); return; } else if (!swapping && !_isExcludedFromFees[from] && !_isExcludedFromFees[to]) { bool isSelling = automatedMarketMakerPairs[to]; bool isBuying = automatedMarketMakerPairs[from]; if (!isBuying && !isSelling) { if (!_isExcludedFromFees[from] && !_isExcludedFromFees[to]) { uint256 tFees = amount.mul(transferFee).div(100); amount = amount.sub(tFees); super._transfer(from, address(this), tFees); super._transfer(from, to, amount); dividendTracker.setBalance(from, balanceOf(from)); dividendTracker.setBalance(to, balanceOf(to)); return; } else { super._transfer(from, to, amount); dividendTracker.setBalance(from, balanceOf(from)); dividendTracker.setBalance(to, balanceOf(to)); return; } } else if (isSelling) { RewardsFee = sellRewardsFee; deadFees = sellDeadFees; marketingFees = sellMarketingFees; liquidityFee = sellLiquidityFee; devFees = sellDevFee; if (limitsInEffect) { require(block.timestamp >= _holderLastTransferTimestamp[tx.origin] + cooldowntimer, \"cooldown period active\"); require(amount <= maxTX,\"above max transaction limit\"); _holderLastTransferTimestamp[tx.origin] = block.timestamp; } } else if (isBuying) { RewardsFee = buyRewardsFee; deadFees = buyDeadFees; marketingFees = buyMarketingFees; liquidityFee = buyLiquidityFee; devFees = buyDevFee; if (limitsInEffect) { require(block.timestamp > launchtimestamp + delay,\"you shall not pass\"); require(tx.gasprice <= gasPriceLimit,\"Gas price exceeds limit.\"); require(_holderLastTransferBlock[tx.origin] != block.number,\"Too many TX in block\"); require(amount <= maxTX,\"above max transaction limit\"); _holderLastTransferBlock[tx.origin] = block.number; } uint256 contractBalanceRecipient = balanceOf(to); require(contractBalanceRecipient + amount <= maxWallet,\"Exceeds maximum wallet token amount.\" ); } uint256 totalFees = RewardsFee.add(liquidityFee + marketingFees + devFees); uint256 contractTokenBalance = balanceOf(address(this)); bool canSwap = contractTokenBalance >= swapTokensAtAmount; if (canSwap && isSelling) { swapping = true; if (swapAndLiquifyEnabled && liquidityFee > 0 && totalBuyFees > 0) { uint256 totalBuySell = buyAmount.add(sellAmount); uint256 swapAmountBought = contractTokenBalance.mul(buyAmount).div(totalBuySell); uint256 swapAmountSold = contractTokenBalance.mul(sellAmount).div(totalBuySell); uint256 swapBuyTokens = swapAmountBought.mul(liquidityFee).div(totalBuyFees); uint256 swapSellTokens = swapAmountSold.mul(liquidityFee).div(totalSellFees); uint256 swapTokens = swapSellTokens.add(swapBuyTokens); swapAndLiquify(swapTokens); } uint256 remainingBalance = balanceOf(address(this)); swapAndSendDividends(remainingBalance); buyAmount = 1; sellAmount = 1; swapping = false; } uint256 fees = amount.mul(totalFees).div(100); uint256 burntokens; if (deadFees > 0) { burntokens = amount.mul(deadFees) / 100; super._transfer(from, DEAD, burntokens); _totalSupply = _totalSupply.sub(burntokens); } amount = amount.sub(fees + burntokens); if (isSelling) { sellAmount = sellAmount.add(fees); } else { buyAmount = buyAmount.add(fees); } super._transfer(from, address(this), fees); uint256 gas = gasForProcessing; try dividendTracker.process(gas) returns (uint256 iterations, uint256 claims, uint256 lastProcessedIndex) { emit ProcessedDividendTracker(iterations, claims, lastProcessedIndex, true, gas, tx.origin); } catch {} } super._transfer(from, to, amount); dividendTracker.setBalance(from, balanceOf(from)); dividendTracker.setBalance(to, balanceOf(to)); }",
        "vulnerability": "Reentrancy",
        "reason": "The _transfer function calls the process function of the dividend tracker, which in turn calls external contracts. This can potentially lead to reentrancy vulnerabilities if the external contract call is malicious, allowing the attacker to exploit the control flow and execute additional functions before the current function call is completed.",
        "file_name": "0x13c34380e14c47cdd089d466396e53f8a0a24442.sol"
    },
    {
        "function_name": "swapAndSendDividends",
        "code": "function swapAndSendDividends(uint256 tokens) private { if (tokens == 0) { return; } swapTokensForEth(tokens); uint256 totalAmount = buyAmount.add(sellAmount); bool success = true; bool successOp1 = true; bool successOp2 = true; uint256 dividends; uint256 dividendsFromBuy; uint256 dividendsFromSell; if (buyRewardsFee > 0) { dividendsFromBuy = address(this).balance.mul(buyAmount).div(totalAmount) .mul(buyRewardsFee).div(buyRewardsFee + buyMarketingFees + buyDevFee); } if (sellRewardsFee > 0) { dividendsFromSell = address(this).balance.mul(sellAmount).div(totalAmount) .mul(sellRewardsFee).div(sellRewardsFee + sellMarketingFees + sellDevFee); } dividends = dividendsFromBuy.add(dividendsFromSell); if (dividends > 0) { (success, ) = address(dividendTracker).call{value: dividends}(\"\"); } uint256 _completeFees = sellMarketingFees.add(sellDevFee) + buyMarketingFees.add(buyDevFee); uint256 feePortions; if (_completeFees > 0) { feePortions = address(this).balance.div(_completeFees); } uint256 marketingPayout = buyMarketingFees.add(sellMarketingFees) * feePortions; uint256 devPayout = buyDevFee.add(sellDevFee) * feePortions; if (marketingPayout > 0) { (successOp1, ) = address(marketingWallet).call{value: marketingPayout}(\"\"); } if (devPayout > 0) { (successOp2, ) = address(devWallet).call{value: devPayout}(\"\"); } emit SendDividends(dividends, marketingPayout + devPayout, success && successOp1 && successOp2); }",
        "vulnerability": "Unchecked Call Return Value",
        "reason": "The function employs low-level call operations to transfer funds to the dividend tracker, marketing wallet, and dev wallet. However, these calls are not properly checked for success, potentially leading to the loss of funds or incorrect state updates if the calls fail.",
        "file_name": "0x13c34380e14c47cdd089d466396e53f8a0a24442.sol"
    },
    {
        "function_name": "updatePayoutToken",
        "code": "function updatePayoutToken(address token) public onlyOwner { dividendTracker.updatePayoutToken(token); emit UpdatePayoutToken(token); }",
        "vulnerability": "Centralization Risk",
        "reason": "The updatePayoutToken function allows the owner to change the payout token without any restrictions or multi-signature verification. This centralization risk could lead to malicious or accidental changes, affecting the distribution of dividends and potentially causing financial losses to token holders.",
        "file_name": "0x13c34380e14c47cdd089d466396e53f8a0a24442.sol"
    }
]