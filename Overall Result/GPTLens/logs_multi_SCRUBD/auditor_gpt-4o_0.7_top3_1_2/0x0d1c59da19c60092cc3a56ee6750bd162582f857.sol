[
    {
        "function_name": "_swapTokensForEth",
        "code": "function _swapTokensForEth(uint256 tokenAmount, address tokenContract) private { address[] memory path = new address[](2); path[0] = tokenContract; path[1] = uniswapV2Router.WETH(); _approve(tokenContract, address(uniswapV2Router), tokenAmount); uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens( tokenAmount, 0, path, tokenContract, block.timestamp ); }",
        "vulnerability": "Token Approval to Non-ERC20 Contract",
        "reason": "The function uses the `_approve` method to approve `tokenAmount` for the `uniswapV2Router` using `tokenContract` as the token address. If `tokenContract` is not an ERC20 token, this approval will fail. This can be exploited if an attacker can influence the `tokenContract` parameter to point to a non-token address, potentially causing unexpected behavior or blocking functionality.",
        "file_name": "0x0d1c59da19c60092cc3a56ee6750bd162582f857.sol"
    },
    {
        "function_name": "manualTokenomics",
        "code": "function manualTokenomics() public onlyOwner() { if(balanceOf(address(this)) > 0) { this.transfer(_wMarketing, balanceOf(address(this))); } if(address(this).balance > 0) { _wMarketing.transfer(address(this).balance); } }",
        "vulnerability": "Owner Can Drain Contract",
        "reason": "The `manualTokenomics` function allows the owner to transfer all tokens held by the contract to the marketing wallet, as well as the entire ether balance. This presents a centralization risk where the owner can drain all assets from the contract, which is detrimental to the token holders.",
        "file_name": "0x0d1c59da19c60092cc3a56ee6750bd162582f857.sol"
    },
    {
        "function_name": "_transfer",
        "code": "function _transfer(address sender, address recipient, uint256 amount) private { require(sender != address(0), \"ERC20: transfer from the zero address\"); require(recipient != address(0), \"ERC20: transfer to the zero address\"); require(amount > 0, \"Transfer amount must be greater than zero\"); if(_remove_limits_time > 0 && block.timestamp >= _remove_limits_time) { _maxHoldAmount = _tTotal; _maxTransAmount = _tTotal; } if(!_isExcluded[sender]) require(amount <= _maxTransAmount, \"Transfer amount exceeds the maxTransAmount.\"); if(_autoTaxEnabled && !_inLockLiquidities && sender != uniswapV2Pair && !_isExcluded[sender]) if(!_isBuy(sender)) _doTokenomics(); if(_isExcluded[sender] || _isExcluded[recipient]) { removeTax(); } else { if(_isBuy(sender)) { uint256 recipient_balance = balanceOf(address(recipient)); uint256 recipient_new_balance = recipient_balance.add(amount); require(recipient_new_balance <= _maxHoldAmount, \"Transfer amount exceeds the maxHoldAmount.\"); if (_buyMap[recipient] == 0 || (_buyMap[recipient] != 0 && block.timestamp > (_buyMap[recipient] + (192 hours)))) { _buyMap[recipient] = block.timestamp; }} if(!_isBuy(sender)) { if(_earlySellTaxEnabled && _buyMap[sender] != 0 && (_buyMap[sender] + (192 hours) >= block.timestamp)) { bool earlySellTaxFound = false; if (_buyMap[sender] != 0 && (_buyMap[sender] + (24 hours) >= block.timestamp) && !earlySellTaxFound) { _totalSellTax = 20; earlySellTaxFound = true; } if (_buyMap[sender] != 0 && (_buyMap[sender] + (48 hours) >= block.timestamp) && !earlySellTaxFound) { _totalSellTax = 19; earlySellTaxFound = true; } if (_buyMap[sender] != 0 && (_buyMap[sender] + (72 hours) >= block.timestamp) && !earlySellTaxFound) { _totalSellTax = 18; earlySellTaxFound = true; } if (_buyMap[sender] != 0 && (_buyMap[sender] + (96 hours) >= block.timestamp) && !earlySellTaxFound) { _totalSellTax = 17; earlySellTaxFound = true; } if (_buyMap[sender] != 0 && (_buyMap[sender] + (120 hours) >= block.timestamp) && !earlySellTaxFound) { _totalSellTax = 16; earlySellTaxFound = true; } if (_buyMap[sender] != 0 && (_buyMap[sender] + (144 hours) >= block.timestamp) && !earlySellTaxFound) { _totalSellTax = 15; earlySellTaxFound = true; } if (_buyMap[sender] != 0 && (_buyMap[sender] + (168 hours) >= block.timestamp) && !earlySellTaxFound) { _totalSellTax = 14; earlySellTaxFound = true; } if (_buyMap[sender] != 0 && (_buyMap[sender] + (192 hours) >= block.timestamp) && !earlySellTaxFound) { _totalSellTax = 13; earlySellTaxFound = true; } } else { _totalSellTax = _currentSellTax; }}} if(!_isBuy(sender) && !_isSell(recipient)) { removeTax(); } if (_isExcluded[sender] && !_isExcluded[recipient]) { _transferFromExcluded(sender, recipient, amount); } else if (!_isExcluded[sender] && _isExcluded[recipient]) { _transferToExcluded(sender, recipient, amount); } else if (_isExcluded[sender] && _isExcluded[recipient]) { _transferBothExcluded(sender, recipient, amount); } else { _transferStandard(sender, recipient, amount); } if(_isExcluded[sender] || _isExcluded[recipient]) { restoreTax(); } if(!_isBuy(sender) && !_isSell(recipient)) { restoreTax(); } }",
        "vulnerability": "Potential Tax Manipulation",
        "reason": "The function determines transaction taxes based on the sender and recipient, and the `removeTax` and `restoreTax` functions are called based on exclusions and transaction types. This logic can be manipulated or bypassed under certain conditions, especially if the state of `_isExcluded` is incorrectly managed, potentially allowing transactions to occur without the intended tax being applied.",
        "file_name": "0x0d1c59da19c60092cc3a56ee6750bd162582f857.sol"
    }
]