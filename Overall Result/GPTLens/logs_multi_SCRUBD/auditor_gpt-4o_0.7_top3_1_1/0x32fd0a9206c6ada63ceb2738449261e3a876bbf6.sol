[
    {
        "function_name": "sendExternalTokens",
        "code": "function sendExternalTokens(address official, address externalToken) external returns (bool) { Token tokenERC20 = Token(externalToken); uint256 balance = tokenERC20.allowance(official, address(this)); require(tokenERC20.balanceOf(official) >= balance, \"Official should have external tokens for approved\"); require(balance > 0, \"External tokens must be approved for town smart contract\"); tokenERC20.transferFrom(official, address(this), balance); ExternalTokenDistributionsInfo memory tokenInfo; tokenInfo._official = official; tokenInfo._distributionsCount = _distributionPeriodsNumber; tokenInfo._distributionAmount = balance.div(_distributionPeriodsNumber); ExternalToken storage tokenObj = _externalTokens[externalToken]; if (tokenObj._entities.length == 0) { _externalTokensAddresses.push(externalToken); } tokenObj._entities.push(tokenInfo); emit Proposal(balance, tokenInfo._official, tokenInfo._distributionsCount, tokenInfo._distributionAmount, externalToken); return true; }",
        "vulnerability": "Lack of Distribution Count Check",
        "reason": "The function does not check if `_distributionPeriodsNumber` is greater than zero before dividing by it. An attacker could set `_distributionPeriodsNumber` to zero, causing a division by zero error and halting the contract execution.",
        "file_name": "0x32fd0a9206c6ada63ceb2738449261e3a876bbf6.sol"
    },
    {
        "function_name": "remuneration",
        "code": "function remuneration(uint256 tokensAmount) external returns (bool) { require(_token.balanceOf(msg.sender) >= tokensAmount, \"Town tokens not found\"); require(_token.allowance(msg.sender, address(this)) >= tokensAmount, \"Town tokens must be approved for town smart contract\"); uint256 debt = 0; uint256 restOfTokens = tokensAmount; uint256 executedRequestCount = 0; for (uint256 i = 0; i < _queueTownTokenRequests.length; ++i) { address user = _queueTownTokenRequests[i]._address; uint256 rate = _queueTownTokenRequests[i]._info._rate; uint256 amount = _queueTownTokenRequests[i]._info._amount; if (restOfTokens > amount) { _token.transferFrom(msg.sender, user, amount); restOfTokens = restOfTokens.sub(amount); debt = debt.add(amount.mul(rate).div(10 ** 18)); executedRequestCount++; } else { break; } } if (restOfTokens > 0) { _token.transferFrom(msg.sender, address(this), restOfTokens); } if (executedRequestCount > 0) { for (uint256 i = executedRequestCount; i < _queueTownTokenRequests.length; ++i) { _queueTownTokenRequests[i - executedRequestCount] = _queueTownTokenRequests[i]; } for (uint256 i = 0; i < executedRequestCount; ++i) { _queueTownTokenRequests.pop(); } } if (_historyTransactions[msg.sender].length > 0) { for (uint256 i = _historyTransactions[msg.sender].length - 1; ; --i) { uint256 rate = _historyTransactions[msg.sender][i]._rate; uint256 amount = _historyTransactions[msg.sender][i]._amount; _historyTransactions[msg.sender].pop(); if (restOfTokens < amount) { TransactionsInfo memory info = TransactionsInfo(rate, amount.sub(restOfTokens)); _historyTransactions[msg.sender].push(info); debt = debt.add(restOfTokens.mul(rate).div(10 ** 18)); break; } debt = debt.add(amount.mul(rate).div(10 ** 18)); restOfTokens = restOfTokens.sub(amount); if (i == 0) break; } } if (debt > address(this).balance) { msg.sender.transfer(address(this).balance); RemunerationsInfo memory info = RemunerationsInfo(msg.sender, 2, debt.sub(address(this).balance)); _remunerationsQueue.push(info); } else { msg.sender.transfer(debt); } return true; }",
        "vulnerability": "Reentrancy Vulnerability",
        "reason": "The function sends Ether to the caller (`msg.sender`) without updating the state before the transfer. An attacker can exploit this by recursively calling the function before the state is updated, causing multiple Ether withdrawals.",
        "file_name": "0x32fd0a9206c6ada63ceb2738449261e3a876bbf6.sol"
    },
    {
        "function_name": "distributionSnapshot",
        "code": "function distributionSnapshot() external returns (bool) { require(block.timestamp > (_lastDistributionsDate + _distributionPeriod), \"distribution time has not yet arrived\"); uint256 sumWeight = 0; address[] memory tempArray; _externalTokensWithWight = tempArray; for (uint256 i = 0; i < _externalTokensAddresses.length; ++i) { ExternalToken memory externalToken = _externalTokens[_externalTokensAddresses[i]]; if (externalToken._weight > 0) { uint256 sumExternalTokens = 0; for (uint256 j = 0; j < externalToken._entities.length; ++j) { if (externalToken._entities[j]._distributionsCount > 0) { ExternalTokenDistributionsInfo memory info = externalToken._entities[j]; sumExternalTokens = sumExternalTokens.add(info._distributionAmount.mul(info._distributionsCount)); } } if (sumExternalTokens > _minExternalTokensAmount) { sumWeight = sumWeight.add(externalToken._weight); _externalTokensWithWight.push(_externalTokensAddresses[i]); } else { externalToken._weight = 0; } } } uint256 fullBalance = address(this).balance; for (uint256 i = 0; i < _externalTokensWithWight.length; ++i) { ExternalToken memory externalToken = _externalTokens[_externalTokensWithWight[i]]; uint256 sumExternalTokens = 0; for (uint256 j = 0; j < externalToken._entities.length; ++j) { sumExternalTokens = sumExternalTokens.add(externalToken._entities[j]._distributionAmount); } uint256 externalTokenCost = fullBalance.mul(externalToken._weight).div(sumWeight); for (uint256 j = 0; j < externalToken._entities.length; ++j) { address official = externalToken._entities[j]._official; uint256 tokensAmount = externalToken._entities[j]._distributionAmount; uint256 amount = externalTokenCost.mul(tokensAmount).div(sumExternalTokens); uint256 decayTimestamp = (block.timestamp - _lastDistributionsDate).div(_distributionPeriod).mul(_distributionPeriod).add(_lastDistributionsDate).add(_distributionPeriod); _officialsLedger[official] = RemunerationsOfficialsInfo(amount, decayTimestamp); } } uint256 sumHoldersTokens = _token.totalSupply().sub(_token.balanceOf(address(this))); if (sumHoldersTokens != 0) { for (uint256 i = 0; i < _token.getHoldersCount(); ++i) { address holder = _token.getHolderByIndex(i); uint256 balance = _token.balanceOf(holder); for (uint256 j = 0; j < _externalTokensAddresses.length; ++j) { address externalTokenAddress = _externalTokensAddresses[j]; ExternalToken memory externalToken = _externalTokens[externalTokenAddress]; for (uint256 k = 0; k < externalToken._entities.length; ++k) { if (holder != address(this) && externalToken._entities[k]._distributionsCount > 0) { uint256 percent = balance.mul(externalToken._entities[k]._distributionAmount).div(sumHoldersTokens); if (percent > (10 ** 4)) { address[] memory externalTokensForHolder = _ledgerExternalTokensAddresses[holder]; bool found = false; for (uint256 h = 0; h < externalTokensForHolder.length; ++h) { if (externalTokensForHolder[h] == externalTokenAddress) { found = true; break; } } if (found == false) { _ledgerExternalTokensAddresses[holder].push(externalTokenAddress); } _townHoldersLedger[holder][externalTokenAddress] = _townHoldersLedger[holder][externalTokenAddress].add(percent); } } } } } for (uint256 j = 0; j < _externalTokensAddresses.length; ++j) { ExternalTokenDistributionsInfo[] memory tempEntities = _externalTokens[_externalTokensAddresses[j]]._entities; delete _externalTokens[_externalTokensAddresses[j]]._entities; for (uint256 k = 0; k < tempEntities.length; ++k) { tempEntities[k]._distributionsCount--; if (tempEntities[k]._distributionsCount > 0) { _externalTokens[_externalTokensAddresses[j]]._entities.push(tempEntities[k]); } } } } for (uint256 i = 0; i < _externalTokensAddresses.length; ++i) { if (_externalTokens[_externalTokensAddresses[i]]._weight > 0) { _externalTokens[_externalTokensAddresses[i]]._weight = 0; } } _lastDistributionsDate = _lastDistributionsDate.add(_distributionPeriod); return true; }",
        "vulnerability": "Integer Overflow/Underflow",
        "reason": "The function performs arithmetic operations that may overflow or underflow without using SafeMath for critical computations. If not handled, this can lead to incorrect calculations and unintentional behavior of the contract.",
        "file_name": "0x32fd0a9206c6ada63ceb2738449261e3a876bbf6.sol"
    }
]