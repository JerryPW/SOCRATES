[
    {
        "function_name": "acceptNextOwner",
        "code": "function acceptNextOwner() external { require (msg.sender == nextOwner, \"Can only accept preapproved new owner.\"); owner = nextOwner; }",
        "vulnerability": "Unrestricted Owner Change",
        "reason": "The function does not reset the 'nextOwner' variable after ownership is transferred. This could potentially allow the previous owner to regain control by calling approveNextOwner again with the same address.",
        "file_name": "0x0c073c92e7684031cfc297b83ecc33619e864d18.sol"
    },
    {
        "function_name": "placeBetRouletteProcess",
        "code": "function placeBetRouletteProcess ( uint commit, uint[] memory betMask, uint[] memory betAmount ) internal returns (uint8 betsCount, uint128 locked) { BetRoulette storage betRoulette = betsRoulette[commit]; betsCount = 0; uint totalBetAmount = 0; uint8 addBets = betRoulette.betsCount; uint8 tmpBetCount = betRoulette.betsCount - 1; uint128 curLocked = 0; uint128 tmpLocked = 0; bool numIsAlredyLocked = false; uint8 bonuses = getBonusProgrammLevel(betRoulette.gambler); while (0 <= tmpBetCount) { require (betMask[tmpBetCount] > 0 && betMask[tmpBetCount] < MAX_BET_MASK, \"Mask should be within range.\"); if (betMask[tmpBetCount] == 38721851401) { require (betAmount[tmpBetCount] >= MIN_BET * 4 && betAmount[tmpBetCount] <= MAX_AMOUNT, \"Amount should be within range.\"); totalBetAmount += betAmount[tmpBetCount]; require (totalBetAmount <= msg.value, \"Total bets amount should be LTE amount\"); (betRoulette.mask[tmpBetCount], betRoulette.rollUnder[tmpBetCount], curLocked) = prepareBetRoulette(36864, betAmount[tmpBetCount] / 4, bonuses); betRoulette.amount[tmpBetCount] = betAmount[tmpBetCount] / 4; (betRoulette.mask[addBets], betRoulette.rollUnder[addBets], tmpLocked) = prepareBetRoulette(38654705664, betAmount[tmpBetCount] / 4, bonuses); betRoulette.amount[addBets] = betAmount[tmpBetCount] / 4; curLocked = (tmpLocked > curLocked) ? tmpLocked : curLocked; addBets += 1; (betRoulette.mask[addBets], betRoulette.rollUnder[addBets], tmpLocked) = prepareBetRoulette(9, betAmount[tmpBetCount] / 4, bonuses); betRoulette.amount[addBets] = betAmount[tmpBetCount] / 4; curLocked = (tmpLocked > curLocked) ? tmpLocked : curLocked; addBets += 1; (betRoulette.mask[addBets], betRoulette.rollUnder[addBets], tmpLocked) = prepareBetRoulette(67108864, betAmount[tmpBetCount] / 4, bonuses); betRoulette.amount[addBets] = betAmount[tmpBetCount] / 4; curLocked = (tmpLocked > curLocked) ? tmpLocked : curLocked; locked += curLocked; addBets += 1; betsCount += 4; } else if (betMask[tmpBetCount] == 39567790237) { require (betAmount[tmpBetCount] >= MIN_BET * 9 && betAmount[tmpBetCount] <= MAX_AMOUNT, \"Amount should be within range.\"); totalBetAmount += betAmount[tmpBetCount]; require (totalBetAmount <= msg.value, \"Total bets amount should be LTE amount\"); (betRoulette.mask[tmpBetCount], betRoulette.rollUnder[tmpBetCount], curLocked) = prepareBetRoulette( 144, betAmount[tmpBetCount] / 9, bonuses); betRoulette.amount[tmpBetCount] = betAmount[tmpBetCount] / 9; (betRoulette.mask[addBets], betRoulette.rollUnder[addBets], tmpLocked) = prepareBetRoulette( 36864, betAmount[tmpBetCount] / 9, bonuses); betRoulette.amount[addBets] = betAmount[tmpBetCount] / 9; curLocked = (tmpLocked > curLocked) ? tmpLocked : curLocked; addBets += 1; (betRoulette.mask[addBets], betRoulette.rollUnder[addBets], tmpLocked) = prepareBetRoulette( 2359296, betAmount[tmpBetCount] / 9, bonuses); betRoulette.amount[addBets] = betAmount[tmpBetCount] / 9; curLocked = (tmpLocked > curLocked) ? tmpLocked : curLocked; addBets += 1; (betRoulette.mask[addBets], betRoulette.rollUnder[addBets], tmpLocked) = prepareBetRoulette( 4718592, betAmount[tmpBetCount] / 9, bonuses); betRoulette.amount[addBets] = betAmount[tmpBetCount] / 9; curLocked = (tmpLocked > curLocked) ? tmpLocked : curLocked; addBets += 1; (betRoulette.mask[addBets], betRoulette.rollUnder[addBets], tmpLocked) = prepareBetRoulette( 38654705664, betAmount[tmpBetCount] / 9, bonuses); betRoulette.amount[addBets] = betAmount[tmpBetCount] / 9; curLocked = (tmpLocked > curLocked) ? tmpLocked : curLocked; addBets += 1; (betRoulette.mask[addBets], betRoulette.rollUnder[addBets], tmpLocked) = prepareBetRoulette( 905969664, betAmount[tmpBetCount] * 2 / 9, bonuses); betRoulette.amount[addBets] = betAmount[tmpBetCount] * 2 / 9; curLocked = (tmpLocked > curLocked) ? tmpLocked : curLocked; addBets += 1; (betRoulette.mask[addBets], betRoulette.rollUnder[addBets], tmpLocked) = prepareBetRoulette( 13, betAmount[tmpBetCount] * 2 / 9, bonuses); betRoulette.amount[addBets] = betAmount[tmpBetCount] * 2 / 9; curLocked = (tmpLocked > curLocked) ? tmpLocked : curLocked; locked += curLocked; addBets += 1; betsCount += 7; } else if (betMask[tmpBetCount] == 19328549442) { require (betAmount[tmpBetCount] >= MIN_BET * 5 && betAmount[tmpBetCount] <= MAX_AMOUNT, \"Amount should be within range.\"); totalBetAmount += betAmount[tmpBetCount]; require (totalBetAmount <= msg.value, \"Total bets amount should be LTE amount\"); (betRoulette.mask[addBets], betRoulette.rollUnder[addBets], curLocked) = prepareBetRoulette( 147456, betAmount[tmpBetCount] / 5, bonuses); betRoulette.amount[addBets] = betAmount[tmpBetCount] / 5; addBets += 1; (betRoulette.mask[addBets], betRoulette.rollUnder[addBets], tmpLocked) = prepareBetRoulette( 1179648, betAmount[tmpBetCount] / 5, bonuses); betRoulette.amount[addBets] = betAmount[tmpBetCount] / 5; curLocked += tmpLocked; (betRoulette.mask[tmpBetCount], betRoulette.rollUnder[tmpBetCount], tmpLocked) = prepareBetRoulette( 576, betAmount[tmpBetCount] / 5, bonuses); betRoulette.amount[tmpBetCount] = betAmount[tmpBetCount] / 5; curLocked = (tmpLocked > curLocked) ? tmpLocked : curLocked; addBets += 1; (betRoulette.mask[addBets], betRoulette.rollUnder[addBets], tmpLocked) = prepareBetRoulette( 19327352832, betAmount[tmpBetCount] / 5, bonuses); betRoulette.amount[addBets] = betAmount[tmpBetCount] / 5; curLocked = (tmpLocked > curLocked) ? tmpLocked : curLocked; addBets += 1; (betRoulette.mask[addBets], betRoulette.rollUnder[addBets], tmpLocked) = prepareBetRoulette( 2, betAmount[tmpBetCount] / 5, bonuses); betRoulette.amount[addBets] = betAmount[tmpBetCount] / 5; curLocked = (tmpLocked > curLocked) ? tmpLocked : curLocked; locked += curLocked; addBets += 1; betsCount += 5; } else if (betMask[tmpBetCount] == 78542613792) { require (betAmount[tmpBetCount] >= MIN_BET * 6 && betAmount[tmpBetCount] <= MAX_AMOUNT, \"Amount should be within range.\"); totalBetAmount += betAmount[tmpBetCount]; require (totalBetAmount <= msg.value, \"Total bets amount should be LTE amount\"); (betRoulette.mask[tmpBetCount], betRoulette.rollUnder[tmpBetCount], curLocked) = prepareBetRoulette( 288, betAmount[tmpBetCount] / 6, bonuses); betRoulette.amount[tmpBetCount] = betAmount[tmpBetCount] / 6; (betRoulette.mask[addBets], betRoulette.rollUnder[addBets], tmpLocked) = prepareBetRoulette( 3072, betAmount[tmpBetCount] / 6, bonuses); betRoulette.amount[addBets] = betAmount[tmpBetCount] / 6; curLocked = (tmpLocked > curLocked) ? tmpLocked : curLocked; addBets += 1; (betRoulette.mask[addBets], betRoulette.rollUnder[addBets], tmpLocked) = prepareBetRoulette( 73728, betAmount[tmpBetCount] / 6, bonuses); betRoulette.amount[addBets] = betAmount[tmpBetCount] / 6; curLocked = (tmpLocked > curLocked) ? tmpLocked : curLocked; addBets += 1; (betRoulette.mask[addBets], betRoulette.rollUnder[addBets], tmpLocked) = prepareBetRoulette( 25165824, betAmount[tmpBetCount] / 6, bonuses); betRoulette.amount[addBets] = betAmount[tmpBetCount] / 6; curLocked = (tmpLocked > curLocked) ? tmpLocked : curLocked; addBets += 1; (betRoulette.mask[addBets], betRoulette.rollUnder[addBets], tmpLocked) = prepareBetRoulette( 1207959552, betAmount[tmpBetCount] / 6, bonuses); betRoulette.amount[addBets] = betAmount[tmpBetCount] / 6; curLocked = (tmpLocked > curLocked) ? tmpLocked : curLocked; addBets += 1; (betRoulette.mask[addBets], betRoulette.rollUnder[addBets], tmpLocked) = prepareBetRoulette( 77309411328, betAmount[tmpBetCount] / 6, bonuses); betRoulette.amount[addBets] = betAmount[tmpBetCount] / 6; curLocked = (tmpLocked > curLocked) ? tmpLocked : curLocked; locked += curLocked; addBets += 1; betsCount += 6; } else { require (betAmount[tmpBetCount] >= MIN_BET && betAmount[tmpBetCount] <= MAX_AMOUNT, \"Amount should be within range.\"); totalBetAmount += betAmount[tmpBetCount]; require (totalBetAmount <= msg.value, \"Total bets amount should be LTE amount\"); (betRoulette.mask[tmpBetCount], betRoulette.rollUnder[tmpBetCount], tmpLocked) = prepareBetRoulette( betMask[tmpBetCount], betAmount[tmpBetCount], bonuses); if (uint8(((betRoulette.mask[tmpBetCount] * POPCNT_MULT) & POPCNT_MASK) % POPCNT_MODULO) != 1) { locked += tmpLocked; } else { if (!numIsAlredyLocked) { numIsAlredyLocked = true; locked += tmpLocked; } } betRoulette.amount[tmpBetCount] = betAmount[tmpBetCount]; betsCount += 1; } if (tmpBetCount == 0) break; tmpBetCount -= 1; } }",
        "vulnerability": "Unchecked Arithmetic",
        "reason": "The function contains a while loop that decrements a uint8 value, 'tmpBetCount', without a bounds check to ensure it does not underflow. This may lead to an infinite loop or incorrect behavior.",
        "file_name": "0x0c073c92e7684031cfc297b83ecc33619e864d18.sol"
    },
    {
        "function_name": "setNewPercents",
        "code": "function setNewPercents( uint8 newHouseEdgePercent, uint8 newDividendsPercent, uint8 newAdvertPercent ) external onlyOwner { require(newDividendsPercent >= 5); require(newHouseEdgePercent + newDividendsPercent + newAdvertPercent <= 30); HOUSE_EDGE_PERCENT = newHouseEdgePercent; ADVERTISE_PERCENT = newAdvertPercent; DIVIDENDS_PERCENT = newDividendsPercent; }",
        "vulnerability": "Unrestricted House Edge Adjustment",
        "reason": "The owner can set the house edge to any value as long as the total percentages do not exceed 30. This could allow the owner to set a very high house edge, potentially impacting the fairness of the game for players.",
        "file_name": "0x0c073c92e7684031cfc297b83ecc33619e864d18.sol"
    }
]