[
    {
        "function_name": "withdraw",
        "code": "function withdraw() external hasEarnings { uint256 amount = _valueMap[msg.sender]; _valueMap[msg.sender] = 0; emit BraveWithdraw(msg.sender, amount); msg.sender.transfer(amount); overStage(1); overStage(5); overStage(10); }",
        "vulnerability": "Reentrancy vulnerability",
        "reason": "The withdraw function transfers ether to msg.sender before updating the stage or performing any other state changes. This allows a potential attacker to re-enter the withdraw function (or any other function that transfers ether) using a fallback function, draining the contract's funds before the state is updated.",
        "file_name": "0x132e2b67e91bf0294536b16d772e8dee099fc40c.sol"
    },
    {
        "function_name": "overStage",
        "code": "function overStage(uint8 rate) private { uint256 curStageIndex = _currentMap[rate]; uint256 finishStageIndex = _finishMap[rate]; assert(curStageIndex >= finishStageIndex); if (curStageIndex == finishStageIndex) {return;} Stage storage finishStage = _stageMap[rate][finishStageIndex]; assert(!finishStage.isFinish); if (finishStage.cnt < MAX_PLAYERS) {return;} assert(finishStage.blocknumber != 0); if (block.number - 256 <= finishStage.blocknumber) { if (block.number == finishStage.blocknumber) {return;} uint8 deadIndex = uint8(blockhash(finishStage.blocknumber)) % MAX_PLAYERS; address deadPlayer = finishStage.playerMap[deadIndex]; emit BraveDeadPlayer(deadPlayer,finishStageIndex,deadIndex, rate); finishStage.deadIndex = deadIndex; for (uint8 i = 0; i < MAX_PLAYERS; i++) { address player = finishStage.playerMap[i]; if (deadIndex != i) { _valueMap[player] += WIN_VALUE * rate; } address referee = _addressMap[player]; _valueMap[referee] += REFEREE_VALUE * rate; _referredMap[referee] += REFEREE_VALUE * rate; } uint256 dividends = p3dContract.myDividends(true); if (dividends > 0) { p3dContract.withdraw(); _valueMap[deadPlayer] += dividends; } p3dContract.buy.value(P3D_VALUE * rate)(address(OFFICIAL_P3D)); } else { for (uint8 j = 0; j < MAX_PLAYERS; j++) { _valueMap[finishStage.playerMap[j]] += PRICE * rate; } emit BraveInvalidateStage(finishStageIndex, rate); } finishStage.isFinish = true; finishStageIndex++; _finishMap[rate] = finishStageIndex; }",
        "vulnerability": "Blockhash usage vulnerability",
        "reason": "The overStage function uses blockhash to generate a pseudo-random number to select a 'dead' player. This is insecure because blockhash is predictable by miners and could be manipulated, allowing them to influence the outcome of the random selection.",
        "file_name": "0x132e2b67e91bf0294536b16d772e8dee099fc40c.sol"
    },
    {
        "function_name": "buyByAddress",
        "code": "function buyByAddress(address referee) external payable { uint8 rate = 1; if (msg.value == PRICE) { rate = 1; } else if (msg.value == PRICE * 5) { rate = 5; } else if (msg.value == PRICE * 10) { rate = 10; } else { require(false); } resetStage(rate); buy(rate); overStage(rate); if (_addressMap[msg.sender] == 0) { if (referee != 0x0000000000000000000000000000000000000000 && referee != msg.sender && _valueMap[referee] >= 0) { _addressMap[msg.sender] = referee; } else { _addressMap[msg.sender] = OFFICIAL; } } emit BraveReferrer(_addressMap[msg.sender],msg.sender,rate); }",
        "vulnerability": "Improper validation of referee",
        "reason": "The function does not properly validate the referee. It only checks if the referee's address is non-zero and that the referee is not the sender, but it does not verify if the referee is a legitimate participant in the game. This allows for potential abuse where a participant could set arbitrary addresses as referees to manipulate referral rewards.",
        "file_name": "0x132e2b67e91bf0294536b16d772e8dee099fc40c.sol"
    }
]