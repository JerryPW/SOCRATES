[
    {
        "function_name": "function()",
        "code": "function() payable { tokenFree = sharesTokenAddress.balanceOf(this); if (now < presaleStart_6_December) { msg.sender.transfer(msg.value); } else if (now > presaleStop_13_December) { msg.sender.transfer(msg.value); if(!tokensWithdrawn){ sharesTokenAddress.transfer(safeContract, sharesTokenAddress.balanceOf(this)); tokenFree = sharesTokenAddress.balanceOf(this); tokensWithdrawn = true; presaleClosed = true; } } else if (presaleClosed) { msg.sender.transfer(msg.value); } else { uint256 tokenToBuy = msg.value / realPrice * coeff; if(tokenToBuy <= 0) msg.sender.transfer(msg.value); require(tokenToBuy > 0); uint256 actualETHTransfer = tokenToBuy * realPrice / coeff; if (tokenFree >= tokenToBuy) { owner.transfer(actualETHTransfer); if (msg.value > actualETHTransfer){ msg.sender.transfer(msg.value - actualETHTransfer); } sharesTokenAddress.transfer(msg.sender, tokenToBuy); tokenSold += tokenToBuy; tokenFree -= tokenToBuy; if(tokenFree==0) presaleClosed = true; } else { uint256 sendETH = tokenFree * realPrice / coeff; owner.transfer(sendETH); sharesTokenAddress.transfer(msg.sender, tokenFree); msg.sender.transfer(msg.value - sendETH); tokenSold += tokenFree; tokenFree = sharesTokenAddress.balanceOf(this); presaleClosed = true; } } TokenFree(tokenFree); PresaleClosed(presaleClosed); }",
        "vulnerability": "Reentrancy vulnerability in fallback function",
        "reason": "The fallback function handles Ether transfers both to and from the contract. It calls msg.sender.transfer() before updating the state variables. An attacker can exploit this by re-entering the contract with a crafted fallback function in their address, potentially causing undesired effects such as multiple withdrawals.",
        "file_name": "0x8c944c3f4029c14c22b6525ac3155482c2559541.sol"
    },
    {
        "function_name": "function()",
        "code": "function() payable { tokenFree = sharesTokenAddress.balanceOf(this); if (now < presaleStart_6_December) { msg.sender.transfer(msg.value); } else if (now > presaleStop_13_December) { msg.sender.transfer(msg.value); if(!tokensWithdrawn){ sharesTokenAddress.transfer(safeContract, sharesTokenAddress.balanceOf(this)); tokenFree = sharesTokenAddress.balanceOf(this); tokensWithdrawn = true; presaleClosed = true; } } else if (presaleClosed) { msg.sender.transfer(msg.value); } else { uint256 tokenToBuy = msg.value / realPrice * coeff; if(tokenToBuy <= 0) msg.sender.transfer(msg.value); require(tokenToBuy > 0); uint256 actualETHTransfer = tokenToBuy * realPrice / coeff; if (tokenFree >= tokenToBuy) { owner.transfer(actualETHTransfer); if (msg.value > actualETHTransfer){ msg.sender.transfer(msg.value - actualETHTransfer); } sharesTokenAddress.transfer(msg.sender, tokenToBuy); tokenSold += tokenToBuy; tokenFree -= tokenToBuy; if(tokenFree==0) presaleClosed = true; } else { uint256 sendETH = tokenFree * realPrice / coeff; owner.transfer(sendETH); sharesTokenAddress.transfer(msg.sender, tokenFree); msg.sender.transfer(msg.value - sendETH); tokenSold += tokenFree; tokenFree = sharesTokenAddress.balanceOf(this); presaleClosed = true; } } TokenFree(tokenFree); PresaleClosed(presaleClosed); }",
        "vulnerability": "Incorrect Ether value calculation",
        "reason": "The calculation of actualETHTransfer and sendETH uses integer division, which could result in a loss of precision, leading to incorrect transfer amounts. This can cause the contract to transfer less Ether than expected, allowing an attacker to buy tokens cheaper than intended.",
        "file_name": "0x8c944c3f4029c14c22b6525ac3155482c2559541.sol"
    },
    {
        "function_name": "function()",
        "code": "function() payable { tokenFree = sharesTokenAddress.balanceOf(this); if (now < presaleStart_6_December) { msg.sender.transfer(msg.value); } else if (now > presaleStop_13_December) { msg.sender.transfer(msg.value); if(!tokensWithdrawn){ sharesTokenAddress.transfer(safeContract, sharesTokenAddress.balanceOf(this)); tokenFree = sharesTokenAddress.balanceOf(this); tokensWithdrawn = true; presaleClosed = true; } } else if (presaleClosed) { msg.sender.transfer(msg.value); } else { uint256 tokenToBuy = msg.value / realPrice * coeff; if(tokenToBuy <= 0) msg.sender.transfer(msg.value); require(tokenToBuy > 0); uint256 actualETHTransfer = tokenToBuy * realPrice / coeff; if (tokenFree >= tokenToBuy) { owner.transfer(actualETHTransfer); if (msg.value > actualETHTransfer){ msg.sender.transfer(msg.value - actualETHTransfer); } sharesTokenAddress.transfer(msg.sender, tokenToBuy); tokenSold += tokenToBuy; tokenFree -= tokenToBuy; if(tokenFree==0) presaleClosed = true; } else { uint256 sendETH = tokenFree * realPrice / coeff; owner.transfer(sendETH); sharesTokenAddress.transfer(msg.sender, tokenFree); msg.sender.transfer(msg.value - sendETH); tokenSold += tokenFree; tokenFree = sharesTokenAddress.balanceOf(this); presaleClosed = true; } } TokenFree(tokenFree); PresaleClosed(presaleClosed); }",
        "vulnerability": "Lack of input validation",
        "reason": "The function does not validate the inputs thoroughly, leading to potential vulnerabilities. For instance, the realPrice calculation uses a floating-point operation on integers, which Solidity does not support. This may lead to inaccuracies in pricing logic, enabling an attacker to manipulate token purchases.",
        "file_name": "0x8c944c3f4029c14c22b6525ac3155482c2559541.sol"
    }
]