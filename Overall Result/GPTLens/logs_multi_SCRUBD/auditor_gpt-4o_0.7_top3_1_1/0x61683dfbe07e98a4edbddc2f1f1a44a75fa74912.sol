[
    {
        "function_name": "BDSM_Crowdsale",
        "code": "function BDSM_Crowdsale(address _tokenAddress, address _owner, address _stopScamHolder) { owner = _owner; sharesTokenAddress = token(_tokenAddress); safeContract = _stopScamHolder; }",
        "vulnerability": "Lack of input validation",
        "reason": "The constructor does not validate the input addresses, which can lead to deploying the contract with zero or invalid addresses. This may cause the contract to be non-functional or allow malicious actors to exploit the contract by passing in addresses they control.",
        "file_name": "0x61683dfbe07e98a4edbddc2f1f1a44a75fa74912.sol"
    },
    {
        "function_name": "fallback function",
        "code": "function() payable { if(now > priceIncrease_20_February){ price = \"0.007 Ether for 1 microBDSM\"; realPrice = 0.007 * 1 ether; } else if(now > priceIncrease_20_January){ price = \"0.00525 Ether for 1 microBDSM\"; realPrice = 0.00525 * 1 ether; } tokenFree = sharesTokenAddress.balanceOf(this); if (now < startICO_20_December) { msg.sender.transfer(msg.value); } else if (now > stopICO_20_March) { msg.sender.transfer(msg.value); if(!tokensWithdrawn){ sharesTokenAddress.transfer(safeContract, sharesTokenAddress.balanceOf(this)); tokenFree = sharesTokenAddress.balanceOf(this); tokensWithdrawn = true; crowdsaleClosed = true; } } else if (crowdsaleClosed) { msg.sender.transfer(msg.value); } else { uint256 tokenToBuy = msg.value / realPrice * coeff; if(tokenToBuy <= 0) msg.sender.transfer(msg.value); require(tokenToBuy > 0); uint256 actualETHTransfer = tokenToBuy * realPrice / coeff; if (tokenFree >= tokenToBuy) { owner.transfer(actualETHTransfer); if (msg.value > actualETHTransfer){ msg.sender.transfer(msg.value - actualETHTransfer); } sharesTokenAddress.transfer(msg.sender, tokenToBuy); tokenSold += tokenToBuy; tokenFree -= tokenToBuy; if(tokenFree==0) crowdsaleClosed = true; } else { uint256 sendETH = tokenFree * realPrice / coeff; owner.transfer(sendETH); sharesTokenAddress.transfer(msg.sender, tokenFree); msg.sender.transfer(msg.value - sendETH); tokenSold += tokenFree; tokenFree = sharesTokenAddress.balanceOf(this); crowdsaleClosed = true; } } TokenFree(tokenFree); CrowdsaleClosed(crowdsaleClosed); } }",
        "vulnerability": "Reentrancy vulnerability",
        "reason": "The fallback function allows for reentrancy as it uses transfer and balance checks after token transfers. An attacker could exploit this by calling the fallback function recursively before the state changes are finalized, effectively draining the contract of its tokens or Ether.",
        "file_name": "0x61683dfbe07e98a4edbddc2f1f1a44a75fa74912.sol"
    },
    {
        "function_name": "fallback function",
        "code": "function() payable { if(now > priceIncrease_20_February){ price = \"0.007 Ether for 1 microBDSM\"; realPrice = 0.007 * 1 ether; } else if(now > priceIncrease_20_January){ price = \"0.00525 Ether for 1 microBDSM\"; realPrice = 0.00525 * 1 ether; } tokenFree = sharesTokenAddress.balanceOf(this); if (now < startICO_20_December) { msg.sender.transfer(msg.value); } else if (now > stopICO_20_March) { msg.sender.transfer(msg.value); if(!tokensWithdrawn){ sharesTokenAddress.transfer(safeContract, sharesTokenAddress.balanceOf(this)); tokenFree = sharesTokenAddress.balanceOf(this); tokensWithdrawn = true; crowdsaleClosed = true; } } else if (crowdsaleClosed) { msg.sender.transfer(msg.value); } else { uint256 tokenToBuy = msg.value / realPrice * coeff; if(tokenToBuy <= 0) msg.sender.transfer(msg.value); require(tokenToBuy > 0); uint256 actualETHTransfer = tokenToBuy * realPrice / coeff; if (tokenFree >= tokenToBuy) { owner.transfer(actualETHTransfer); if (msg.value > actualETHTransfer){ msg.sender.transfer(msg.value - actualETHTransfer); } sharesTokenAddress.transfer(msg.sender, tokenToBuy); tokenSold += tokenToBuy; tokenFree -= tokenToBuy; if(tokenFree==0) crowdsaleClosed = true; } else { uint256 sendETH = tokenFree * realPrice / coeff; owner.transfer(sendETH); sharesTokenAddress.transfer(msg.sender, tokenFree); msg.sender.transfer(msg.value - sendETH); tokenSold += tokenFree; tokenFree = sharesTokenAddress.balanceOf(this); crowdsaleClosed = true; } } TokenFree(tokenFree); CrowdsaleClosed(crowdsaleClosed); } }",
        "vulnerability": "Incorrect token pricing logic",
        "reason": "The pricing logic allows for division before multiplication in the line `uint256 tokenToBuy = msg.value / realPrice * coeff;`, which can lead to truncation errors and incorrect token amounts being calculated. This could be exploited by an attacker to receive more tokens than they should for a given Ether amount.",
        "file_name": "0x61683dfbe07e98a4edbddc2f1f1a44a75fa74912.sol"
    }
]