[
    {
        "function_name": "editCounterPart",
        "vulnerability": "Lack of access control",
        "criticism": "The reasoning is correct. The function allows the swap creator to change the counterparty at any time without restrictions. This could lead to unauthorized changes and potential fund misdirection. The severity is high as it could lead to loss of funds, but the profitability is low as it requires the swap creator to act maliciously.",
        "correctness": 8,
        "severity": 8,
        "profitability": 2,
        "reason": "The function allows the swap creator to change the counterparty at any time without restrictions. This means that even after a swap has been initiated, the creator can change the counterparty which could lead to unauthorized changes and potential fund misdirection.",
        "code": "function editCounterPart(uint256 _swapId, address payable _counterPart) public { require(checksCreator[_swapId] == msg.sender, \"You're not the interested counterpart\"); require(msg.sender == swapList[msg.sender][swapMatch[_swapId]].addressOne, \"Message sender must be the swap creator\"); checksCounterparty[_swapId] = _counterPart; swapList[msg.sender][swapMatch[_swapId]].addressTwo = _counterPart; }",
        "file_name": "0x13d8faf4a690f5ae52e2d2c52938d1167057b9af.sol",
        "final_score": 6.5
    },
    {
        "function_name": "createSwapIntent",
        "vulnerability": "Whitelist bypass",
        "criticism": "The reasoning is correct. The function does not check the whitelist for custom 'typeStd' which could allow unauthorized dApps to execute transfers. However, the severity and profitability of this vulnerability are moderate, as it requires knowledge of the system's internals and the ability to create a custom 'typeStd'.",
        "correctness": 7,
        "severity": 5,
        "profitability": 5,
        "reason": "The function only checks the whitelist for transfers where the 'typeStd' is among ERC20, ERC721, and ERC1155 and uses a default transfer mechanism for others. If an attacker uses a custom typeStd that is not handled by the whitelist check, they can bypass the system's limitations, allowing unauthorized dApps to execute transfers.",
        "code": "function createSwapIntent(swapIntent memory _swapIntent, swapStruct[] memory _nftsOne, swapStruct[] memory _nftsTwo) payable public whenNotPaused nonReentrant { if(payment.status) { if(ERC721Interface(TRADESQUAD).balanceOf(msg.sender)==0) { require(msg.value>=payment.value.add(_swapIntent.valueOne), \"Not enought WEI for handle the transaction\"); _swapIntent.swapFee = getWeiPayValueAmount() ; } else { require(msg.value>=_swapIntent.valueOne, \"Not enought WEI for handle the transaction\"); _swapIntent.swapFee = 0 ; } } else require(msg.value>=_swapIntent.valueOne, \"Not enought WEI for handle the transaction\"); _swapIntent.addressOne = payable(msg.sender); _swapIntent.id = _swapIds.current(); checksCreator[_swapIntent.id] = _swapIntent.addressOne ; checksCounterparty[_swapIntent.id] = _swapIntent.addressTwo ; _swapIntent.swapStart = block.timestamp; _swapIntent.swapEnd = 0; _swapIntent.status = swapStatus.Opened ; swapMatch[_swapIds.current()] = swapList[msg.sender].length; swapList[msg.sender].push(_swapIntent); uint256 i; for(i=0; i<_nftsOne.length; i++) nftsOne[_swapIntent.id].push(_nftsOne[i]); for(i=0; i<_nftsTwo.length; i++) nftsTwo[_swapIntent.id].push(_nftsTwo[i]); for(i=0; i<nftsOne[_swapIntent.id].length; i++) { require(whiteList[nftsOne[_swapIntent.id][i].dapp], \"A DAPP is not handled by the system\"); if(nftsOne[_swapIntent.id][i].typeStd == ERC20) { ERC20Interface(nftsOne[_swapIntent.id][i].dapp).transferFrom(_swapIntent.addressOne, address(this), nftsOne[_swapIntent.id][i].blc[0]); } else if(nftsOne[_swapIntent.id][i].typeStd == ERC721) { ERC721Interface(nftsOne[_swapIntent.id][i].dapp).safeTransferFrom(_swapIntent.addressOne, address(this), nftsOne[_swapIntent.id][i].tokenId[0], nftsOne[_swapIntent.id][i].data); } else if(nftsOne[_swapIntent.id][i].typeStd == ERC1155) { ERC1155Interface(nftsOne[_swapIntent.id][i].dapp).safeBatchTransferFrom(_swapIntent.addressOne, address(this), nftsOne[_swapIntent.id][i].tokenId, nftsOne[_swapIntent.id][i].blc, nftsOne[_swapIntent.id][i].data); } else { customInterface(dappRelations[nftsOne[_swapIntent.id][i].dapp]).bridgeSafeTransferFrom(nftsOne[_swapIntent.id][i].dapp, _swapIntent.addressOne, dappRelations[nftsOne[_swapIntent.id][i].dapp], nftsOne[_swapIntent.id][i].tokenId, nftsOne[_swapIntent.id][i].blc, nftsOne[_swapIntent.id][i].data); } } emit swapEvent(msg.sender, (block.timestamp-(block.timestamp%secs)), _swapIntent.status, _swapIntent.id, _swapIntent.addressTwo); _swapIds.increment(); }",
        "file_name": "0x13d8faf4a690f5ae52e2d2c52938d1167057b9af.sol",
        "final_score": 6.0
    },
    {
        "function_name": "cancelSwapIntent",
        "vulnerability": "Improper refund logic",
        "criticism": "The reasoning is partially correct. The function does not check if the swap has already been partially or fully executed before allowing a cancellation. However, the function does check if the swap status is 'Opened' before proceeding with the cancellation. Therefore, the severity and profitability of this vulnerability are low, as it requires the swap creator to act maliciously and the counterparty to not check the swap status.",
        "correctness": 5,
        "severity": 3,
        "profitability": 2,
        "reason": "The cancelSwapIntent function does not check if the swap has already been partially or fully executed before allowing a cancellation. This could lead to scenarios where the creator cancels a swap after the counterparty has sent their assets, resulting in the creator regaining their assets without fulfilling their part of the trade.",
        "code": "function cancelSwapIntent(uint256 _swapId) public nonReentrant { require(checksCreator[_swapId] == msg.sender, \"You're not the interested counterpart\"); require(swapList[msg.sender][swapMatch[_swapId]].addressOne == msg.sender, \"You're not the interested counterpart\"); require(swapList[msg.sender][swapMatch[_swapId]].status == swapStatus.Opened, \"Swap Status is not opened\"); if(swapList[msg.sender][swapMatch[_swapId]].swapFee>0) payable(msg.sender).transfer(swapList[msg.sender][swapMatch[_swapId]].swapFee); uint256 i; for(i=0; i<nftsOne[_swapId].length; i++) { if(nftsOne[_swapId][i].typeStd == ERC20) { ERC20Interface(nftsOne[_swapId][i].dapp).transfer(swapList[msg.sender][swapMatch[_swapId]].addressOne, nftsOne[_swapId][i].blc[0]); } else if(nftsOne[_swapId][i].typeStd == ERC721) { ERC721Interface(nftsOne[_swapId][i].dapp).safeTransferFrom(address(this), swapList[msg.sender][swapMatch[_swapId]].addressOne, nftsOne[_swapId][i].tokenId[0], nftsOne[_swapId][i].data); } else if(nftsOne[_swapId][i].typeStd == ERC1155) { ERC1155Interface(nftsOne[_swapId][i].dapp).safeBatchTransferFrom(address(this), swapList[msg.sender][swapMatch[_swapId]].addressOne, nftsOne[_swapId][i].tokenId, nftsOne[_swapId][i].blc, nftsOne[_swapId][i].data); } else { customInterface(dappRelations[nftsOne[_swapId][i].dapp]).bridgeSafeTransferFrom(nftsOne[_swapId][i].dapp, dappRelations[nftsOne[_swapId][i].dapp], swapList[msg.sender][swapMatch[_swapId]].addressOne, nftsOne[_swapId][i].tokenId, nftsOne[_swapId][i].blc, nftsOne[_swapId][i].data); } } if(swapList[msg.sender][swapMatch[_swapId]].valueOne > 0) swapList[msg.sender][swapMatch[_swapId]].addressOne.transfer(swapList[msg.sender][swapMatch[_swapId]].valueOne); swapList[msg.sender][swapMatch[_swapId]].swapEnd = block.timestamp; swapList[msg.sender][swapMatch[_swapId]].status = swapStatus.Cancelled; emit swapEvent(msg.sender, (block.timestamp-(block.timestamp%secs)), swapStatus.Cancelled, _swapId, address(0)); }",
        "file_name": "0x13d8faf4a690f5ae52e2d2c52938d1167057b9af.sol",
        "final_score": 3.75
    }
]