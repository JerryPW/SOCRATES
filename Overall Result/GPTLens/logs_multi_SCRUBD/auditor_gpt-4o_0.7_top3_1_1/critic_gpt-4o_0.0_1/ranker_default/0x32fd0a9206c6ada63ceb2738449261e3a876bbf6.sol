[
    {
        "function_name": "remuneration",
        "vulnerability": "Reentrancy Vulnerability",
        "criticism": "The reasoning correctly identifies a reentrancy vulnerability due to the transfer of Ether before updating the state. This is a well-known and severe vulnerability that can lead to significant financial loss if exploited. The severity is high because it can allow an attacker to drain funds from the contract. The profitability is also high as an attacker can repeatedly withdraw Ether.",
        "correctness": 9,
        "severity": 8,
        "profitability": 8,
        "reason": "The function sends Ether to the caller (`msg.sender`) without updating the state before the transfer. An attacker can exploit this by recursively calling the function before the state is updated, causing multiple Ether withdrawals.",
        "code": "function remuneration(uint256 tokensAmount) external returns (bool) { require(_token.balanceOf(msg.sender) >= tokensAmount, \"Town tokens not found\"); require(_token.allowance(msg.sender, address(this)) >= tokensAmount, \"Town tokens must be approved for town smart contract\"); uint256 debt = 0; uint256 restOfTokens = tokensAmount; uint256 executedRequestCount = 0; for (uint256 i = 0; i < _queueTownTokenRequests.length; ++i) { address user = _queueTownTokenRequests[i]._address; uint256 rate = _queueTownTokenRequests[i]._info._rate; uint256 amount = _queueTownTokenRequests[i]._info._amount; if (restOfTokens > amount) { _token.transferFrom(msg.sender, user, amount); restOfTokens = restOfTokens.sub(amount); debt = debt.add(amount.mul(rate).div(10 ** 18)); executedRequestCount++; } else { break; } } if (restOfTokens > 0) { _token.transferFrom(msg.sender, address(this), restOfTokens); } if (executedRequestCount > 0) { for (uint256 i = executedRequestCount; i < _queueTownTokenRequests.length; ++i) { _queueTownTokenRequests[i - executedRequestCount] = _queueTownTokenRequests[i]; } for (uint256 i = 0; i < executedRequestCount; ++i) { _queueTownTokenRequests.pop(); } } if (_historyTransactions[msg.sender].length > 0) { for (uint256 i = _historyTransactions[msg.sender].length - 1; ; --i) { uint256 rate = _historyTransactions[msg.sender][i]._rate; uint256 amount = _historyTransactions[msg.sender][i]._amount; _historyTransactions[msg.sender].pop(); if (restOfTokens < amount) { TransactionsInfo memory info = TransactionsInfo(rate, amount.sub(restOfTokens)); _historyTransactions[msg.sender].push(info); debt = debt.add(restOfTokens.mul(rate).div(10 ** 18)); break; } debt = debt.add(amount.mul(rate).div(10 ** 18)); restOfTokens = restOfTokens.sub(amount); if (i == 0) break; } } if (debt > address(this).balance) { msg.sender.transfer(address(this).balance); RemunerationsInfo memory info = RemunerationsInfo(msg.sender, 2, debt.sub(address(this).balance)); _remunerationsQueue.push(info); } else { msg.sender.transfer(debt); } return true; }",
        "file_name": "0x32fd0a9206c6ada63ceb2738449261e3a876bbf6.sol",
        "final_score": 8.5
    },
    {
        "function_name": "sendExternalTokens",
        "vulnerability": "Lack of Distribution Count Check",
        "criticism": "The reasoning is correct in identifying a potential division by zero error due to the lack of a check on `_distributionPeriodsNumber`. This is a critical vulnerability as it can halt the contract execution, leading to a denial of service. The severity is high because it can disrupt the contract's functionality entirely. The profitability is moderate because while an attacker cannot directly profit from this, they can cause significant disruption.",
        "correctness": 8,
        "severity": 7,
        "profitability": 3,
        "reason": "The function does not check if `_distributionPeriodsNumber` is greater than zero before dividing by it. An attacker could set `_distributionPeriodsNumber` to zero, causing a division by zero error and halting the contract execution.",
        "code": "function sendExternalTokens(address official, address externalToken) external returns (bool) { Token tokenERC20 = Token(externalToken); uint256 balance = tokenERC20.allowance(official, address(this)); require(tokenERC20.balanceOf(official) >= balance, \"Official should have external tokens for approved\"); require(balance > 0, \"External tokens must be approved for town smart contract\"); tokenERC20.transferFrom(official, address(this), balance); ExternalTokenDistributionsInfo memory tokenInfo; tokenInfo._official = official; tokenInfo._distributionsCount = _distributionPeriodsNumber; tokenInfo._distributionAmount = balance.div(_distributionPeriodsNumber); ExternalToken storage tokenObj = _externalTokens[externalToken]; if (tokenObj._entities.length == 0) { _externalTokensAddresses.push(externalToken); } tokenObj._entities.push(tokenInfo); emit Proposal(balance, tokenInfo._official, tokenInfo._distributionsCount, tokenInfo._distributionAmount, externalToken); return true; }",
        "file_name": "0x32fd0a9206c6ada63ceb2738449261e3a876bbf6.sol",
        "final_score": 6.5
    },
    {
        "function_name": "distributionSnapshot",
        "vulnerability": "Integer Overflow/Underflow",
        "criticism": "The reasoning is correct in identifying the risk of integer overflow/underflow due to the lack of SafeMath usage. However, the severity is moderate because modern Solidity versions (0.8.0 and above) have built-in overflow/underflow checks. The profitability is low because exploiting this would require specific conditions and may not lead to direct financial gain.",
        "correctness": 7,
        "severity": 4,
        "profitability": 2,
        "reason": "The function performs arithmetic operations that may overflow or underflow without using SafeMath for critical computations. If not handled, this can lead to incorrect calculations and unintentional behavior of the contract.",
        "code": "function distributionSnapshot() external returns (bool) { require(block.timestamp > (_lastDistributionsDate + _distributionPeriod), \"distribution time has not yet arrived\"); uint256 sumWeight = 0; address[] memory tempArray; _externalTokensWithWight = tempArray; for (uint256 i = 0; i < _externalTokensAddresses.length; ++i) { ExternalToken memory externalToken = _externalTokens[_externalTokensAddresses[i]]; if (externalToken._weight > 0) { uint256 sumExternalTokens = 0; for (uint256 j = 0; j < externalToken._entities.length; ++j) { if (externalToken._entities[j]._distributionsCount > 0) { ExternalTokenDistributionsInfo memory info = externalToken._entities[j]; sumExternalTokens = sumExternalTokens.add(info._distributionAmount.mul(info._distributionsCount)); } } if (sumExternalTokens > _minExternalTokensAmount) { sumWeight = sumWeight.add(externalToken._weight); _externalTokensWithWight.push(_externalTokensAddresses[i]); } else { externalToken._weight = 0; } } } uint256 fullBalance = address(this).balance; for (uint256 i = 0; i < _externalTokensWithWight.length; ++i) { ExternalToken memory externalToken = _externalTokens[_externalTokensWithWight[i]]; uint256 sumExternalTokens = 0; for (uint256 j = 0; j < externalToken._entities.length; ++j) { sumExternalTokens = sumExternalTokens.add(externalToken._entities[j]._distributionAmount); } uint256 externalTokenCost = fullBalance.mul(externalToken._weight).div(sumWeight); for (uint256 j = 0; j < externalToken._entities.length; ++j) { address official = externalToken._entities[j]._official; uint256 tokensAmount = externalToken._entities[j]._distributionAmount; uint256 amount = externalTokenCost.mul(tokensAmount).div(sumExternalTokens); uint256 decayTimestamp = (block.timestamp - _lastDistributionsDate).div(_distributionPeriod).mul(_distributionPeriod).add(_lastDistributionsDate).add(_distributionPeriod); _officialsLedger[official] = RemunerationsOfficialsInfo(amount, decayTimestamp); } } uint256 sumHoldersTokens = _token.totalSupply().sub(_token.balanceOf(address(this))); if (sumHoldersTokens != 0) { for (uint256 i = 0; i < _token.getHoldersCount(); ++i) { address holder = _token.getHolderByIndex(i); uint256 balance = _token.balanceOf(holder); for (uint256 j = 0; j < _externalTokensAddresses.length; ++j) { address externalTokenAddress = _externalTokensAddresses[j]; ExternalToken memory externalToken = _externalTokens[externalTokenAddress]; for (uint256 k = 0; k < externalToken._entities.length; ++k) { if (holder != address(this) && externalToken._entities[k]._distributionsCount > 0) { uint256 percent = balance.mul(externalToken._entities[k]._distributionAmount).div(sumHoldersTokens); if (percent > (10 ** 4)) { address[] memory externalTokensForHolder = _ledgerExternalTokensAddresses[holder]; bool found = false; for (uint256 h = 0; h < externalTokensForHolder.length; ++h) { if (externalTokensForHolder[h] == externalTokenAddress) { found = true; break; } } if (found == false) { _ledgerExternalTokensAddresses[holder].push(externalTokenAddress); } _townHoldersLedger[holder][externalTokenAddress] = _townHoldersLedger[holder][externalTokenAddress].add(percent); } } } } } for (uint256 j = 0; j < _externalTokensAddresses.length; ++j) { ExternalTokenDistributionsInfo[] memory tempEntities = _externalTokens[_externalTokensAddresses[j]]._entities; delete _externalTokens[_externalTokensAddresses[j]]._entities; for (uint256 k = 0; k < tempEntities.length; ++k) { tempEntities[k]._distributionsCount--; if (tempEntities[k]._distributionsCount > 0) { _externalTokens[_externalTokensAddresses[j]]._entities.push(tempEntities[k]); } } } } for (uint256 i = 0; i < _externalTokensAddresses.length; ++i) { if (_externalTokens[_externalTokensAddresses[i]]._weight > 0) { _externalTokens[_externalTokensAddresses[i]]._weight = 0; } } _lastDistributionsDate = _lastDistributionsDate.add(_distributionPeriod); return true; }",
        "file_name": "0x32fd0a9206c6ada63ceb2738449261e3a876bbf6.sol",
        "final_score": 5.0
    }
]