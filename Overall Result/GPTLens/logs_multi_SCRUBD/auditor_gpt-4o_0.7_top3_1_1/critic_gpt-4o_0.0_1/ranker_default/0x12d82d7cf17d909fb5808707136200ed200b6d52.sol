[
    {
        "function_name": "removeOrder",
        "vulnerability": "Reentrancy vulnerability",
        "criticism": "The reasoning is correct. The function does not have reentrancy protection and uses a call to send ETH to the user. This could allow an attacker to re-enter the function and cause inconsistent state changes. However, the severity and profitability of this vulnerability are high only if the attacker is able to trigger the function in a way that benefits them.",
        "correctness": 8,
        "severity": 7,
        "profitability": 7,
        "reason": "The function uses a call to send ETH to the user without any checks for reentrancy protection. An attacker could exploit this by re-entering the function, potentially causing inconsistent state changes.",
        "code": "function removeOrder(uint256 indexOfOrder) public { if (indexOfOrder >= _userActions.length) return; require(_userActions[indexOfOrder].user == msg.sender || msg.sender == owner() || msg.sender == address(this)); if(msg.sender != address(this)){ _userActions[indexOfOrder].user.call{value: _transactionFee}(\"\"); } for (uint i = indexOfOrder; i<_userActions.length-1; i++){ _userActions[i] = _userActions[i+1]; } _userActions.pop(); }",
        "file_name": "0x12d82d7cf17d909fb5808707136200ed200b6d52.sol",
        "final_score": 7.5
    },
    {
        "function_name": "processUserTransactions",
        "vulnerability": "Lack of reentrancy guard",
        "criticism": "The reasoning is correct. The function contains multiple external calls, including a call to `removeOrder` which also has reentrancy issues. This exposes the function to potential reentrancy attacks. However, the severity and profitability of this vulnerability are high only if the attacker is able to trigger the function in a way that benefits them.",
        "correctness": 8,
        "severity": 7,
        "profitability": 7,
        "reason": "The function contains multiple external calls including a call to `removeOrder` which also has reentrancy issues. This exposes the function to potential reentrancy attacks, as attackers could re-enter the function through one of these external calls and manipulate the state.",
        "code": "function processUserTransactions(uint256 amountToProcess, swapInfoEntry[] memory swapInfo) public onlyOwner{ require(swapInfo.length == _tokensHeld.length); uint256 totalPoolValue = getContractTotalBalance(swapInfo); userInteractionInfo[] memory userActionsSnapshot = _userActions; processInfoStruct memory processingInfo = processInfoStruct(0,0,0,0,0); for (uint i = 0; i < amountToProcess; i++){ if(userActionsSnapshot[i].deposit == true){ if(userActionsSnapshot[i].deadline >= block.timestamp && IERC20(WETHAddress).allowance(userActionsSnapshot[i].user, address(this)) >= userActionsSnapshot[i].amount && IERC20(WETHAddress).balanceOf(userActionsSnapshot[i].user) >= userActionsSnapshot[i].amount ){ IERC20(WETHAddress).transferFrom(userActionsSnapshot[i].user, address(this), userActionsSnapshot[i].amount); processingInfo.platformFeeAmount += (userActionsSnapshot[i].amount * _factoryFee / 10**18); processingInfo.ownerFeeAmount += userActionsSnapshot[i].amount * _poolFee / 10**18; userActionsSnapshot[i].amount = userActionsSnapshot[i].amount - (userActionsSnapshot[i].amount * _poolFee / 10**18) - (userActionsSnapshot[i].amount * _factoryFee / 10**18); processingInfo.valueDeposited += userActionsSnapshot[i].amount; if(balanceOf(userActionsSnapshot[i].user) == 0){ _totalHolders++; } } else { userActionsSnapshot[i].amount = 0; } } else { if(userActionsSnapshot[i].deadline >= block.timestamp && allowance(userActionsSnapshot[i].user, address(this)) >= userActionsSnapshot[i].amount && balanceOf(userActionsSnapshot[i].user) >= userActionsSnapshot[i].amount){ ERC20Burnable(address(this)).burnFrom(userActionsSnapshot[i].user, userActionsSnapshot[i].amount); processingInfo.tokensWithdrawn += userActionsSnapshot[i].amount; processingInfo.withdrawals++; if(balanceOf(userActionsSnapshot[i].user) == 0){ _totalHolders--; } } else { userActionsSnapshot[i].amount = 0; } } removeOrder(0); } if(processingInfo.valueDeposited > 0){ uint256 valueIncreasePercentage = 0; uint256 amountToMint; uint256 tokensProcessed = 0; if(_tokensHeld.length > 0 && totalSupply() > 0){ for (uint i = 0; i < _tokensHeld.length; i++){ require(swapInfo[i].token == _tokensHeld[i]); uint256 value; if(swapInfo[i].pathToWETHV2.length != 0){ value = InvestmentLibrary.getQuoteV2(swapInfo[i].pathToWETHV2, IERC20(_tokensHeld[i]).balanceOf(address(this)) * 10**(18 - IERC20Metadata(_tokensHeld[i]).decimals())); } else { value = InvestmentLibrary.getQuoteV3(swapInfo[i].pathToWETHV3, IERC20(_tokensHeld[i]).balanceOf(address(this)) * 10**(18 - IERC20Metadata(_tokensHeld[i]).decimals())); } uint256 amountRecieved = _swapTokens(swapInfo[i].pathFromWETHV2, swapInfo[i].pathFromWETHV3, processingInfo.valueDeposited * (value * 10**18 / totalPoolValue) / 10**18, swapInfo[i].fromWETHMinimumAmountOut); valueIncreasePercentage += amountRecieved * 10**18 / (IERC20(_tokensHeld[i]).balanceOf(address(this)) - amountRecieved); tokensProcessed++; } amountToMint = (totalSupply() + processingInfo.tokensWithdrawn) * (valueIncreasePercentage / tokensProcessed) / 10**18; } else if(totalPoolValue > 0 && totalSupply() > 0) { amountToMint = (totalSupply() + processingInfo.tokensWithdrawn) * ((IERC20(WETHAddress).balanceOf(address(this)) - totalPoolValue - processingInfo.ownerFeeAmount - processingInfo.platformFeeAmount) * 10**18 / totalPoolValue) / 10**18; } else { amountToMint = processingInfo.valueDeposited * 100; } for (uint i = 0; i < amountToProcess; i++){ if(userActionsSnapshot[i].deposit == true && userActionsSnapshot[i].amount != 0){ _mint(userActionsSnapshot[i].user, amountToMint * (userActionsSnapshot[i].amount * 10**18 / processingInfo.valueDeposited) / 10**18); } } } if(processingInfo.tokensWithdrawn > 0){ uint256 WETHRecieved = (processingInfo.tokensWithdrawn * 10**18 / (totalSupply() + processingInfo.tokensWithdrawn)) * IERC20(WETHAddress).balanceOf(address(this)) / 10**18; address[] memory tokensHeldSnapshot = _tokensHeld; if(tokensHeldSnapshot.length > 0){ for (uint i = 0; i < tokensHeldSnapshot.length; i++){ require(swapInfo[i].token == tokensHeldSnapshot[i]); WETHRecieved += _swapTokens(swapInfo[i].pathToWETHV2, swapInfo[i].pathToWETHV3, IERC20(tokensHeldSnapshot[i]).balanceOf(address(this)) * (processingInfo.tokensWithdrawn * 10**18 / (totalSupply() + processingInfo.tokensWithdrawn)) / 10**18, swapInfo[i].toWETHMinimumAmountOut); } } processingInfo.platformFeeAmount += (WETHRecieved * _factoryFee / 10**18); processingInfo.ownerFeeAmount += WETHRecieved * _poolFee / 10**18; WETHRecieved = WETHRecieved - (WETHRecieved * _poolFee / 10**18) - (WETHRecieved * _factoryFee / 10**18); IWETH(WETHAddress).withdraw(WETHRecieved); for (uint i = 0; i < amountToProcess; i++){ if(userActionsSnapshot[i].deposit == false && userActionsSnapshot[i].amount != 0){ userActionsSnapshot[i].user.call{value: WETHRecieved * (userActionsSnapshot[i].amount * 10**18 / processingInfo.tokensWithdrawn) / 10**18}(\"\"); } } } IWETH WETHContract = IWETH(WETHAddress); WETHContract.withdraw(processingInfo.ownerFeeAmount); owner().call{value: address(this).balance}(\"\"); processFee(processingInfo.platformFeeAmount); emit transactionsProcessed(processingInfo); }",
        "file_name": "0x12d82d7cf17d909fb5808707136200ed200b6d52.sol",
        "final_score": 7.5
    },
    {
        "function_name": "removeFromPoolInstantly",
        "vulnerability": "Reentrancy vulnerability",
        "criticism": "The reasoning is correct. The function uses a call to transfer ETH to the user without any checks against reentrancy. This could allow an attacker to re-enter the function, causing repeated withdrawals and potentially draining the contract balance. However, the severity and profitability of this vulnerability are high only if the attacker is able to trigger the function in a way that benefits them.",
        "correctness": 8,
        "severity": 7,
        "profitability": 7,
        "reason": "The function uses a call to transfer ETH to the user without any checks against reentrancy. An attacker could exploit this by re-entering the function, causing repeated withdrawals and potentially draining the contract balance.",
        "code": "function removeFromPoolInstantly(uint256 amountToRemove, swapInfoEntry[] memory swapInfo) public { require(balanceOf(msg.sender) > 0); require(amountToRemove > 0); require(amountToRemove <= balanceOf(msg.sender)); require(swapInfo.length == _tokensHeld.length); _burn(msg.sender, amountToRemove); if(balanceOf(msg.sender) == 0){ _totalHolders--; } uint256 userShare = amountToRemove * 10**18 / (totalSupply() + amountToRemove); uint256 wethPayout = IERC20(WETHAddress).balanceOf(address(this)) * userShare / 10**18; address[] memory tokensHeldSnapshot = _tokensHeld; for (uint i = 0; i < tokensHeldSnapshot.length; i++){ require(swapInfo[i].token == tokensHeldSnapshot[i]); if((swapInfo[i].toWETHMinimumAmountOut == 0 && swapInfo[i].fromWETHMinimumAmountOut == 0) == false){ IERC20 tokenContract = IERC20(tokensHeldSnapshot[i]); uint256 wethRecieved = _swapTokens( swapInfo[i].pathToWETHV2, swapInfo[i].pathToWETHV3, tokenContract.balanceOf(address(this)) * userShare / 10**18, swapInfo[i].toWETHMinimumAmountOut ); wethPayout += wethRecieved; } } uint256 poolOwnerFeeAmount = wethPayout * _poolFee / 10**18; uint256 factoryFeeAmount = wethPayout * _factoryFee / 10**18; uint256 amountToPayToUser = wethPayout - factoryFeeAmount - poolOwnerFeeAmount; IWETH WETHContract = IWETH(WETHAddress); IERC20(WETHAddress).transfer(owner(), poolOwnerFeeAmount); processFee(factoryFeeAmount); WETHContract.withdraw(amountToPayToUser); msg.sender.call{value: amountToPayToUser}(\"\"); emit feePaidToOwner(msg.sender, owner(), poolOwnerFeeAmount); emit poolRemovedFrom(msg.sender, amountToRemove, amountToPayToUser); }",
        "file_name": "0x12d82d7cf17d909fb5808707136200ed200b6d52.sol",
        "final_score": 7.5
    }
]