[
    {
        "function_name": "placeBetRouletteProcess",
        "vulnerability": "Unchecked Arithmetic",
        "criticism": "The reasoning is correct. The function contains a while loop that decrements a uint8 value, 'tmpBetCount', without a bounds check to ensure it does not underflow. This may lead to an infinite loop or incorrect behavior. The severity and profitability of this vulnerability are high because it can cause severe exploitation and an external attacker can profit from this vulnerability.",
        "correctness": 9,
        "severity": 9,
        "profitability": 9,
        "reason": "The function contains a while loop that decrements a uint8 value, 'tmpBetCount', without a bounds check to ensure it does not underflow. This may lead to an infinite loop or incorrect behavior.",
        "code": "function placeBetRouletteProcess ( uint commit, uint[] memory betMask, uint[] memory betAmount ) internal returns (uint8 betsCount, uint128 locked) { BetRoulette storage betRoulette = betsRoulette[commit]; betsCount = 0; uint totalBetAmount = 0; uint8 addBets = betRoulette.betsCount; uint8 tmpBetCount = betRoulette.betsCount - 1; uint128 curLocked = 0; uint128 tmpLocked = 0; bool numIsAlredyLocked = false; uint8 bonuses = getBonusProgrammLevel(betRoulette.gambler); while (0 <= tmpBetCount) { require (betMask[tmpBetCount] > 0 && betMask[tmpBetCount] < MAX_BET_MASK, \"Mask should be within range.\"); if (betMask[tmpBetCount] == 38721851401) { require (betAmount[tmpBetCount] >= MIN_BET * 4 && betAmount[tmpBetCount] <= MAX_AMOUNT, \"Amount should be within range.\"); totalBetAmount += betAmount[tmpBetCount]; require (totalBetAmount <= msg.value, \"Total bets amount should be LTE amount\"); (betRoulette.mask[tmpBetCount], betRoulette.rollUnder[tmpBetCount], curLocked) = prepareBetRoulette(36864, betAmount[tmpBetCount] / 4, bonuses); betRoulette.amount[tmpBetCount] = betAmount[tmpBetCount] / 4; (betRoulette.mask[addBets], betRoulette.rollUnder[addBets], tmpLocked) = prepareBetRoulette(38654705664, betAmount[tmpBetCount] / 4, bonuses); betRoulette.amount[addBets] = betAmount[tmpBetCount] / 4; curLocked = (tmpLocked > curLocked) ? tmpLocked : curLocked; addBets += 1; (betRoulette.mask[addBets], betRoulette.rollUnder[addBets], tmpLocked) = prepareBetRoulette(9, betAmount[tmpBetCount] / 4, bonuses); betRoulette.amount[addBets] = betAmount[tmpBetCount] / 4; curLocked = (tmpLocked > curLocked) ? tmpLocked : curLocked; addBets += 1; (betRoulette.mask[addBets], betRoulette.rollUnder[addBets], tmpLocked) = prepareBetRoulette(67108864, betAmount[tmpBetCount] / 4, bonuses); betRoulette.amount[addBets] = betAmount[tmpBetCount] / 4; curLocked = (tmpLocked > curLocked) ? tmpLocked : curLocked; locked += curLocked; addBets += 1; betsCount += 4; } else if (betMask[tmpBetCount] == 39567790237) { require (betAmount[tmpBetCount] >= MIN_BET * 9 && betAmount[tmpBetCount] <= MAX_AMOUNT, \"Amount should be within range.\"); totalBetAmount += betAmount[tmpBetCount]; require (totalBetAmount <= msg.value, \"Total bets amount should be LTE amount\"); (betRoulette.mask[tmpBetCount], betRoulette.rollUnder[tmpBetCount], curLocked) = prepareBetRoulette( 144, betAmount[tmpBetCount] / 9, bonuses); betRoulette.amount[tmpBetCount] = betAmount[tmpBetCount] / 9; (betRoulette.mask[addBets], betRoulette.rollUnder[addBets], tmpLocked) = prepareBetRoulette( 36864, betAmount[tmpBetCount] / 9, bonuses); betRoulette.amount[addBets] = betAmount[tmpBetCount] / 9; curLocked = (tmpLocked > curLocked) ? tmpLocked : curLocked; addBets += 1; (betRoulette.mask[addBets], betRoulette.rollUnder[addBets], tmpLocked) = prepareBetRoulette( 2359296, betAmount[tmpBetCount] / 9, bonuses); betRoulette.amount[addBets] = betAmount[tmpBetCount] / 9; curLocked = (tmpLocked > curLocked) ? tmpLocked : curLocked; addBets += 1; (betRoulette.mask[addBets], betRoulette.rollUnder[addBets], tmpLocked) = prepareBetRoulette( 4718592, betAmount[tmpBetCount] / 9, bonuses); betRoulette.amount[addBets] = betAmount[tmpBetCount] / 9; curLocked = (tmpLocked > curLocked) ? tmpLocked : curLocked; addBets += 1; (betRoulette.mask[addBets], betRoulette.rollUnder[addBets], tmpLocked) = prepareBetRoulette( 38654705664, betAmount[tmpBetCount] / 9, bonuses); betRoulette.amount[addBets] = betAmount[tmpBetCount] / 9; curLocked = (tmpLocked > curLocked) ? tmpLocked : curLocked; addBets += 1; (betRoulette.mask[addBets], betRoulette.rollUnder[addBets], tmpLocked) = prepareBetRoulette( 905969664, betAmount[tmpBetCount] * 2 / 9, bonuses); betRoulette.amount[addBets] = betAmount[tmpBetCount] * 2 / 9; curLocked = (tmpLocked > curLocked) ? tmpLocked : curLocked; addBets += 1; (betRoulette.mask[addBets], betRoulette.rollUnder[addBets], tmpLocked) = prepareBetRoulette( 13, betAmount[tmpBetCount] * 2 / 9, bonuses); betRoulette.amount[addBets] = betAmount[tmpBetCount] * 2 / 9; curLocked = (tmpLocked > curLocked) ? tmpLocked : curLocked; locked += curLocked; addBets += 1; betsCount += 7; } else if (betMask[tmpBetCount] == 19328549442) { require (betAmount[tmpBetCount] >= MIN_BET * 5 && betAmount[tmpBetCount] <= MAX_AMOUNT, \"Amount should be within range.\"); totalBetAmount += betAmount[tmpBetCount]; require (totalBetAmount <= msg.value, \"Total bets amount should be LTE amount\"); (betRoulette.mask[addBets], betRoulette.rollUnder[addBets], curLocked) = prepareBetRoulette( 147456, betAmount[tmpBetCount] / 5, bonuses); betRoulette.amount[addBets] = betAmount[tmpBetCount] / 5; addBets += 1; (betRoulette.mask[addBets], betRoulette.rollUnder[addBets], tmpLocked) = prepareBetRoulette( 1179648, betAmount[tmpBetCount] / 5, bonuses); betRoulette.amount[addBets] = betAmount[tmpBetCount] / 5; curLocked += tmpLocked; (betRoulette.mask[tmpBetCount], betRoulette.rollUnder[tmpBetCount], tmpLocked) = prepareBetRoulette( 576, betAmount[tmpBetCount] / 5, bonuses); betRoulette.amount[tmpBetCount] = betAmount[tmpBetCount] / 5; curLocked = (tmpLocked > curLocked) ? tmpLocked : curLocked; addBets += 1; (betRoulette.mask[addBets], betRoulette.rollUnder[addBets], tmpLocked) = prepareBetRoulette( 19327352832, betAmount[tmpBetCount] / 5, bonuses); betRoulette.amount[addBets] = betAmount[tmpBetCount] / 5; curLocked = (tmpLocked > curLocked) ? tmpLocked : curLocked; addBets += 1; (betRoulette.mask[addBets], betRoulette.rollUnder[addBets], tmpLocked) = prepareBetRoulette( 2, betAmount[tmpBetCount] / 5, bonuses); betRoulette.amount[addBets] = betAmount[tmpBetCount] / 5; curLocked = (tmpLocked > curLocked) ? tmpLocked : curLocked; locked += curLocked; addBets += 1; betsCount += 5; } else if (betMask[tmpBetCount] == 78542613792) { require (betAmount[tmpBetCount] >= MIN_BET * 6 && betAmount[tmpBetCount] <= MAX_AMOUNT, \"Amount should be within range.\"); totalBetAmount += betAmount[tmpBetCount]; require (totalBetAmount <= msg.value, \"Total bets amount should be LTE amount\"); (betRoulette.mask[tmpBetCount], betRoulette.rollUnder[tmpBetCount], curLocked) = prepareBetRoulette( 288, betAmount[tmpBetCount] / 6, bonuses); betRoulette.amount[tmpBetCount] = betAmount[tmpBetCount] / 6; (betRoulette.mask[addBets], betRoulette.rollUnder[addBets], tmpLocked) = prepareBetRoulette( 3072, betAmount[tmpBetCount] / 6, bonuses); betRoulette.amount[addBets] = betAmount[tmpBetCount] / 6; curLocked = (tmpLocked > curLocked) ? tmpLocked : curLocked; addBets += 1; (betRoulette.mask[addBets], betRoulette.rollUnder[addBets], tmpLocked) = prepareBetRoulette( 73728, betAmount[tmpBetCount] / 6, bonuses); betRoulette.amount[addBets] = betAmount[tmpBetCount] / 6; curLocked = (tmpLocked > curLocked) ? tmpLocked : curLocked; addBets += 1; (betRoulette.mask[addBets], betRoulette.rollUnder[addBets], tmpLocked) = prepareBetRoulette( 25165824, betAmount[tmpBetCount] / 6, bonuses); betRoulette.amount[addBets] = betAmount[tmpBetCount] / 6; curLocked = (tmpLocked > curLocked) ? tmpLocked : curLocked; addBets += 1; (betRoulette.mask[addBets], betRoulette.rollUnder[addBets], tmpLocked) = prepareBetRoulette( 1207959552, betAmount[tmpBetCount] / 6, bonuses); betRoulette.amount[addBets] = betAmount[tmpBetCount] / 6; curLocked = (tmpLocked > curLocked) ? tmpLocked : curLocked; addBets += 1; (betRoulette.mask[addBets], betRoulette.rollUnder[addBets], tmpLocked) = prepareBetRoulette( 77309411328, betAmount[tmpBetCount] / 6, bonuses); betRoulette.amount[addBets] = betAmount[tmpBetCount] / 6; curLocked = (tmpLocked > curLocked) ? tmpLocked : curLocked; locked += curLocked; addBets += 1; betsCount += 6; } else { require (betAmount[tmpBetCount] >= MIN_BET && betAmount[tmpBetCount] <= MAX_AMOUNT, \"Amount should be within range.\"); totalBetAmount += betAmount[tmpBetCount]; require (totalBetAmount <= msg.value, \"Total bets amount should be LTE amount\"); (betRoulette.mask[tmpBetCount], betRoulette.rollUnder[tmpBetCount], tmpLocked) = prepareBetRoulette( betMask[tmpBetCount], betAmount[tmpBetCount], bonuses); if (uint8(((betRoulette.mask[tmpBetCount] * POPCNT_MULT) & POPCNT_MASK) % POPCNT_MODULO) != 1) { locked += tmpLocked; } else { if (!numIsAlredyLocked) { numIsAlredyLocked = true; locked += tmpLocked; } } betRoulette.amount[tmpBetCount] = betAmount[tmpBetCount]; betsCount += 1; } if (tmpBetCount == 0) break; tmpBetCount -= 1; } }",
        "file_name": "0x0c073c92e7684031cfc297b83ecc33619e864d18.sol",
        "final_score": 9.0
    },
    {
        "function_name": "acceptNextOwner",
        "vulnerability": "Unrestricted Owner Change",
        "criticism": "The reasoning is correct. The function does not reset the 'nextOwner' variable after ownership is transferred. This could potentially allow the previous owner to regain control by calling approveNextOwner again with the same address. However, the severity and profitability of this vulnerability are moderate because it depends on the previous owner's intention.",
        "correctness": 7,
        "severity": 5,
        "profitability": 5,
        "reason": "The function does not reset the 'nextOwner' variable after ownership is transferred. This could potentially allow the previous owner to regain control by calling approveNextOwner again with the same address.",
        "code": "function acceptNextOwner() external { require (msg.sender == nextOwner, \"Can only accept preapproved new owner.\"); owner = nextOwner; }",
        "file_name": "0x0c073c92e7684031cfc297b83ecc33619e864d18.sol",
        "final_score": 6.0
    },
    {
        "function_name": "setNewPercents",
        "vulnerability": "Unrestricted House Edge Adjustment",
        "criticism": "The reasoning is correct. The owner can set the house edge to any value as long as the total percentages do not exceed 30. This could allow the owner to set a very high house edge, potentially impacting the fairness of the game for players. However, the severity and profitability of this vulnerability are low because it depends on the owner's intention.",
        "correctness": 7,
        "severity": 3,
        "profitability": 1,
        "reason": "The owner can set the house edge to any value as long as the total percentages do not exceed 30. This could allow the owner to set a very high house edge, potentially impacting the fairness of the game for players.",
        "code": "function setNewPercents( uint8 newHouseEdgePercent, uint8 newDividendsPercent, uint8 newAdvertPercent ) external onlyOwner { require(newDividendsPercent >= 5); require(newHouseEdgePercent + newDividendsPercent + newAdvertPercent <= 30); HOUSE_EDGE_PERCENT = newHouseEdgePercent; ADVERTISE_PERCENT = newAdvertPercent; DIVIDENDS_PERCENT = newDividendsPercent; }",
        "file_name": "0x0c073c92e7684031cfc297b83ecc33619e864d18.sol",
        "final_score": 4.5
    }
]