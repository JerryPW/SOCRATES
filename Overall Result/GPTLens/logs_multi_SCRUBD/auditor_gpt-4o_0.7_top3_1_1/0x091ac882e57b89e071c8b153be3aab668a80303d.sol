[
    {
        "function_name": "claimExternalTokens",
        "code": "function claimExternalTokens(address holder) public returns (bool) { address[] memory externalTokensForHolder = _ledgerExternalTokensAddresses[holder]; if (externalTokensForHolder.length > 0) { for (uint256 i = externalTokensForHolder.length - 1; ; --i) { ERC20(externalTokensForHolder[i]).transfer(holder, _townHoldersLedger[holder][externalTokensForHolder[i]]); delete _townHoldersLedger[holder][externalTokensForHolder[i]]; delete _ledgerExternalTokensAddresses[holder][i]; _ledgerExternalTokensAddresses[holder].length--; if (i == 0) break; } } return true; }",
        "vulnerability": "Reentrancy vulnerability",
        "reason": "The function transfers tokens to the holder before deleting the ledger entries. If the token being transferred is a malicious contract, it can call back into this contract and cause unexpected behavior or state manipulation during the reentrancy.",
        "file_name": "0x091ac882e57b89e071c8b153be3aab668a80303d.sol"
    },
    {
        "function_name": "remuneration",
        "code": "function remuneration(uint256 tokensAmount) external returns (bool) { require(_token.balanceOf(msg.sender) >= tokensAmount, \"Town tokens not found\"); require(_token.allowance(msg.sender, address(this)) >= tokensAmount, \"Town tokens must be approved for town smart contract\"); uint256 debt = 0; uint256 restOfTokens = tokensAmount; uint256 executedRequestCount = 0; for (uint256 i = 0; i < _queueTownTokenRequests.length; ++i) { address user = _queueTownTokenRequests[i]._address; uint256 rate = _queueTownTokenRequests[i]._info._rate; uint256 amount = _queueTownTokenRequests[i]._info._amount; if (restOfTokens > amount) { _token.transferFrom(msg.sender, user, amount); restOfTokens = restOfTokens.sub(amount); debt = debt.add(amount.mul(rate).div(10 ** 18)); executedRequestCount++; } else { break; } } if (restOfTokens > 0) { _token.transferFrom(msg.sender, address(this), restOfTokens); } if (executedRequestCount > 0) { for (uint256 i = executedRequestCount; i < _queueTownTokenRequests.length; ++i) { _queueTownTokenRequests[i - executedRequestCount] = _queueTownTokenRequests[i]; } for (uint256 i = 0; i < executedRequestCount; ++i) { delete _queueTownTokenRequests[_queueTownTokenRequests.length - 1]; _queueTownTokenRequests.length--; } } if (_historyTransactions[msg.sender].length > 0) { for (uint256 i = _historyTransactions[msg.sender].length - 1; ; --i) { uint256 rate = _historyTransactions[msg.sender][i]._rate; uint256 amount = _historyTransactions[msg.sender][i]._amount; delete _historyTransactions[msg.sender][i]; _historyTransactions[msg.sender].length--; if (restOfTokens < amount) { TransactionsInfo memory info = TransactionsInfo(rate, amount.sub(restOfTokens)); _historyTransactions[msg.sender].push(info); debt = debt.add(restOfTokens.mul(rate).div(10 ** 18)); break; } debt = debt.add(amount.mul(rate).div(10 ** 18)); restOfTokens = restOfTokens.sub(amount); if (i == 0) break; } } if (debt > address(this).balance) { msg.sender.transfer(address(this).balance); RemunerationsInfo memory info = RemunerationsInfo(msg.sender, 2, debt.sub(address(this).balance)); _remunerationsQueue.push(info); } else { msg.sender.transfer(debt); } return true; }",
        "vulnerability": "Integer underflow/overflow vulnerability",
        "reason": "The `debt` calculation uses multiplication and division operations that can result in integer overflow or underflow if the input values are not properly checked. This can lead to incorrect debt calculations and fund distribution.",
        "file_name": "0x091ac882e57b89e071c8b153be3aab668a80303d.sol"
    },
    {
        "function_name": "getTownTokens",
        "code": "function getTownTokens(address holder) public payable returns (bool) { require(holder != address(0), \"holder address cannot be null\"); uint256 amount = msg.value; uint256 tokenAmount = IWantTakeTokensToAmount(amount); uint256 rate = currentRate(); if (_transactionsCount < _durationOfMinTokenGetAmount && tokenAmount < _minTokenGetAmount) { return false; } if (tokenAmount >= _maxTokenGetAmount) { tokenAmount = _maxTokenGetAmount; uint256 change = amount.sub(_maxTokenGetAmount.mul(rate).div(10 ** 18)); msg.sender.transfer(change); amount = amount.sub(change); } if (_token.balanceOf(address(this)) >= tokenAmount) { TransactionsInfo memory transactionsHistory = TransactionsInfo(rate, tokenAmount); _token.transfer(holder, tokenAmount); _historyTransactions[holder].push(transactionsHistory); _transactionsCount = _transactionsCount.add(1); } else { if (_token.balanceOf(address(this)) > 0) { uint256 tokenBalance = _token.balanceOf(address(this)); _token.transfer(holder, tokenBalance); TransactionsInfo memory transactionsHistory = TransactionsInfo(rate, tokenBalance); _historyTransactions[holder].push(transactionsHistory); tokenAmount = tokenAmount.sub(tokenBalance); } TransactionsInfo memory transactionsInfo = TransactionsInfo(rate, tokenAmount); TownTokenRequest memory tokenRequest = TownTokenRequest(holder, transactionsInfo); _queueTownTokenRequests.push(tokenRequest); } for (uint256 i = 0; i < _remunerationsQueue.length; ++i) { if (_remunerationsQueue[i]._priority == 1) { if (_remunerationsQueue[i]._amount > amount) { _remunerationsQueue[i]._address.transfer(_remunerationsQueue[i]._amount); amount = amount.sub(_remunerationsQueue[i]._amount); delete _remunerationsQueue[i]; for (uint j = i + 1; j < _remunerationsQueue.length; ++j) { _remunerationsQueue[j - 1] = _remunerationsQueue[j]; } _remunerationsQueue.length--; } else { _remunerationsQueue[i]._address.transfer(amount); _remunerationsQueue[i]._amount = _remunerationsQueue[i]._amount.sub(amount); break; } } } for (uint256 i = 0; i < _remunerationsQueue.length; ++i) { if (_remunerationsQueue[i]._amount > amount) { _remunerationsQueue[i]._address.transfer(_remunerationsQueue[i]._amount); amount = amount.sub(_remunerationsQueue[i]._amount); delete _remunerationsQueue[i]; for (uint j = i + 1; j < _remunerationsQueue.length; ++j) { _remunerationsQueue[j - 1] = _remunerationsQueue[j]; } _remunerationsQueue.length--; } else { _remunerationsQueue[i]._address.transfer(amount); _remunerationsQueue[i]._amount = _remunerationsQueue[i]._amount.sub(amount); break; } } return true; }",
        "vulnerability": "Improper handling of token requests and potential reentrancy",
        "reason": "The function attempts to handle token requests and remuneration in a complex manner, which can lead to vulnerabilities such as reentrancy attacks. If an external contract calls back into this function during a token transfer, it may manipulate the state and cause unexpected behavior.",
        "file_name": "0x091ac882e57b89e071c8b153be3aab668a80303d.sol"
    }
]