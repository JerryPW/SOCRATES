[
    {
        "function_name": "mintProof",
        "code": "function mintProof(uint256 mintCount,address receiveAds,bytes32[] memory proof) public payable { require(!isContract(msg.sender),\"not supper contract mint\"); require(mintCount > 0, \"Invalid mint count\"); require(mintCount <= _maxMintPerAddress, \"Exceeded maximum mint count per address\"); require(msg.value >= mintCount*_mintPrice, \"illegal price\"); require(_mintCounts[msg.sender]+mintCount <= _maxMintPerAddress, \"over limit\"); receiveAds = msg.sender; if(isZero(wlRoot)){ require(block.timestamp >= mintStartTime, \"Minting has not started yet\"); require(block.timestamp <= mintEndTime, \"Minting has ended\"); }else { if (block.timestamp<wlMintedEndTime){ require(wlMintedCounts+mintCount<=wlMintCounts,\"over limit\"); bytes32 leaf = keccak256(abi.encodePacked(msg.sender)); require(MerkleProof.verify(proof, wlRoot, leaf),\"Not In Wl\"); wlMintedCounts += mintCount; } } if (block.timestamp<wlMintedEndTime){ require(_mintedCounts-wlMintedCounts+mintCount <= (_maxMintCount - wlMintedCounts), \"illegal mintAmount\"); } IWETH(wethAddress).deposit{value: msg.value*(1000-deployReserveEthPro-donateEthPro)/1000}(); IWETH(wethAddress).approve(lpContract, msg.value*(1000-deployReserveEthPro-donateEthPro)/1000); IWETH(wethAddress).transferFrom(address(this), lpContract, msg.value*(1000-deployReserveEthPro-donateEthPro)/1000); uint256 mintAmount = (totalSupply() * _maxPro * mintCount) / (_maxMintCount * 2000000); for (uint256 i = 0; i < contractAuths.length; i++) { if (contractAuths[i].contractType == ContractType.ERC721) { if(validateNftNumber==1){ IERC721Enumerable eRC721Enumerable = IERC721Enumerable(contractAuths[i].contractAddress); uint256 tokenId = eRC721Enumerable.tokenOfOwnerByIndex(msg.sender, 0); require(!tokenExists[tokenId],\"had used!\"); tokenExists[tokenId] = true; } uint256 tokenCount = getERC721TokenCount(contractAuths[i].contractAddress); require(tokenCount >= contractAuths[i].tokenCount, \"Insufficient ERC721 tokens\"); } else if (contractAuths[i].contractType == ContractType.ERC20) { uint256 tokenCount = getERC20TokenCount(contractAuths[i].contractAddress); require(tokenCount >= contractAuths[i].tokenCount, \"Insufficient ERC20 tokens\"); } else if (contractAuths[i].contractType == ContractType.ERC1155) { uint256 tokenCount = getERC1155TokenCount(contractAuths[i].contractAddress, 0); require(tokenCount >= contractAuths[i].tokenCount, \"Insufficient ERC1155 tokens\"); } } _transfer(address(this), receiveAds, mintAmount); _transfer(address(this), lpContract, mintAmount); IUniswapV2Pair(lpContract).sync(); _mintCounts[msg.sender] += mintCount; _mintedCounts += mintCount; }",
        "vulnerability": "Reentrancy vulnerability in mintProof",
        "reason": "The `mintProof` function involves multiple external calls to the WETH contract for deposit, approval, and transfer. This sequence of operations can potentially introduce a reentrancy vulnerability because an attacker could exploit these external calls to execute code via a crafted contract. This could allow the attacker to manipulate state variables such as `_mintCounts` and `_mintedCounts` before they are correctly updated, potentially minting more tokens than intended.",
        "file_name": "0x0321be5f545ea569424aace4dc08d60f467229ac.sol"
    },
    {
        "function_name": "transferFrom",
        "code": "function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) { uint256 burnAddressAmount = amount * burnAddressPer / 1000; uint256 burnBlockAmount = amount * burnBlockPer / 1000; uint256 burnAirDropAmount = amount * burnAirDropPer / 1000; uint256 transferAmount = amount - burnAddressAmount -burnBlockAmount-burnAirDropAmount; super._transfer(sender, recipient, transferAmount); if(burnAddressAmount>0){ super._transfer(sender, burnAddress, burnAddressAmount); } if(burnBlockAmount>0){ super._transfer(sender, blackHole, burnBlockAmount); } if(burnAirDropAmount>0){ super._transfer(sender, airDropAddress, burnAirDropAmount); } uint256 currentAllowance = allowance(sender, msg.sender); require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\"); super._approve(sender, msg.sender, currentAllowance - amount); return true; }",
        "vulnerability": "Incorrect order of allowance check",
        "reason": "In the `transferFrom` function, the allowance is checked after the transfer operations. This means that the `_transfer` function could be executed even if the allowance is insufficient, as the check is performed after the transfer. As a result, the transfer could occur with an allowance that should not permit it, leading to unauthorized transfers.",
        "file_name": "0x0321be5f545ea569424aace4dc08d60f467229ac.sol"
    },
    {
        "function_name": "deployAwardToken",
        "code": "function deployAwardToken() external { require(_mintedCounts==_maxMintCount,\"waiting mint finish\"); require(msg.sender==_deplyAddress,\"not deplyer\"); require(totalTokensClaimed <= totalTokensLocked, \"All tokens have been claimed.\"); uint256 currentTimestamp = block.timestamp; uint256 lockEndTime = deployTime + (tokenLockDays * 86400); uint256 unlockTimes = (lockEndTime - currentTimestamp) / ((tokenLockDays / tokenUnlockCounts) * 86400) - hadTokenUnlockCounts; uint256 claimableTokens; IERC20 token2 = IERC20(address(this)); if (unlockTimes >= tokenUnlockCounts) { claimableTokens = token2.balanceOf(address(this)); hadTokenUnlockCounts = tokenUnlockCounts; } else { require(unlockTimes>0,\"not have unlock times!\"); claimableTokens = unlockTimes * (totalTokensLocked/tokenUnlockCounts); hadTokenUnlockCounts += unlockTimes; } token2.transfer(msg.sender, claimableTokens); }",
        "vulnerability": "Incorrect token unlock logic",
        "reason": "The `deployAwardToken` function contains flawed logic in calculating `unlockTimes`. The calculation `(lockEndTime - currentTimestamp) / ((tokenLockDays / tokenUnlockCounts) * 86400) - hadTokenUnlockCounts` can result in negative `unlockTimes`, which is not handled properly. If `unlockTimes` becomes negative due to incorrect calculation or timing, it can lead to bypassing the `require` check for `unlockTimes > 0`, allowing the attacker to claim tokens earlier than intended or multiple times.",
        "file_name": "0x0321be5f545ea569424aace4dc08d60f467229ac.sol"
    }
]