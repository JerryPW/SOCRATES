[
    {
        "function_name": "createSwapIntent",
        "code": "function createSwapIntent(swapIntent memory _swapIntent, swapStruct[] memory _nftsOne, swapStruct[] memory _nftsTwo) payable public whenNotPaused nonReentrant { if(payment.status) { if(ERC721Interface(TRADESQUAD).balanceOf(msg.sender)==0) { require(msg.value>=payment.value.add(_swapIntent.valueOne), \"Not enought WEI for handle the transaction\"); _swapIntent.swapFee = getWeiPayValueAmount() ; } else { require(msg.value>=_swapIntent.valueOne, \"Not enought WEI for handle the transaction\"); _swapIntent.swapFee = 0 ; } } else require(msg.value>=_swapIntent.valueOne, \"Not enought WEI for handle the transaction\"); _swapIntent.addressOne = payable(msg.sender); _swapIntent.id = _swapIds.current(); checksCreator[_swapIntent.id] = _swapIntent.addressOne ; checksCounterparty[_swapIntent.id] = _swapIntent.addressTwo ; _swapIntent.swapStart = block.timestamp; _swapIntent.swapEnd = 0; _swapIntent.status = swapStatus.Opened ; swapMatch[_swapIds.current()] = swapList[msg.sender].length; swapList[msg.sender].push(_swapIntent); uint256 i; for(i=0; i<_nftsOne.length; i++) nftsOne[_swapIntent.id].push(_nftsOne[i]); for(i=0; i<_nftsTwo.length; i++) nftsTwo[_swapIntent.id].push(_nftsTwo[i]); for(i=0; i<nftsOne[_swapIntent.id].length; i++) { require(whiteList[nftsOne[_swapIntent.id][i].dapp], \"A DAPP is not handled by the system\"); if(nftsOne[_swapIntent.id][i].typeStd == ERC20) { ERC20Interface(nftsOne[_swapIntent.id][i].dapp).transferFrom(_swapIntent.addressOne, address(this), nftsOne[_swapIntent.id][i].blc[0]); } else if(nftsOne[_swapIntent.id][i].typeStd == ERC721) { ERC721Interface(nftsOne[_swapIntent.id][i].dapp).safeTransferFrom(_swapIntent.addressOne, address(this), nftsOne[_swapIntent.id][i].tokenId[0], nftsOne[_swapIntent.id][i].data); } else if(nftsOne[_swapIntent.id][i].typeStd == ERC1155) { ERC1155Interface(nftsOne[_swapIntent.id][i].dapp).safeBatchTransferFrom(_swapIntent.addressOne, address(this), nftsOne[_swapIntent.id][i].tokenId, nftsOne[_swapIntent.id][i].blc, nftsOne[_swapIntent.id][i].data); } else { customInterface(dappRelations[nftsOne[_swapIntent.id][i].dapp]).bridgeSafeTransferFrom(nftsOne[_swapIntent.id][i].dapp, _swapIntent.addressOne, dappRelations[nftsOne[_swapIntent.id][i].dapp], nftsOne[_swapIntent.id][i].tokenId, nftsOne[_swapIntent.id][i].blc, nftsOne[_swapIntent.id][i].data); } } emit swapEvent(msg.sender, (block.timestamp-(block.timestamp%secs)), _swapIntent.status, _swapIntent.id, _swapIntent.addressTwo); _swapIds.increment(); }",
        "vulnerability": "Whitelist bypass",
        "reason": "The function only checks the whitelist for transfers where the 'typeStd' is among ERC20, ERC721, and ERC1155 and uses a default transfer mechanism for others. If an attacker uses a custom typeStd that is not handled by the whitelist check, they can bypass the system's limitations, allowing unauthorized dApps to execute transfers.",
        "file_name": "0x13d8faf4a690f5ae52e2d2c52938d1167057b9af.sol"
    },
    {
        "function_name": "editCounterPart",
        "code": "function editCounterPart(uint256 _swapId, address payable _counterPart) public { require(checksCreator[_swapId] == msg.sender, \"You're not the interested counterpart\"); require(msg.sender == swapList[msg.sender][swapMatch[_swapId]].addressOne, \"Message sender must be the swap creator\"); checksCounterparty[_swapId] = _counterPart; swapList[msg.sender][swapMatch[_swapId]].addressTwo = _counterPart; }",
        "vulnerability": "Lack of access control",
        "reason": "The function allows the swap creator to change the counterparty at any time without restrictions. This means that even after a swap has been initiated, the creator can change the counterparty which could lead to unauthorized changes and potential fund misdirection.",
        "file_name": "0x13d8faf4a690f5ae52e2d2c52938d1167057b9af.sol"
    },
    {
        "function_name": "cancelSwapIntent",
        "code": "function cancelSwapIntent(uint256 _swapId) public nonReentrant { require(checksCreator[_swapId] == msg.sender, \"You're not the interested counterpart\"); require(swapList[msg.sender][swapMatch[_swapId]].addressOne == msg.sender, \"You're not the interested counterpart\"); require(swapList[msg.sender][swapMatch[_swapId]].status == swapStatus.Opened, \"Swap Status is not opened\"); if(swapList[msg.sender][swapMatch[_swapId]].swapFee>0) payable(msg.sender).transfer(swapList[msg.sender][swapMatch[_swapId]].swapFee); uint256 i; for(i=0; i<nftsOne[_swapId].length; i++) { if(nftsOne[_swapId][i].typeStd == ERC20) { ERC20Interface(nftsOne[_swapId][i].dapp).transfer(swapList[msg.sender][swapMatch[_swapId]].addressOne, nftsOne[_swapId][i].blc[0]); } else if(nftsOne[_swapId][i].typeStd == ERC721) { ERC721Interface(nftsOne[_swapId][i].dapp).safeTransferFrom(address(this), swapList[msg.sender][swapMatch[_swapId]].addressOne, nftsOne[_swapId][i].tokenId[0], nftsOne[_swapId][i].data); } else if(nftsOne[_swapId][i].typeStd == ERC1155) { ERC1155Interface(nftsOne[_swapId][i].dapp).safeBatchTransferFrom(address(this), swapList[msg.sender][swapMatch[_swapId]].addressOne, nftsOne[_swapId][i].tokenId, nftsOne[_swapId][i].blc, nftsOne[_swapId][i].data); } else { customInterface(dappRelations[nftsOne[_swapId][i].dapp]).bridgeSafeTransferFrom(nftsOne[_swapId][i].dapp, dappRelations[nftsOne[_swapId][i].dapp], swapList[msg.sender][swapMatch[_swapId]].addressOne, nftsOne[_swapId][i].tokenId, nftsOne[_swapId][i].blc, nftsOne[_swapId][i].data); } } if(swapList[msg.sender][swapMatch[_swapId]].valueOne > 0) swapList[msg.sender][swapMatch[_swapId]].addressOne.transfer(swapList[msg.sender][swapMatch[_swapId]].valueOne); swapList[msg.sender][swapMatch[_swapId]].swapEnd = block.timestamp; swapList[msg.sender][swapMatch[_swapId]].status = swapStatus.Cancelled; emit swapEvent(msg.sender, (block.timestamp-(block.timestamp%secs)), swapStatus.Cancelled, _swapId, address(0)); }",
        "vulnerability": "Improper refund logic",
        "reason": "The cancelSwapIntent function does not check if the swap has already been partially or fully executed before allowing a cancellation. This could lead to scenarios where the creator cancels a swap after the counterparty has sent their assets, resulting in the creator regaining their assets without fulfilling their part of the trade.",
        "file_name": "0x13d8faf4a690f5ae52e2d2c52938d1167057b9af.sol"
    }
]