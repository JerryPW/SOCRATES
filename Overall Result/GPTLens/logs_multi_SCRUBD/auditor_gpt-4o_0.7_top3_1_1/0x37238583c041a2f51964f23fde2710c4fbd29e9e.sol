[
    {
        "function_name": "endRound",
        "code": "function endRound(BATMODatasets.EventReturns memory _eventData_) private returns (BATMODatasets.EventReturns) { uint256 _rID = rID_; uint256 _winPID = round_[_rID].plyr; uint256 _winTID = round_[_rID].team; uint256 _pot = round_[_rID].pot; uint256 _win = (_pot.mul(48)) / 100; uint256 _dev = (_pot / 50); uint256 _gen = (_pot.mul(potSplit_[_winTID].gen)) / 100; uint256 _OBOK = (_pot.mul(potSplit_[_winTID].obok)) / 100; uint256 _res = (((_pot.sub(_win)).sub(_dev)).sub(_gen)).sub(_OBOK); uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys); uint256 _dust = _gen.sub((_ppt.mul(round_[_rID].keys)) / 1000000000000000000); if (_dust > 0) { _gen = _gen.sub(_dust); _res = _res.add(_dust); } plyr_[_winPID].win = _win.add(plyr_[_winPID].win); admin.transfer(_dev / 2); admin2.transfer(_dev / 2); address(ObokContract).call.value(_OBOK.sub((_OBOK / 3).mul(2)))(bytes4(keccak256(\"donateDivs()\"))); round_[_rID].pot = _pot.add(_OBOK / 3); round_[_rID].mask = _ppt.add(round_[_rID].mask); _eventData_.compressedData = _eventData_.compressedData + (round_[_rID].end * 1000000); _eventData_.compressedIDs = _eventData_.compressedIDs + (_winPID * 100000000000000000000000000) + (_winTID * 100000000000000000); _eventData_.winnerAddr = plyr_[_winPID].addr; _eventData_.winnerName = plyr_[_winPID].name; _eventData_.amountWon = _win; _eventData_.genAmount = _gen; _eventData_.tokenAmount = _OBOK; _eventData_.newPot = _res; rID_++; _rID++; round_[_rID].strt = now; round_[_rID].end = now.add(rndInit_).add(rndGap_); round_[_rID].pot += _res; return(_eventData_); }",
        "vulnerability": "Unrestricted External Call",
        "reason": "The use of `call.value()` in `address(ObokContract).call.value(_OBOK.sub((_OBOK / 3).mul(2)))(bytes4(keccak256(\"donateDivs()\")));` allows for potential reentrancy attacks, especially if the `donateDivs` function is not properly controlled or audited. The external call to another contract without checks or using a more secure pattern like `transfer` or `send` can make the contract vulnerable to reentrancy.",
        "file_name": "0x37238583c041a2f51964f23fde2710c4fbd29e9e.sol"
    },
    {
        "function_name": "distributeExternal",
        "code": "function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, BATMODatasets.EventReturns memory _eventData_) private returns(BATMODatasets.EventReturns) { uint256 _p1 = _eth / 100; uint256 _dev = _eth / 50; _dev = _dev.add(_p1); uint256 _OBOK; if (!address(admin).call.value(_dev/2)() && !address(admin2).call.value(_dev/2)()) { _OBOK = _dev; _dev = 0; } uint256 _aff = _eth / 10; if (_affID != _pID && plyr_[_affID].name != '') { plyr_[_affID].aff = _aff.add(plyr_[_affID].aff); emit FOMOEvents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now); } else { _OBOK = _aff; } _OBOK = _OBOK.add((_eth.mul(fees_[_team].obok)) / (100)); if (_OBOK > 0) { uint256 _potAmount = _OBOK / 2; address(ObokContract).call.value(_OBOK.sub(_potAmount))(bytes4(keccak256(\"donateDivs()\"))); round_[_rID].pot = round_[_rID].pot.add(_potAmount); _eventData_.tokenAmount = _OBOK.add(_eventData_.tokenAmount); } return(_eventData_); }",
        "vulnerability": "Unrestricted External Call",
        "reason": "Similar to the `endRound` function, `distributeExternal` makes external calls using `call.value()`, which can lead to reentrancy issues if the called contract has malicious or buggy code. The outcome of the external calls is not properly handled, making the contract susceptible to unexpected behaviors if the external call fails.",
        "file_name": "0x37238583c041a2f51964f23fde2710c4fbd29e9e.sol"
    },
    {
        "function_name": "withdraw",
        "code": "function withdraw() isActivated() isHuman() public { uint256 _rID = rID_; uint256 _now = now; uint256 _pID = pIDxAddr_[msg.sender]; uint256 _eth; if (_now > round_[_rID].end && round_[_rID].ended == false && round_[_rID].plyr != 0) { BATMODatasets.EventReturns memory _eventData_; round_[_rID].ended = true; _eventData_ = endRound(_eventData_); _eth = withdrawEarnings(_pID); if (_eth > 0) plyr_[_pID].addr.transfer(_eth); _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000); _eventData_.compressedIDs = _eventData_.compressedIDs + _pID; emit FOMOEvents.onWithdrawAndDistribute ( msg.sender, plyr_[_pID].name, _eth, _eventData_.compressedData, _eventData_.compressedIDs, _eventData_.winnerAddr, _eventData_.winnerName, _eventData_.amountWon, _eventData_.newPot, _eventData_.tokenAmount, _eventData_.genAmount ); } else { _eth = withdrawEarnings(_pID); if (_eth > 0) plyr_[_pID].addr.transfer(_eth); emit FOMOEvents.onWithdraw(_pID, msg.sender, plyr_[_pID].name, _eth, _now); } }",
        "vulnerability": "Reentrancy Vulnerability",
        "reason": "The `withdraw` function executes `plyr_[_pID].addr.transfer(_eth);` which can lead to reentrancy attacks if `_eth > 0`. Although `transfer` is generally safe due to the 2300 gas stipend, if there are fallback functions or if additional logic is added before or after, this could potentially be exploited. Additionally, the function modifies state variables after the transfer, which is not a recommended pattern.",
        "file_name": "0x37238583c041a2f51964f23fde2710c4fbd29e9e.sol"
    }
]