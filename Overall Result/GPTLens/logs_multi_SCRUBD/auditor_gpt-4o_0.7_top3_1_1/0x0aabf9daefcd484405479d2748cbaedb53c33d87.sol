[
    {
        "function_name": "swapAndLiquify",
        "code": "function swapAndLiquify(uint256 tokens) private {\n    uint256 marketFeeFull = tokens.mul(marketFee).div(100);\n    uint256 tokensAfterFee = tokens - marketFeeFull;\n    uint256 initHalf = tokens.div(2);\n    uint256 half = tokensAfterFee.div(2);\n    uint256 otherHalf = tokensAfterFee.sub(half);\n    uint256 initialBalance = address(this).balance;\n    swapTokensForEth(initHalf);\n    uint256 newBalance = address(this).balance.sub(initialBalance);\n    uint256 marketFeeBalance = newBalance.mul(marketFee).div(100);\n    uint256 finalBalance = newBalance - marketFeeBalance;\n    uint256 finalHalf = otherHalf;\n    if(marketTokenAddressForFee != address(0)){\n        swapEthForTokens(marketFeeBalance, marketTokenAddressForFee, marketAddress);\n    }else{\n        (bool sent,) = marketAddress.call{value: marketFeeBalance}(\"\");\n    }\n    addLiquidity(finalHalf, finalBalance);\n    emit SwapAndLiquify(half, finalBalance, otherHalf);\n}",
        "vulnerability": "Potential reentrancy vulnerability",
        "reason": "The function transfers Ether to the marketAddress using a low-level call, which can lead to reentrancy attacks if the receiving contract executes code upon receiving Ether. The function does not use the checks-effects-interactions pattern, making it vulnerable to such attacks.",
        "file_name": "0x0aabf9daefcd484405479d2748cbaedb53c33d87.sol"
    },
    {
        "function_name": "_transfer",
        "code": "function _transfer( address from, address to, uint256 amount ) internal override {\n    require(!_isBlacklisted[from], \"Blacklisted address cannot transfer!\");\n    require(!_isBlacklisted[to], \"Blacklisted address cannot transfer!\");\n    require(from != address(0), \"ERC20: transfer to the zero address\");\n    require(to != address(0), \"ERC20: transfer to the zero address\");\n    bool tradingIsEnabled = getTradingIsEnabled();\n    if(!tradingIsEnabled) {\n        require(canTransferBeforeTradingIsEnabled[from], \"MRFROG: This account cannot send tokens until trading is enabled\");\n    }\n    if(amount == 0) {\n        super._transfer(from, to, 0);\n        return;\n    }\n    bool buyOrSell = false;\n    if ( from != owner() && to != owner() && to != address(0) && to != address(0xdead) && to != uniswapV2Pair && automatedMarketMakerPairs[from] ) {\n        require( amount <= maxBuyTranscationAmount, \"Transfer amount exceeds the maxTxAmount.\" );\n        uint256 contractBalanceRecepient = balanceOf(to);\n        require( contractBalanceRecepient + amount <= _maxWalletToken, \"Exceeds maximum wallet token amount.\" );\n        previousMarketFee = marketFee;\n        previousTokenRewardsFee = tokenRewardsFee;\n        previousLiquidityFee = liquidityFee;\n        previousTotalFees = totalFees;\n        marketFee = buyMarketFee;\n        tokenRewardsFee = buyTokenRewardsFee;\n        liquidityFee = buyLiquidityFee;\n        totalFees = buyTotalFees;\n        buyOrSell = true;\n    }\n    if( !swapping && tradingIsEnabled && automatedMarketMakerPairs[to] && from != address(uniswapV2Router) && !_isExcludedFromFees[to] ) {\n        require(amount <= maxSellTransactionAmount, \"Sell transfer amount exceeds the maxSellTransactionAmount.\");\n        previousMarketFee = marketFee;\n        previousTokenRewardsFee = tokenRewardsFee;\n        previousLiquidityFee = liquidityFee;\n        previousTotalFees = totalFees;\n        marketFee = sellMarketFee;\n        tokenRewardsFee = sellTokenRewardsFee;\n        liquidityFee = sellLiquidityFee;\n        totalFees = sellTotalFees;\n        buyOrSell = true;\n    }\n    uint256 contractTokenBalance = balanceOf(address(this));\n    bool canSwap = contractTokenBalance >= swapTokensAtAmount;\n    if( tradingIsEnabled && canSwap && !swapping && !automatedMarketMakerPairs[from] && from != burnAddress && to != burnAddress ) {\n        swapping = true;\n        uint256 dividendAmount = swapTokensAtAmount.mul(tokenRewardsFee).div(100);\n        uint256 adminAmount = swapTokensAtAmount.sub(dividendAmount);\n        swapAndLiquify(adminAmount);\n        swapAndSendDividends(dividendAmount);\n        swapping = false;\n    }\n    bool takeFee = tradingIsEnabled && !swapping;\n    if(_isExcludedFromFees[from] || _isExcludedFromFees[to]) {\n        takeFee = false;\n    }\n    if(takeFee) {\n        uint256 fees = amount.mul(totalFees).div(100);\n        amount = amount.sub(fees);\n        super._transfer(from, address(this), fees);\n    }\n    super._transfer(from, to, amount);\n    restoreFees();\n    try dividendTracker.setBalance(payable(from), balanceOf(from)) {} catch {}\n    try dividendTracker.setBalance(payable(to), balanceOf(to)) {} catch {}\n    bool canDividend = block.timestamp >= processDividendTime;\n    if(!swapping && canDividend) {\n        uint256 gas = gasForProcessing;\n        processDividendTime += dividendTime;\n        try dividendTracker.process(gas) returns (uint256 iterations, uint256 claims, uint256 lastProcessedIndex) {\n            emit ProcessedDividendTracker(iterations, claims, lastProcessedIndex, true, gas, tx.origin);\n        } catch { }\n    }\n}",
        "vulnerability": "Trading restriction bypass",
        "reason": "The function allows certain addresses to trade before trading is enabled. This can lead to an unfair advantage and potential market manipulation, as those addresses can buy or sell tokens without restrictions while others cannot.",
        "file_name": "0x0aabf9daefcd484405479d2748cbaedb53c33d87.sol"
    },
    {
        "function_name": "distributeDividends",
        "code": "function distributeDividends() public override payable onlyMaster {\n    require(totalSupply() > 0);\n    if (msg.value > 0) {\n        magnifiedDividendPerShare = magnifiedDividendPerShare.add( (msg.value).mul(magnitude) / totalSupply() );\n        emit DividendsDistributed(msg.sender, msg.value);\n        totalDividendsDistributed = totalDividendsDistributed.add(msg.value);\n    }\n}",
        "vulnerability": "Dividend distribution reliance on external calls",
        "reason": "The function relies on the msg.value, which could be manipulated through reentrancy or incorrect calculations from the caller. This could lead to an incorrect distribution of dividends, providing an advantage to certain users or unfairly distributing the dividends.",
        "file_name": "0x0aabf9daefcd484405479d2748cbaedb53c33d87.sol"
    }
]